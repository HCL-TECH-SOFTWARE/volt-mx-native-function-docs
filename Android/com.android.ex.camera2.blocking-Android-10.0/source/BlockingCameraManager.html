<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='com-android-ex-camera2-blocking-BlockingCameraManager'>/**@class com.android.ex.camera2.blocking.BlockingCameraManager
</span>@extends java.lang.Object

 Expose {@link CameraManager} functionality with blocking functions.

 &lt;p&gt;Safe to use at the same time as the regular CameraManager, so this does not
 duplicate any functionality that is already blocking.&lt;/p&gt;

 &lt;p&gt;Be careful when using this from UI thread! This function will typically block
 for about 500ms when successful, and as long as {@value #OPEN_TIME_OUT_MS}ms when timing out.&lt;/p&gt;
*/
var BlockingCameraManager = {

<span id='com-android-ex-camera2-blocking-BlockingCameraManager-method-openCamera'>/**Open the camera, blocking it until it succeeds or fails.
</span>
 &lt;p&gt;Note that the Handler provided must not be null. Furthermore, if there is a handler,
 its Looper must not be the current thread's Looper. Otherwise we'd never receive
 the callbacks from the CameraDevice since this function would prevent them from being
 processed.&lt;/p&gt;

 &lt;p&gt;Throws {@link CameraAccessException} for the same reason {@link CameraManager#openCamera}
 does.&lt;/p&gt;

 &lt;p&gt;Throws {@link com.android.ex.camera2.blocking.BlockingCameraManager.BlockingOpenException} when the open fails asynchronously (due to
 {@link CameraDevice.StateCallback#onDisconnected(CameraDevice)} or
 ({@link CameraDevice.StateCallback#onError(CameraDevice)}.&lt;/p&gt;

 &lt;p&gt;Throws {@link TimeoutRuntimeException} if opening times out. This is usually
 highly unrecoverable, and all future calls to opening that camera will fail since the
 service will think it's busy. This class will do its best to clean up eventually.&lt;/p&gt;
@param {String} cameraId
            Id of the camera
@param {Object {CameraDevice.StateCallback}} listener
            Listener to the camera. onOpened, onDisconnected, onError need not be implemented.
@param {Object {Handler}} handler
            Handler which to run the listener on. Must not be null.
@return {Object {android.hardware.camera2.CameraDevice}} CameraDevice
@throws IllegalArgumentException
            If the handler is null, or if the handler's looper is current.
@throws CameraAccessException
            If open fails immediately.
@throws BlockingOpenException
            If open fails after blocking for some amount of time.
@throws TimeoutRuntimeException
            If opening times out. Typically unrecoverable.
*/
openCamera : function(  ) {},


};</pre>
</body>
</html>
