<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='javax-net-ssl-SSLSocketFactory'>/**@class javax.net.ssl.SSLSocketFactory
</span>@extends javax.net.SocketFactory

 &lt;code&gt;SSLSocketFactory&lt;/code&gt;s create &lt;code&gt;SSLSocket&lt;/code&gt;s.

 @since 1.4
 @see SSLSocket
 @author David Brownell
*/
var SSLSocketFactory = {

<span id='javax-net-ssl-SSLSocketFactory-method-getDefault'>/**Returns the default SSL socket factory.
</span>
 &lt;p&gt;The first time this method is called, the security property
 &quot;ssl.SocketFactory.provider&quot; is examined. If it is non-null, a class by
 that name is loaded and instantiated. If that is successful and the
 object is an instance of SSLSocketFactory, it is made the default SSL
 socket factory.

 &lt;p&gt;Otherwise, this method returns
 &lt;code&gt;SSLContext.getDefault().getSocketFactory()&lt;/code&gt;. If that
 call fails, an inoperative factory is returned.
@return {Object {javax.net.SocketFactory}} the default &lt;code&gt;SocketFactory&lt;/code&gt;
@see SSLContext#getDefault
*/
getDefault : function(  ) {},

<span id='javax-net-ssl-SSLSocketFactory-method-getDefaultCipherSuites'>/**Returns the list of cipher suites which are enabled by default.
</span> Unless a different list is enabled, handshaking on an SSL connection
 will use one of these cipher suites.  The minimum quality of service
 for these defaults requires confidentiality protection and server
 authentication (that is, no anonymous cipher suites).
@see #getSupportedCipherSuites()
@return {String} array of the cipher suites enabled by default
*/
getDefaultCipherSuites : function(  ) {},

<span id='javax-net-ssl-SSLSocketFactory-method-getSupportedCipherSuites'>/**Returns the names of the cipher suites which could be enabled for use
</span> on an SSL connection.  Normally, only a subset of these will actually
 be enabled by default, since this list may include cipher suites which
 do not meet quality of service requirements for those defaults.  Such
 cipher suites are useful in specialized applications.

 &lt;p class=&quot;caution&quot;&gt;Applications should not blindly enable all supported
 cipher suites.  The supported cipher suites can include signaling cipher suite
 values that can cause connection problems if enabled inappropriately.

 &lt;p&gt;The proper way to use this method is to either check if a specific cipher
 suite is supported via {@code Arrays.asList(getSupportedCipherSuites()).contains(...)}
 or to filter a desired list of cipher suites to only the supported ones via
 {@code desiredSuiteSet.retainAll(Arrays.asList(getSupportedCipherSuites()))}.
@see #getDefaultCipherSuites()
@return {String} an array of cipher suite names
*/
getSupportedCipherSuites : function(  ) {},

<span id='javax-net-ssl-SSLSocketFactory-method-createSocket'>/**Returns a socket layered over an existing socket connected to the named
</span> host, at the given port.  This constructor can be used when tunneling SSL
 through a proxy or when negotiating the use of SSL over an existing
 socket. The host and port refer to the logical peer destination.
 This socket is configured using the socket options established for
 this factory.
@param {Object {Socket}} s the existing socket
@param {String} host the server host
@param {Number} port the server port
@param {Boolean} autoClose close the underlying socket when this socket is closed
@return {Object {java.net.Socket}} a socket connected to the specified host and port
@throws IOException if an I/O error occurs when creating the socket
@throws NullPointerException if the parameter s is null
*/
createSocket : function(  ) {},

<span id='javax-net-ssl-SSLSocketFactory-method-createSocket'>/**Creates a server mode {@link Socket} layered over an
</span> existing connected socket, and is able to read data which has
 already been consumed/removed from the {@link Socket}'s
 underlying {@link InputStream}.
 &lt;p&gt;
 This method can be used by a server application that needs to
 observe the inbound data but still create valid SSL/TLS
 connections: for example, inspection of Server Name Indication
 (SNI) extensions (See section 3 of &lt;A
 HREF=&quot;http://www.ietf.org/rfc/rfc6066.txt&quot;&gt;TLS Extensions
 (RFC6066)&lt;/A&gt;).  Data that has been already removed from the
 underlying {@link InputStream} should be loaded into the
 {@code consumed} stream before this method is called, perhaps
 using a {@link java.io.ByteArrayInputStream}.  When this
 {@link Socket} begins handshaking, it will read all of the data in
 {@code consumed} until it reaches {@code EOF}, then all further
 data is read from the underlying {@link InputStream} as
 usual.
 &lt;p&gt;
 The returned socket is configured using the socket options
 established for this factory, and is set to use server mode when
 handshaking (see {@link javax.net.ssl.SSLSocket#setUseClientMode(boolean)}).
@param {Object {Socket}} s
         the existing socket
@param {Object {InputStream}} consumed
         the consumed inbound network data that has already been
         removed from the existing {@link Socket}
         {@link InputStream}.  This parameter may be
         {@code null} if no data has been removed.
@param {Boolean} autoClose close the underlying socket when this socket is closed.
@return {Object {java.net.Socket}} the {@link Socket} compliant with the socket options
         established for this factory
@throws IOException if an I/O error occurs when creating the socket
@throws UnsupportedOperationException if the underlying provider
         does not implement the operation
@throws NullPointerException if {@code s} is {@code null}
@since 1.8
@hide 
*/
createSocket : function(  ) {},


};</pre>
</body>
</html>
