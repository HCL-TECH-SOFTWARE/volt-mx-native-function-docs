<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='android-app-admin-DevicePolicyManagerInternal'>/**@class android.app.admin.DevicePolicyManagerInternal
</span>@extends java.lang.Object

 Device policy manager local system service interface.

 @hide Only for use within the system server.
*/
var DevicePolicyManagerInternal = {

<span id='android-app-admin-DevicePolicyManagerInternal-method-getCrossProfileWidgetProviders'>/**Gets the packages whose widget providers are white-listed to be
</span> available in the parent user.

 &lt;p&gt;This takes the DPMS lock.  DO NOT call from PM/UM/AM with their lock held.
@param {Number} profileId The profile id.
@return {Object {java.util.List}} The list of packages if such or empty list if there are
    no white-listed packages or the profile id is not a managed
    profile.
*/
getCrossProfileWidgetProviders : function(  ) {},

<span id='android-app-admin-DevicePolicyManagerInternal-method-addOnCrossProfileWidgetProvidersChangeListener'>/**Adds a listener for changes in the white-listed packages to show
</span> cross-profile app widgets.

 &lt;p&gt;This takes the DPMS lock.  DO NOT call from PM/UM/AM with their lock held.
@param {Object {DevicePolicyManagerInternal.OnCrossProfileWidgetProvidersChangeListener}} listener The listener to add.
*/
addOnCrossProfileWidgetProvidersChangeListener : function(  ) {},

<span id='android-app-admin-DevicePolicyManagerInternal-method-isActiveAdminWithPolicy'>/**Checks if an app with given uid is an active device admin of its user and has the policy
</span> specified.

 &lt;p&gt;This takes the DPMS lock.  DO NOT call from PM/UM/AM with their lock held.
@param {Number} uid App uid.
@param {Number} reqPolicy Required policy, for policies see {@link DevicePolicyManager}.
@return {Boolean} true if the uid is an active admin with the given policy.
*/
isActiveAdminWithPolicy : function(  ) {},

<span id='android-app-admin-DevicePolicyManagerInternal-method-createShowAdminSupportIntent'>/**Creates an intent to show the admin support dialog to say that an action is disallowed by
</span> the device/profile owner.

 &lt;p&gt;This method does not take the DPMS lock.  Safe to be called from anywhere.
@param {Number} userId The user where the action is disallowed.
@param {Boolean} useDefaultIfNoAdmin If true, a non-null intent will be returned, even if we couldn't
 find a profile/device owner.
@return {Object {android.content.Intent}} The intent to trigger the admin support dialog.
*/
createShowAdminSupportIntent : function(  ) {},

<span id='android-app-admin-DevicePolicyManagerInternal-method-createUserRestrictionSupportIntent'>/**Creates an intent to show the admin support dialog showing the admin who has set a user
</span> restriction.

 &lt;p&gt;This method does not take the DPMS lock. Safe to be called from anywhere.
@param {Number} userId The user where the user restriction is set.
@return {Object {android.content.Intent}} The intent to trigger the admin support dialog, or null if the user restriction is
 not enforced by the profile/device owner.
*/
createUserRestrictionSupportIntent : function(  ) {},

<span id='android-app-admin-DevicePolicyManagerInternal-method-isUserAffiliatedWithDevice'>/**Returns whether this user/profile is affiliated with the device.
</span>
 &lt;p&gt;
 By definition, the user that the device owner runs on is always affiliated with the device.
 Any other user/profile is considered affiliated with the device if the set specified by its
 profile owner via {@link android.app.admin.DevicePolicyManager#setAffiliationIds} intersects with the device
 owner's.
 &lt;p&gt;
 Profile owner on the primary user will never be considered as affiliated as there is no
 device owner to be affiliated with.
*/
isUserAffiliatedWithDevice : function(  ) {},

<span id='android-app-admin-DevicePolicyManagerInternal-method-canSilentlyInstallPackage'>/**Returns whether the calling package can install or uninstall packages without user
</span> interaction.
*/
canSilentlyInstallPackage : function(  ) {},

<span id='android-app-admin-DevicePolicyManagerInternal-method-reportSeparateProfileChallengeChanged'>/**Reports that a profile has changed to use a unified or separate credential.
</span>@param {Number} userId User ID of the profile.
*/
reportSeparateProfileChallengeChanged : function(  ) {},

<span id='android-app-admin-DevicePolicyManagerInternal-method-canUserHaveUntrustedCredentialReset'>/**Check whether the user could have their password reset in an untrusted manor due to there
</span> being an admin which can call {@link #resetPassword} to reset the password without knowledge
 of the previous password.
@param {Number} userId The user in question
*/
canUserHaveUntrustedCredentialReset : function(  ) {},

<span id='android-app-admin-DevicePolicyManagerInternal-method-getPrintingDisabledReasonForUser'>/**Return text of error message if printing is disabled.
</span> Called by Print Service when printing is disabled by PO or DO when printing is attempted.
@param {Number} userId The user in question
@return {Object {java.lang.CharSequence}} localized error message
*/
getPrintingDisabledReasonForUser : function(  ) {},


};</pre>
</body>
</html>
