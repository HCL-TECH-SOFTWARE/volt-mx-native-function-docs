<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='android-graphics-ImageFormat'>/**@class android.graphics.ImageFormat
</span>@extends java.lang.Object

*/
var ImageFormat = {

<span id='android-graphics-ImageFormat-property-UNKNOWN'>/***/
</span>UNKNOWN : &quot;0&quot;,
<span id='android-graphics-ImageFormat-property-RGB_565'>/** RGB format used for pictures encoded as RGB_565. See
</span> {@link android.hardware.Camera.Parameters#setPictureFormat(int)}.
*/
RGB_565 : &quot;4&quot;,
<span id='android-graphics-ImageFormat-property-YV12'>/** &lt;p&gt;Android YUV format.&lt;/p&gt;
</span>
 &lt;p&gt;This format is exposed to software decoders and applications.&lt;/p&gt;

 &lt;p&gt;YV12 is a 4:2:0 YCrCb planar format comprised of a WxH Y plane followed
 by (W/2) x (H/2) Cr and Cb planes.&lt;/p&gt;

 &lt;p&gt;This format assumes
 &lt;ul&gt;
 &lt;li&gt;an even width&lt;/li&gt;
 &lt;li&gt;an even height&lt;/li&gt;
 &lt;li&gt;a horizontal stride multiple of 16 pixels&lt;/li&gt;
 &lt;li&gt;a vertical stride equal to the height&lt;/li&gt;
 &lt;/ul&gt;
 &lt;/p&gt;

 &lt;pre&gt; y_size = stride * height
 c_stride = ALIGN(stride/2, 16)
 c_size = c_stride * height/2
 size = y_size + c_size * 2
 cr_offset = y_size
 cb_offset = y_size + c_size&lt;/pre&gt;

 &lt;p&gt;For the {@link android.hardware.camera2} API, the {@link #YUV_420_888} format is
 recommended for YUV output instead.&lt;/p&gt;

 &lt;p&gt;For the older camera API, this format is guaranteed to be supported for
 {@link android.hardware.Camera} preview images since API level 12; for earlier API versions,
 check {@link android.hardware.Camera.Parameters#getSupportedPreviewFormats()}.

 &lt;p&gt;Note that for camera preview callback use (see
 {@link android.hardware.Camera#setPreviewCallback}), the
 &lt;var&gt;stride&lt;/var&gt; value is the smallest possible; that is, it is equal
 to:

 &lt;pre&gt;stride = ALIGN(width, 16)&lt;/pre&gt;

 @see android.hardware.Camera.Parameters#setPreviewCallback
 @see android.hardware.Camera.Parameters#setPreviewFormat
 @see android.hardware.Camera.Parameters#getSupportedPreviewFormats
 &lt;/p&gt;
*/
YV12 : &quot;842094169&quot;,
<span id='android-graphics-ImageFormat-property-Y8'>/** &lt;p&gt;Android Y8 format.&lt;/p&gt;
</span>
 &lt;p&gt;Y8 is a YUV planar format comprised of a WxH Y plane only, with each pixel
 being represented by 8 bits. It is equivalent to just the Y plane from {@link #YV12}
 format.&lt;/p&gt;

 &lt;p&gt;This format assumes
 &lt;ul&gt;
 &lt;li&gt;an even width&lt;/li&gt;
 &lt;li&gt;an even height&lt;/li&gt;
 &lt;li&gt;a horizontal stride multiple of 16 pixels&lt;/li&gt;
 &lt;/ul&gt;
 &lt;/p&gt;

 &lt;pre&gt; size = stride * height &lt;/pre&gt;

 &lt;p&gt;For example, the {@link android.media.Image} object can provide data
 in this format from a {@link android.hardware.camera2.CameraDevice} (if
 supported) through a {@link android.media.ImageReader} object. The
 {@link android.media.Image#getPlanes() Image#getPlanes()} will return a
 single plane containing the pixel data. The pixel stride is always 1 in
 {@link android.media.Image.Plane#getPixelStride()}, and the
 {@link android.media.Image.Plane#getRowStride()} describes the vertical
 neighboring pixel distance (in bytes) between adjacent rows.&lt;/p&gt;

 @see android.media.Image
 @see android.media.ImageReader
 @see android.hardware.camera2.CameraDevice
*/
Y8 : &quot;538982489&quot;,
<span id='android-graphics-ImageFormat-property-Y16'>/** &lt;p&gt;Android Y16 format.&lt;/p&gt;
</span>
 Y16 is a YUV planar format comprised of a WxH Y plane, with each pixel
 being represented by 16 bits. It is just like {@link #Y8}, but has 16
 bits per pixel (little endian).&lt;/p&gt;

 &lt;p&gt;This format assumes
 &lt;ul&gt;
 &lt;li&gt;an even width&lt;/li&gt;
 &lt;li&gt;an even height&lt;/li&gt;
 &lt;li&gt;a horizontal stride multiple of 16 pixels&lt;/li&gt;
 &lt;/ul&gt;
 &lt;/p&gt;

 &lt;pre&gt; y_size = stride * height &lt;/pre&gt;

 &lt;p&gt;For example, the {@link android.media.Image} object can provide data
 in this format from a {@link android.hardware.camera2.CameraDevice}
 through a {@link android.media.ImageReader} object if this format is
 supported by {@link android.hardware.camera2.CameraDevice}.&lt;/p&gt;

 @see android.media.Image
 @see android.media.ImageReader
 @see android.hardware.camera2.CameraDevice

 @hide
*/
Y16 : &quot;540422489&quot;,
<span id='android-graphics-ImageFormat-property-NV16'>/** YCbCr format, used for video.
</span>
 &lt;p&gt;For the {@link android.hardware.camera2} API, the {@link #YUV_420_888} format is
 recommended for YUV output instead.&lt;/p&gt;

 &lt;p&gt;Whether this format is supported by the old camera API can be determined by
 {@link android.hardware.Camera.Parameters#getSupportedPreviewFormats()}.&lt;/p&gt;

*/
NV16 : &quot;16&quot;,
<span id='android-graphics-ImageFormat-property-NV21'>/** YCrCb format used for images, which uses the NV21 encoding format.
</span>
 &lt;p&gt;This is the default format
 for {@link android.hardware.Camera} preview images, when not otherwise set with
 {@link android.hardware.Camera.Parameters#setPreviewFormat(int)}.&lt;/p&gt;

 &lt;p&gt;For the {@link android.hardware.camera2} API, the {@link #YUV_420_888} format is
 recommended for YUV output instead.&lt;/p&gt;
*/
NV21 : &quot;17&quot;,
<span id='android-graphics-ImageFormat-property-YUY2'>/** YCbCr format used for images, which uses YUYV (YUY2) encoding format.
</span>
 &lt;p&gt;For the {@link android.hardware.camera2} API, the {@link #YUV_420_888} format is
 recommended for YUV output instead.&lt;/p&gt;

 &lt;p&gt;This is an alternative format for {@link android.hardware.Camera} preview images. Whether
 this format is supported by the camera hardware can be determined by
 {@link android.hardware.Camera.Parameters#getSupportedPreviewFormats()}.&lt;/p&gt;
*/
YUY2 : &quot;20&quot;,
<span id='android-graphics-ImageFormat-property-JPEG'>/** Compressed JPEG format.
</span>
 &lt;p&gt;This format is always supported as an output format for the
 {@link android.hardware.camera2} API, and as a picture format for the older
 {@link android.hardware.Camera} API&lt;/p&gt;
*/
JPEG : &quot;256&quot;,
<span id='android-graphics-ImageFormat-property-DEPTH_JPEG'>/** Depth augmented compressed JPEG format.
</span>
 &lt;p&gt;JPEG compressed main image along with XMP embedded depth metadata
 following ISO 16684-1:2011(E).&lt;/p&gt;
*/
DEPTH_JPEG : &quot;1768253795&quot;,
<span id='android-graphics-ImageFormat-property-YUV_420_888'>/** &lt;p&gt;Multi-plane Android YUV 420 format&lt;/p&gt;
</span>
 &lt;p&gt;This format is a generic YCbCr format, capable of describing any 4:2:0
 chroma-subsampled planar or semiplanar buffer (but not fully interleaved),
 with 8 bits per color sample.&lt;/p&gt;

 &lt;p&gt;Images in this format are always represented by three separate buffers
 of data, one for each color plane. Additional information always
 accompanies the buffers, describing the row stride and the pixel stride
 for each plane.&lt;/p&gt;

 &lt;p&gt;The order of planes in the array returned by
 {@link android.media.Image#getPlanes() Image#getPlanes()} is guaranteed such that
 plane #0 is always Y, plane #1 is always U (Cb), and plane #2 is always V (Cr).&lt;/p&gt;

 &lt;p&gt;The Y-plane is guaranteed not to be interleaved with the U/V planes
 (in particular, pixel stride is always 1 in
 {@link android.media.Image.Plane#getPixelStride() yPlane.getPixelStride()}).&lt;/p&gt;

 &lt;p&gt;The U/V planes are guaranteed to have the same row stride and pixel stride
 (in particular,
 {@link android.media.Image.Plane#getRowStride() uPlane.getRowStride()}
 == {@link android.media.Image.Plane#getRowStride() vPlane.getRowStride()} and
 {@link android.media.Image.Plane#getPixelStride() uPlane.getPixelStride()}
 == {@link android.media.Image.Plane#getPixelStride() vPlane.getPixelStride()};
 ).&lt;/p&gt;

 &lt;p&gt;For example, the {@link android.media.Image} object can provide data
 in this format from a {@link android.hardware.camera2.CameraDevice}
 through a {@link android.media.ImageReader} object.&lt;/p&gt;

 @see android.media.Image
 @see android.media.ImageReader
 @see android.hardware.camera2.CameraDevice
*/
YUV_420_888 : &quot;35&quot;,
<span id='android-graphics-ImageFormat-property-YUV_422_888'>/** &lt;p&gt;Multi-plane Android YUV 422 format&lt;/p&gt;
</span>
 &lt;p&gt;This format is a generic YCbCr format, capable of describing any 4:2:2
 chroma-subsampled (planar, semiplanar or interleaved) format,
 with 8 bits per color sample.&lt;/p&gt;

 &lt;p&gt;Images in this format are always represented by three separate buffers
 of data, one for each color plane. Additional information always
 accompanies the buffers, describing the row stride and the pixel stride
 for each plane.&lt;/p&gt;

 &lt;p&gt;The order of planes in the array returned by
 {@link android.media.Image#getPlanes() Image#getPlanes()} is guaranteed such that
 plane #0 is always Y, plane #1 is always U (Cb), and plane #2 is always V (Cr).&lt;/p&gt;

 &lt;p&gt;In contrast to the {@link #YUV_420_888} format, the Y-plane may have a pixel
 stride greater than 1 in
 {@link android.media.Image.Plane#getPixelStride() yPlane.getPixelStride()}.&lt;/p&gt;

 &lt;p&gt;The U/V planes are guaranteed to have the same row stride and pixel stride
 (in particular,
 {@link android.media.Image.Plane#getRowStride() uPlane.getRowStride()}
 == {@link android.media.Image.Plane#getRowStride() vPlane.getRowStride()} and
 {@link android.media.Image.Plane#getPixelStride() uPlane.getPixelStride()}
 == {@link android.media.Image.Plane#getPixelStride() vPlane.getPixelStride()};
 ).&lt;/p&gt;

 &lt;p&gt;For example, the {@link android.media.Image} object can provide data
 in this format from a {@link android.media.MediaCodec}
 through {@link android.media.MediaCodec#getOutputImage} object.&lt;/p&gt;

 @see android.media.Image
 @see android.media.MediaCodec
*/
YUV_422_888 : &quot;39&quot;,
<span id='android-graphics-ImageFormat-property-YUV_444_888'>/** &lt;p&gt;Multi-plane Android YUV 444 format&lt;/p&gt;
</span>
 &lt;p&gt;This format is a generic YCbCr format, capable of describing any 4:4:4
 (planar, semiplanar or interleaved) format,
 with 8 bits per color sample.&lt;/p&gt;

 &lt;p&gt;Images in this format are always represented by three separate buffers
 of data, one for each color plane. Additional information always
 accompanies the buffers, describing the row stride and the pixel stride
 for each plane.&lt;/p&gt;

 &lt;p&gt;The order of planes in the array returned by
 {@link android.media.Image#getPlanes() Image#getPlanes()} is guaranteed such that
 plane #0 is always Y, plane #1 is always U (Cb), and plane #2 is always V (Cr).&lt;/p&gt;

 &lt;p&gt;In contrast to the {@link #YUV_420_888} format, the Y-plane may have a pixel
 stride greater than 1 in
 {@link android.media.Image.Plane#getPixelStride() yPlane.getPixelStride()}.&lt;/p&gt;

 &lt;p&gt;The U/V planes are guaranteed to have the same row stride and pixel stride
 (in particular,
 {@link android.media.Image.Plane#getRowStride() uPlane.getRowStride()}
 == {@link android.media.Image.Plane#getRowStride() vPlane.getRowStride()} and
 {@link android.media.Image.Plane#getPixelStride() uPlane.getPixelStride()}
 == {@link android.media.Image.Plane#getPixelStride() vPlane.getPixelStride()};
 ).&lt;/p&gt;

 &lt;p&gt;For example, the {@link android.media.Image} object can provide data
 in this format from a {@link android.media.MediaCodec}
 through {@link android.media.MediaCodec#getOutputImage} object.&lt;/p&gt;

 @see android.media.Image
 @see android.media.MediaCodec
*/
YUV_444_888 : &quot;40&quot;,
<span id='android-graphics-ImageFormat-property-FLEX_RGB_888'>/** &lt;p&gt;Multi-plane Android RGB format&lt;/p&gt;
</span>
 &lt;p&gt;This format is a generic RGB format, capable of describing most RGB formats,
 with 8 bits per color sample.&lt;/p&gt;

 &lt;p&gt;Images in this format are always represented by three separate buffers
 of data, one for each color plane. Additional information always
 accompanies the buffers, describing the row stride and the pixel stride
 for each plane.&lt;/p&gt;

 &lt;p&gt;The order of planes in the array returned by
 {@link android.media.Image#getPlanes() Image#getPlanes()} is guaranteed such that
 plane #0 is always R (red), plane #1 is always G (green), and plane #2 is always B
 (blue).&lt;/p&gt;

 &lt;p&gt;All three planes are guaranteed to have the same row strides and pixel strides.&lt;/p&gt;

 &lt;p&gt;For example, the {@link android.media.Image} object can provide data
 in this format from a {@link android.media.MediaCodec}
 through {@link android.media.MediaCodec#getOutputImage} object.&lt;/p&gt;

 @see android.media.Image
 @see android.media.MediaCodec
*/
FLEX_RGB_888 : &quot;41&quot;,
<span id='android-graphics-ImageFormat-property-FLEX_RGBA_8888'>/** &lt;p&gt;Multi-plane Android RGBA format&lt;/p&gt;
</span>
 &lt;p&gt;This format is a generic RGBA format, capable of describing most RGBA formats,
 with 8 bits per color sample.&lt;/p&gt;

 &lt;p&gt;Images in this format are always represented by four separate buffers
 of data, one for each color plane. Additional information always
 accompanies the buffers, describing the row stride and the pixel stride
 for each plane.&lt;/p&gt;

 &lt;p&gt;The order of planes in the array returned by
 {@link android.media.Image#getPlanes() Image#getPlanes()} is guaranteed such that
 plane #0 is always R (red), plane #1 is always G (green), plane #2 is always B (blue),
 and plane #3 is always A (alpha). This format may represent pre-multiplied or
 non-premultiplied alpha.&lt;/p&gt;

 &lt;p&gt;All four planes are guaranteed to have the same row strides and pixel strides.&lt;/p&gt;

 &lt;p&gt;For example, the {@link android.media.Image} object can provide data
 in this format from a {@link android.media.MediaCodec}
 through {@link android.media.MediaCodec#getOutputImage} object.&lt;/p&gt;

 @see android.media.Image
 @see android.media.MediaCodec
*/
FLEX_RGBA_8888 : &quot;42&quot;,
<span id='android-graphics-ImageFormat-property-RAW_SENSOR'>/** &lt;p&gt;General raw camera sensor image format, usually representing a
</span> single-channel Bayer-mosaic image. Each pixel color sample is stored with
 16 bits of precision.&lt;/p&gt;

 &lt;p&gt;The layout of the color mosaic, the maximum and minimum encoding
 values of the raw pixel data, the color space of the image, and all other
 needed information to interpret a raw sensor image must be queried from
 the {@link android.hardware.camera2.CameraDevice} which produced the
 image.&lt;/p&gt;
*/
RAW_SENSOR : &quot;32&quot;,
<span id='android-graphics-ImageFormat-property-RAW_PRIVATE'>/** &lt;p&gt;Private raw camera sensor image format, a single channel image with
</span> implementation depedent pixel layout.&lt;/p&gt;

 &lt;p&gt;RAW_PRIVATE is a format for unprocessed raw image buffers coming from an
 image sensor. The actual structure of buffers of this format is
 implementation-dependent.&lt;/p&gt;

*/
RAW_PRIVATE : &quot;36&quot;,
<span id='android-graphics-ImageFormat-property-RAW10'>/** &lt;p&gt;
</span> Android 10-bit raw format
 &lt;/p&gt;
 &lt;p&gt;
 This is a single-plane, 10-bit per pixel, densely packed (in each row),
 unprocessed format, usually representing raw Bayer-pattern images coming
 from an image sensor.
 &lt;/p&gt;
 &lt;p&gt;
 In an image buffer with this format, starting from the first pixel of
 each row, each 4 consecutive pixels are packed into 5 bytes (40 bits).
 Each one of the first 4 bytes contains the top 8 bits of each pixel, The
 fifth byte contains the 2 least significant bits of the 4 pixels, the
 exact layout data for each 4 consecutive pixels is illustrated below
 ({@code Pi[j]} stands for the jth bit of the ith pixel):
 &lt;/p&gt;
 &lt;table&gt;
 &lt;thead&gt;
 &lt;tr&gt;
 &lt;th align=&quot;center&quot;&gt;&lt;/th&gt;
 &lt;th align=&quot;center&quot;&gt;bit 7&lt;/th&gt;
 &lt;th align=&quot;center&quot;&gt;bit 6&lt;/th&gt;
 &lt;th align=&quot;center&quot;&gt;bit 5&lt;/th&gt;
 &lt;th align=&quot;center&quot;&gt;bit 4&lt;/th&gt;
 &lt;th align=&quot;center&quot;&gt;bit 3&lt;/th&gt;
 &lt;th align=&quot;center&quot;&gt;bit 2&lt;/th&gt;
 &lt;th align=&quot;center&quot;&gt;bit 1&lt;/th&gt;
 &lt;th align=&quot;center&quot;&gt;bit 0&lt;/th&gt;
 &lt;/tr&gt;
 &lt;/thead&gt; &lt;tbody&gt;
 &lt;tr&gt;
 &lt;td align=&quot;center&quot;&gt;Byte 0:&lt;/td&gt;
 &lt;td align=&quot;center&quot;&gt;P0[9]&lt;/td&gt;
 &lt;td align=&quot;center&quot;&gt;P0[8]&lt;/td&gt;
 &lt;td align=&quot;center&quot;&gt;P0[7]&lt;/td&gt;
 &lt;td align=&quot;center&quot;&gt;P0[6]&lt;/td&gt;
 &lt;td align=&quot;center&quot;&gt;P0[5]&lt;/td&gt;
 &lt;td align=&quot;center&quot;&gt;P0[4]&lt;/td&gt;
 &lt;td align=&quot;center&quot;&gt;P0[3]&lt;/td&gt;
 &lt;td align=&quot;center&quot;&gt;P0[2]&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td align=&quot;center&quot;&gt;Byte 1:&lt;/td&gt;
 &lt;td align=&quot;center&quot;&gt;P1[9]&lt;/td&gt;
 &lt;td align=&quot;center&quot;&gt;P1[8]&lt;/td&gt;
 &lt;td align=&quot;center&quot;&gt;P1[7]&lt;/td&gt;
 &lt;td align=&quot;center&quot;&gt;P1[6]&lt;/td&gt;
 &lt;td align=&quot;center&quot;&gt;P1[5]&lt;/td&gt;
 &lt;td align=&quot;center&quot;&gt;P1[4]&lt;/td&gt;
 &lt;td align=&quot;center&quot;&gt;P1[3]&lt;/td&gt;
 &lt;td align=&quot;center&quot;&gt;P1[2]&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td align=&quot;center&quot;&gt;Byte 2:&lt;/td&gt;
 &lt;td align=&quot;center&quot;&gt;P2[9]&lt;/td&gt;
 &lt;td align=&quot;center&quot;&gt;P2[8]&lt;/td&gt;
 &lt;td align=&quot;center&quot;&gt;P2[7]&lt;/td&gt;
 &lt;td align=&quot;center&quot;&gt;P2[6]&lt;/td&gt;
 &lt;td align=&quot;center&quot;&gt;P2[5]&lt;/td&gt;
 &lt;td align=&quot;center&quot;&gt;P2[4]&lt;/td&gt;
 &lt;td align=&quot;center&quot;&gt;P2[3]&lt;/td&gt;
 &lt;td align=&quot;center&quot;&gt;P2[2]&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td align=&quot;center&quot;&gt;Byte 3:&lt;/td&gt;
 &lt;td align=&quot;center&quot;&gt;P3[9]&lt;/td&gt;
 &lt;td align=&quot;center&quot;&gt;P3[8]&lt;/td&gt;
 &lt;td align=&quot;center&quot;&gt;P3[7]&lt;/td&gt;
 &lt;td align=&quot;center&quot;&gt;P3[6]&lt;/td&gt;
 &lt;td align=&quot;center&quot;&gt;P3[5]&lt;/td&gt;
 &lt;td align=&quot;center&quot;&gt;P3[4]&lt;/td&gt;
 &lt;td align=&quot;center&quot;&gt;P3[3]&lt;/td&gt;
 &lt;td align=&quot;center&quot;&gt;P3[2]&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td align=&quot;center&quot;&gt;Byte 4:&lt;/td&gt;
 &lt;td align=&quot;center&quot;&gt;P3[1]&lt;/td&gt;
 &lt;td align=&quot;center&quot;&gt;P3[0]&lt;/td&gt;
 &lt;td align=&quot;center&quot;&gt;P2[1]&lt;/td&gt;
 &lt;td align=&quot;center&quot;&gt;P2[0]&lt;/td&gt;
 &lt;td align=&quot;center&quot;&gt;P1[1]&lt;/td&gt;
 &lt;td align=&quot;center&quot;&gt;P1[0]&lt;/td&gt;
 &lt;td align=&quot;center&quot;&gt;P0[1]&lt;/td&gt;
 &lt;td align=&quot;center&quot;&gt;P0[0]&lt;/td&gt;
 &lt;/tr&gt;
 &lt;/tbody&gt;
 &lt;/table&gt;
 &lt;p&gt;
 This format assumes
 &lt;ul&gt;
 &lt;li&gt;a width multiple of 4 pixels&lt;/li&gt;
 &lt;li&gt;an even height&lt;/li&gt;
 &lt;/ul&gt;
 &lt;/p&gt;

 &lt;pre&gt;size = row stride * height&lt;/pre&gt; where the row stride is in &lt;em&gt;bytes&lt;/em&gt;,
 not pixels.

 &lt;p&gt;
 Since this is a densely packed format, the pixel stride is always 0. The
 application must use the pixel data layout defined in above table to
 access each row data. When row stride is equal to {@code width * (10 / 8)}, there
 will be no padding bytes at the end of each row, the entire image data is
 densely packed. When stride is larger than {@code width * (10 / 8)}, padding
 bytes will be present at the end of each row.
 &lt;/p&gt;
 &lt;p&gt;
 For example, the {@link android.media.Image} object can provide data in
 this format from a {@link android.hardware.camera2.CameraDevice} (if
 supported) through a {@link android.media.ImageReader} object. The
 {@link android.media.Image#getPlanes() Image#getPlanes()} will return a
 single plane containing the pixel data. The pixel stride is always 0 in
 {@link android.media.Image.Plane#getPixelStride()}, and the
 {@link android.media.Image.Plane#getRowStride()} describes the vertical
 neighboring pixel distance (in bytes) between adjacent rows.
 &lt;/p&gt;

 @see android.media.Image
 @see android.media.ImageReader
 @see android.hardware.camera2.CameraDevice
*/
RAW10 : &quot;37&quot;,
<span id='android-graphics-ImageFormat-property-RAW12'>/** &lt;p&gt;
</span> Android 12-bit raw format
 &lt;/p&gt;
 &lt;p&gt;
 This is a single-plane, 12-bit per pixel, densely packed (in each row),
 unprocessed format, usually representing raw Bayer-pattern images coming
 from an image sensor.
 &lt;/p&gt;
 &lt;p&gt;
 In an image buffer with this format, starting from the first pixel of each
 row, each two consecutive pixels are packed into 3 bytes (24 bits). The first
 and second byte contains the top 8 bits of first and second pixel. The third
 byte contains the 4 least significant bits of the two pixels, the exact layout
 data for each two consecutive pixels is illustrated below (Pi[j] stands for
 the jth bit of the ith pixel):
 &lt;/p&gt;
 &lt;table&gt;
 &lt;thead&gt;
 &lt;tr&gt;
 &lt;th align=&quot;center&quot;&gt;&lt;/th&gt;
 &lt;th align=&quot;center&quot;&gt;bit 7&lt;/th&gt;
 &lt;th align=&quot;center&quot;&gt;bit 6&lt;/th&gt;
 &lt;th align=&quot;center&quot;&gt;bit 5&lt;/th&gt;
 &lt;th align=&quot;center&quot;&gt;bit 4&lt;/th&gt;
 &lt;th align=&quot;center&quot;&gt;bit 3&lt;/th&gt;
 &lt;th align=&quot;center&quot;&gt;bit 2&lt;/th&gt;
 &lt;th align=&quot;center&quot;&gt;bit 1&lt;/th&gt;
 &lt;th align=&quot;center&quot;&gt;bit 0&lt;/th&gt;
 &lt;/tr&gt;
 &lt;/thead&gt; &lt;tbody&gt;
 &lt;tr&gt;
 &lt;td align=&quot;center&quot;&gt;Byte 0:&lt;/td&gt;
 &lt;td align=&quot;center&quot;&gt;P0[11]&lt;/td&gt;
 &lt;td align=&quot;center&quot;&gt;P0[10]&lt;/td&gt;
 &lt;td align=&quot;center&quot;&gt;P0[ 9]&lt;/td&gt;
 &lt;td align=&quot;center&quot;&gt;P0[ 8]&lt;/td&gt;
 &lt;td align=&quot;center&quot;&gt;P0[ 7]&lt;/td&gt;
 &lt;td align=&quot;center&quot;&gt;P0[ 6]&lt;/td&gt;
 &lt;td align=&quot;center&quot;&gt;P0[ 5]&lt;/td&gt;
 &lt;td align=&quot;center&quot;&gt;P0[ 4]&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td align=&quot;center&quot;&gt;Byte 1:&lt;/td&gt;
 &lt;td align=&quot;center&quot;&gt;P1[11]&lt;/td&gt;
 &lt;td align=&quot;center&quot;&gt;P1[10]&lt;/td&gt;
 &lt;td align=&quot;center&quot;&gt;P1[ 9]&lt;/td&gt;
 &lt;td align=&quot;center&quot;&gt;P1[ 8]&lt;/td&gt;
 &lt;td align=&quot;center&quot;&gt;P1[ 7]&lt;/td&gt;
 &lt;td align=&quot;center&quot;&gt;P1[ 6]&lt;/td&gt;
 &lt;td align=&quot;center&quot;&gt;P1[ 5]&lt;/td&gt;
 &lt;td align=&quot;center&quot;&gt;P1[ 4]&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td align=&quot;center&quot;&gt;Byte 2:&lt;/td&gt;
 &lt;td align=&quot;center&quot;&gt;P1[ 3]&lt;/td&gt;
 &lt;td align=&quot;center&quot;&gt;P1[ 2]&lt;/td&gt;
 &lt;td align=&quot;center&quot;&gt;P1[ 1]&lt;/td&gt;
 &lt;td align=&quot;center&quot;&gt;P1[ 0]&lt;/td&gt;
 &lt;td align=&quot;center&quot;&gt;P0[ 3]&lt;/td&gt;
 &lt;td align=&quot;center&quot;&gt;P0[ 2]&lt;/td&gt;
 &lt;td align=&quot;center&quot;&gt;P0[ 1]&lt;/td&gt;
 &lt;td align=&quot;center&quot;&gt;P0[ 0]&lt;/td&gt;
 &lt;/tr&gt;
 &lt;/tbody&gt;
 &lt;/table&gt;
 &lt;p&gt;
 This format assumes
 &lt;ul&gt;
 &lt;li&gt;a width multiple of 4 pixels&lt;/li&gt;
 &lt;li&gt;an even height&lt;/li&gt;
 &lt;/ul&gt;
 &lt;/p&gt;

 &lt;pre&gt;size = row stride * height&lt;/pre&gt; where the row stride is in &lt;em&gt;bytes&lt;/em&gt;,
 not pixels.

 &lt;p&gt;
 Since this is a densely packed format, the pixel stride is always 0. The
 application must use the pixel data layout defined in above table to
 access each row data. When row stride is equal to {@code width * (12 / 8)}, there
 will be no padding bytes at the end of each row, the entire image data is
 densely packed. When stride is larger than {@code width * (12 / 8)}, padding
 bytes will be present at the end of each row.
 &lt;/p&gt;
 &lt;p&gt;
 For example, the {@link android.media.Image} object can provide data in
 this format from a {@link android.hardware.camera2.CameraDevice} (if
 supported) through a {@link android.media.ImageReader} object. The
 {@link android.media.Image#getPlanes() Image#getPlanes()} will return a
 single plane containing the pixel data. The pixel stride is always 0 in
 {@link android.media.Image.Plane#getPixelStride()}, and the
 {@link android.media.Image.Plane#getRowStride()} describes the vertical
 neighboring pixel distance (in bytes) between adjacent rows.
 &lt;/p&gt;

 @see android.media.Image
 @see android.media.ImageReader
 @see android.hardware.camera2.CameraDevice
*/
RAW12 : &quot;38&quot;,
<span id='android-graphics-ImageFormat-property-DEPTH16'>/** &lt;p&gt;Android dense depth image format.&lt;/p&gt;
</span>
 &lt;p&gt;Each pixel is 16 bits, representing a depth ranging measurement from a depth camera or
 similar sensor. The 16-bit sample consists of a confidence value and the actual ranging
 measurement.&lt;/p&gt;

 &lt;p&gt;The confidence value is an estimate of correctness for this sample.  It is encoded in the
 3 most significant bits of the sample, with a value of 0 representing 100% confidence, a
 value of 1 representing 0% confidence, a value of 2 representing 1/7, a value of 3
 representing 2/7, and so on.&lt;/p&gt;

 &lt;p&gt;As an example, the following sample extracts the range and confidence from the first pixel
 of a DEPTH16-format {@link android.media.Image}, and converts the confidence to a
 floating-point value between 0 and 1.f inclusive, with 1.f representing maximum confidence:

 &lt;pre&gt;
    ShortBuffer shortDepthBuffer = img.getPlanes()[0].getBuffer().asShortBuffer();
    short depthSample = shortDepthBuffer.get()
    short depthRange = (short) (depthSample &amp; 0x1FFF);
    short depthConfidence = (short) ((depthSample &gt;&gt; 13) &amp; 0x7);
    float depthPercentage = depthConfidence == 0 ? 1.f : (depthConfidence - 1) / 7.f;
 &lt;/pre&gt;
 &lt;/p&gt;

 &lt;p&gt;This format assumes
 &lt;ul&gt;
 &lt;li&gt;an even width&lt;/li&gt;
 &lt;li&gt;an even height&lt;/li&gt;
 &lt;li&gt;a horizontal stride multiple of 16 pixels&lt;/li&gt;
 &lt;/ul&gt;
 &lt;/p&gt;

 &lt;pre&gt; y_size = stride * height &lt;/pre&gt;

 When produced by a camera, the units for the range are millimeters.
*/
DEPTH16 : &quot;1144402265&quot;,
<span id='android-graphics-ImageFormat-property-DEPTH_POINT_CLOUD'>/** Android sparse depth point cloud format.
</span>
 &lt;p&gt;A variable-length list of 3D points plus a confidence value, with each point represented
 by four floats; first the X, Y, Z position coordinates, and then the confidence value.&lt;/p&gt;

 &lt;p&gt;The number of points is {@code (size of the buffer in bytes) / 16}.

 &lt;p&gt;The coordinate system and units of the position values depend on the source of the point
 cloud data. The confidence value is between 0.f and 1.f, inclusive, with 0 representing 0%
 confidence and 1.f representing 100% confidence in the measured position values.&lt;/p&gt;

 &lt;p&gt;As an example, the following code extracts the first depth point in a DEPTH_POINT_CLOUD
 format {@link android.media.Image}:
 &lt;pre&gt;
    FloatBuffer floatDepthBuffer = img.getPlanes()[0].getBuffer().asFloatBuffer();
    float x = floatDepthBuffer.get();
    float y = floatDepthBuffer.get();
    float z = floatDepthBuffer.get();
    float confidence = floatDepthBuffer.get();
 &lt;/pre&gt;

 For camera devices that support the
 {@link android.hardware.camera2.CameraCharacteristics#REQUEST_AVAILABLE_CAPABILITIES_DEPTH_OUTPUT DEPTH_OUTPUT}
 capability, DEPTH_POINT_CLOUD coordinates have units of meters, and the coordinate system is
 defined by the camera's pose transforms:
 {@link android.hardware.camera2.CameraCharacteristics#LENS_POSE_TRANSLATION} and
 {@link android.hardware.camera2.CameraCharacteristics#LENS_POSE_ROTATION}. That means the origin is
 the optical center of the camera device, and the positive Z axis points along the camera's optical axis,
 toward the scene.
*/
DEPTH_POINT_CLOUD : &quot;257&quot;,
<span id='android-graphics-ImageFormat-property-RAW_DEPTH'>/** Unprocessed implementation-dependent raw
</span> depth measurements, opaque with 16 bit
 samples.

 @hide
*/
RAW_DEPTH : &quot;4098&quot;,
<span id='android-graphics-ImageFormat-property-PRIVATE'>/** Android private opaque image format.
</span> &lt;p&gt;
 The choices of the actual format and pixel data layout are entirely up to
 the device-specific and framework internal implementations, and may vary
 depending on use cases even for the same device. The buffers of this
 format can be produced by components like
 {@link android.media.ImageWriter ImageWriter} , and interpreted correctly
 by consumers like {@link android.hardware.camera2.android.graphics.CameraDevice
 android.graphics.CameraDevice} based on the device/framework private information. However,
 these buffers are not directly accessible to the application.
 &lt;/p&gt;
 &lt;p&gt;
 When an {@link android.media.Image Image} of this format is obtained from
 an {@link android.media.ImageReader ImageReader} or
 {@link android.media.ImageWriter ImageWriter}, the
 {@link android.media.Image#getPlanes() getPlanes()} method will return an
 empty {@link android.media.Image.Plane Plane} array.
 &lt;/p&gt;
 &lt;p&gt;
 If a buffer of this format is to be used as an OpenGL ES texture, the
 framework will assume that sampling the texture will always return an
 alpha value of 1.0 (i.e. the buffer contains only opaque pixel values).
 &lt;/p&gt;
*/
PRIVATE : &quot;34&quot;,
<span id='android-graphics-ImageFormat-property-HEIC'>/** Compressed HEIC format.
</span>
 &lt;p&gt;This format defines the HEIC brand of High Efficiency Image File
 Format as described in ISO/IEC 23008-12.&lt;/p&gt;
*/
HEIC : &quot;1212500294&quot;,
<span id='android-graphics-ImageFormat-method-getBitsPerPixel'>/**Use this function to retrieve the number of bits per pixel of an
</span> ImageFormat.
@param {Number} format
@return {Number} the number of bits per pixel of the given format or -1 if the
         format doesn't exist or is not supported.
*/
getBitsPerPixel : function(  ) {},

<span id='android-graphics-ImageFormat-method-isPublicFormat'>/**Determine whether or not this is a public-visible {@code format}.
</span>
 &lt;p&gt;In particular, {@code @hide} formats will return {@code false}.&lt;/p&gt;

 &lt;p&gt;Any other formats (including UNKNOWN) will return {@code false}.&lt;/p&gt;
@param {Number} format an integer format
@return {Boolean} a boolean
@hide 
*/
isPublicFormat : function(  ) {},


};</pre>
</body>
</html>
