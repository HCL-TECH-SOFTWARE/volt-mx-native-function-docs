<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='android-opengl-Matrix'>/**@class android.opengl.Matrix
</span>@extends java.lang.Object

 Matrix math utilities. These methods operate on OpenGL ES format
 matrices and vectors stored in float arrays.
 &lt;p&gt;
 Matrices are 4 x 4 column-vector matrices stored in column-major
 order:
 &lt;pre&gt;
  m[offset +  0] m[offset +  4] m[offset +  8] m[offset + 12]
  m[offset +  1] m[offset +  5] m[offset +  9] m[offset + 13]
  m[offset +  2] m[offset +  6] m[offset + 10] m[offset + 14]
  m[offset +  3] m[offset +  7] m[offset + 11] m[offset + 15]&lt;/pre&gt;

 Vectors are 4 x 1 column vectors stored in order:
 &lt;pre&gt;
 v[offset + 0]
 v[offset + 1]
 v[offset + 2]
 v[offset + 3]&lt;/pre&gt;
*/
var Matrix = {

<span id='android-opengl-Matrix-method-multiplyMM'>/**Multiplies two 4x4 matrices together and stores the result in a third 4x4
</span> matrix. In matrix notation: result = lhs x rhs. Due to the way
 matrix multiplication works, the result matrix will have the same
 effect as first multiplying by the rhs matrix, then multiplying by
 the lhs matrix. This is the opposite of what you might expect.
 &lt;p&gt;
 The same float array may be passed for result, lhs, and/or rhs. However,
 the result element values are undefined if the result elements overlap
 either the lhs or rhs elements.
@param {Object {float[]}} result The float array that holds the result.
@param {Number} resultOffset The offset into the result array where the result is
        stored.
@param {Object {float[]}} lhs The float array that holds the left-hand-side matrix.
@param {Number} lhsOffset The offset into the lhs array where the lhs is stored
@param {Object {float[]}} rhs The float array that holds the right-hand-side matrix.
@param {Number} rhsOffset The offset into the rhs array where the rhs is stored.
@throws IllegalArgumentException if result, lhs, or rhs are null, or if
 resultOffset + 16 &gt; result.length or lhsOffset + 16 &gt; lhs.length or
 rhsOffset + 16 &gt; rhs.length.
*/
multiplyMM : function(  ) {},

<span id='android-opengl-Matrix-method-multiplyMV'>/**Multiplies a 4 element vector by a 4x4 matrix and stores the result in a
</span> 4-element column vector. In matrix notation: result = lhs x rhs
 &lt;p&gt;
 The same float array may be passed for resultVec, lhsMat, and/or rhsVec.
 However, the resultVec element values are undefined if the resultVec
 elements overlap either the lhsMat or rhsVec elements.
@param {Object {float[]}} resultVec The float array that holds the result vector.
@param {Number} resultVecOffset The offset into the result array where the result
        vector is stored.
@param {Object {float[]}} lhsMat The float array that holds the left-hand-side matrix.
@param {Number} lhsMatOffset The offset into the lhs array where the lhs is stored
@param {Object {float[]}} rhsVec The float array that holds the right-hand-side vector.
@param {Number} rhsVecOffset The offset into the rhs vector where the rhs vector
        is stored.
@throws IllegalArgumentException if resultVec, lhsMat,
 or rhsVec are null, or if resultVecOffset + 4 &gt; resultVec.length
 or lhsMatOffset + 16 &gt; lhsMat.length or
 rhsVecOffset + 4 &gt; rhsVec.length.
*/
multiplyMV : function(  ) {},

<span id='android-opengl-Matrix-method-transposeM'>/**Transposes a 4 x 4 matrix.
</span> &lt;p&gt;
 mTrans and m must not overlap.
@param {Object {float[]}} mTrans the array that holds the output transposed matrix
@param {Number} mTransOffset an offset into mTrans where the transposed matrix is
        stored.
@param {Object {float[]}} m the input array
@param {Number} mOffset an offset into m where the input matrix is stored.
*/
transposeM : function(  ) {},

<span id='android-opengl-Matrix-method-invertM'>/**Inverts a 4 x 4 matrix.
</span> &lt;p&gt;
 mInv and m must not overlap.
@param {Object {float[]}} mInv the array that holds the output inverted matrix
@param {Number} mInvOffset an offset into mInv where the inverted matrix is
        stored.
@param {Object {float[]}} m the input array
@param {Number} mOffset an offset into m where the input matrix is stored.
@return {Boolean} true if the matrix could be inverted, false if it could not.
*/
invertM : function(  ) {},

<span id='android-opengl-Matrix-method-orthoM'>/**Computes an orthographic projection matrix.
</span>@param {Object {float[]}} m returns the result
@param {Number} mOffset
@param {Number} left
@param {Number} right
@param {Number} bottom
@param {Number} top
@param {Number} near
@param {Number} far
*/
orthoM : function(  ) {},

<span id='android-opengl-Matrix-method-frustumM'>/**Defines a projection matrix in terms of six clip planes.
</span>@param {Object {float[]}} m the float array that holds the output perspective matrix
@param {Number} offset the offset into float array m where the perspective
        matrix data is written
@param {Number} left
@param {Number} right
@param {Number} bottom
@param {Number} top
@param {Number} near
@param {Number} far
*/
frustumM : function(  ) {},

<span id='android-opengl-Matrix-method-perspectiveM'>/**Defines a projection matrix in terms of a field of view angle, an
</span> aspect ratio, and z clip planes.
@param {Object {float[]}} m the float array that holds the perspective matrix
@param {Number} offset the offset into float array m where the perspective
        matrix data is written
@param {Number} fovy field of view in y direction, in degrees
@param {Number} aspect width to height aspect ratio of the viewport
@param {Number} zNear
@param {Number} zFar
*/
perspectiveM : function(  ) {},

<span id='android-opengl-Matrix-method-length'>/**Computes the length of a vector.
</span>@param {Number} x x coordinate of a vector
@param {Number} y y coordinate of a vector
@param {Number} z z coordinate of a vector
@return {Number} the length of a vector
*/
length : function(  ) {},

<span id='android-opengl-Matrix-method-setIdentityM'>/**Sets matrix m to the identity matrix.
</span>@param {Object {float[]}} sm returns the result
@param {Number} smOffset index into sm where the result matrix starts
*/
setIdentityM : function(  ) {},

<span id='android-opengl-Matrix-method-scaleM'>/**Scales matrix m by x, y, and z, putting the result in sm.
</span> &lt;p&gt;
 m and sm must not overlap.
@param {Object {float[]}} sm returns the result
@param {Number} smOffset index into sm where the result matrix starts
@param {Object {float[]}} m source matrix
@param {Number} mOffset index into m where the source matrix starts
@param {Number} x scale factor x
@param {Number} y scale factor y
@param {Number} z scale factor z
*/
scaleM : function(  ) {},

<span id='android-opengl-Matrix-method-scaleM'>/**Scales matrix m in place by sx, sy, and sz.
</span>@param {Object {float[]}} m matrix to scale
@param {Number} mOffset index into m where the matrix starts
@param {Number} x scale factor x
@param {Number} y scale factor y
@param {Number} z scale factor z
*/
scaleM : function(  ) {},

<span id='android-opengl-Matrix-method-translateM'>/**Translates matrix m by x, y, and z, putting the result in tm.
</span> &lt;p&gt;
 m and tm must not overlap.
@param {Object {float[]}} tm returns the result
@param {Number} tmOffset index into sm where the result matrix starts
@param {Object {float[]}} m source matrix
@param {Number} mOffset index into m where the source matrix starts
@param {Number} x translation factor x
@param {Number} y translation factor y
@param {Number} z translation factor z
*/
translateM : function(  ) {},

<span id='android-opengl-Matrix-method-translateM'>/**Translates matrix m by x, y, and z in place.
</span>@param {Object {float[]}} m matrix
@param {Number} mOffset index into m where the matrix starts
@param {Number} x translation factor x
@param {Number} y translation factor y
@param {Number} z translation factor z
*/
translateM : function(  ) {},

<span id='android-opengl-Matrix-method-rotateM'>/**Rotates matrix m by angle a (in degrees) around the axis (x, y, z).
</span> &lt;p&gt;
 m and rm must not overlap.
@param {Object {float[]}} rm returns the result
@param {Number} rmOffset index into rm where the result matrix starts
@param {Object {float[]}} m source matrix
@param {Number} mOffset index into m where the source matrix starts
@param {Number} a angle to rotate in degrees
@param {Number} x X axis component
@param {Number} y Y axis component
@param {Number} z Z axis component
*/
rotateM : function(  ) {},

<span id='android-opengl-Matrix-method-rotateM'>/**Rotates matrix m in place by angle a (in degrees)
</span> around the axis (x, y, z).
@param {Object {float[]}} m source matrix
@param {Number} mOffset index into m where the matrix starts
@param {Number} a angle to rotate in degrees
@param {Number} x X axis component
@param {Number} y Y axis component
@param {Number} z Z axis component
*/
rotateM : function(  ) {},

<span id='android-opengl-Matrix-method-setRotateM'>/**Creates a matrix for rotation by angle a (in degrees)
</span> around the axis (x, y, z).
 &lt;p&gt;
 An optimized path will be used for rotation about a major axis
 (e.g. x=1.0f y=0.0f z=0.0f).
@param {Object {float[]}} rm returns the result
@param {Number} rmOffset index into rm where the result matrix starts
@param {Number} a angle to rotate in degrees
@param {Number} x X axis component
@param {Number} y Y axis component
@param {Number} z Z axis component
*/
setRotateM : function(  ) {},

<span id='android-opengl-Matrix-method-setRotateEulerM'>/**Converts Euler angles to a rotation matrix.
</span>@param {Object {float[]}} rm returns the result
@param {Number} rmOffset index into rm where the result matrix starts
@param {Number} x angle of rotation, in degrees
@param {Number} y angle of rotation, in degrees
@param {Number} z angle of rotation, in degrees
*/
setRotateEulerM : function(  ) {},

<span id='android-opengl-Matrix-method-setLookAtM'>/**Defines a viewing transformation in terms of an eye point, a center of
</span> view, and an up vector.
@param {Object {float[]}} rm returns the result
@param {Number} rmOffset index into rm where the result matrix starts
@param {Number} eyeX eye point X
@param {Number} eyeY eye point Y
@param {Number} eyeZ eye point Z
@param {Number} centerX center of view X
@param {Number} centerY center of view Y
@param {Number} centerZ center of view Z
@param {Number} upX up vector X
@param {Number} upY up vector Y
@param {Number} upZ up vector Z
*/
setLookAtM : function(  ) {},


};</pre>
</body>
</html>
