<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='android-content-ContentProvider'>/**@class android.content.ContentProvider
</span> implements android.content.ContentInterface

 implements android.content.ComponentCallbacks2

@extends java.lang.Object

 Content providers are one of the primary building blocks of Android applications, providing
 content to applications. They encapsulate data and provide it to applications through the single
 {@link android.content.ContentResolver} interface. A content provider is only required if you need to share
 data between multiple applications. For example, the contacts data is used by multiple
 applications and must be stored in a content provider. If you don't need to share data amongst
 multiple applications you can use a database directly via
 {@link android.database.sqlite.SQLiteDatabase}.

 &lt;p&gt;When a request is made via
 a {@link android.content.ContentResolver} the system inspects the authority of the given URI and passes the
 request to the content provider registered with the authority. The content provider can interpret
 the rest of the URI however it wants. The {@link android.content.UriMatcher} class is helpful for parsing
 URIs.&lt;/p&gt;

 &lt;p&gt;The primary methods that need to be implemented are:
 &lt;ul&gt;
   &lt;li&gt;{@link #onCreate} which is called to initialize the provider&lt;/li&gt;
   &lt;li&gt;{@link #query} which returns data to the caller&lt;/li&gt;
   &lt;li&gt;{@link #insert} which inserts new data into the content provider&lt;/li&gt;
   &lt;li&gt;{@link #update} which updates existing data in the content provider&lt;/li&gt;
   &lt;li&gt;{@link #delete} which deletes data from the content provider&lt;/li&gt;
   &lt;li&gt;{@link #getType} which returns the MIME type of data in the content provider&lt;/li&gt;
 &lt;/ul&gt;&lt;/p&gt;

 &lt;p class=&quot;caution&quot;&gt;Data access methods (such as {@link #insert} and
 {@link #update}) may be called from many threads at once, and must be thread-safe.
 Other methods (such as {@link #onCreate}) are only called from the application
 main thread, and must avoid performing lengthy operations.  See the method
 descriptions for their expected thread behavior.&lt;/p&gt;

 &lt;p&gt;Requests to {@link android.content.ContentResolver} are automatically forwarded to the appropriate
 ContentProvider instance, so subclasses don't have to worry about the details of
 cross-process calls.&lt;/p&gt;

 &lt;div class=&quot;special reference&quot;&gt;
 &lt;h3&gt;Developer Guides&lt;/h3&gt;
 &lt;p&gt;For more information about using content providers, read the
 &lt;a href=&quot;{@docRoot}guide/topics/providers/content-providers.html&quot;&gt;Content Providers&lt;/a&gt;
 developer guide.&lt;/p&gt;
 &lt;/div&gt;
*/
var ContentProvider = {

<span id='android-content-ContentProvider-method-coerceToLocalContentProvider'>/**Given an IContentProvider, try to coerce it back to the real
</span> ContentProvider object if it is running in the local process.  This can
 be used if you know you are running in the same process as a provider,
 and want to get direct access to its implementation details.  Most
 clients should not nor have a reason to use it.
@param {Object {IContentProvider}} abstractInterface The ContentProvider interface that is to be
              coerced.
@return {Object {android.content.ContentProvider}} If the IContentProvider is non-{@code null} and local, returns its actual
 ContentProvider instance.  Otherwise returns {@code null}.
@hide 
*/
coerceToLocalContentProvider : function(  ) {},

<span id='android-content-ContentProvider-method-getContext'>/**Retrieves the Context this provider is running in.  Only available once
</span> {@link #onCreate} has been called -- this will return {@code null} in the
 constructor.
*/
getContext : function(  ) {},

<span id='android-content-ContentProvider-method-getCallingPackage'>/**Return the package name of the caller that initiated the request being
</span> processed on the current thread. The returned package will have been
 verified to belong to the calling UID. Returns {@code null} if not
 currently processing a request.
 &lt;p&gt;
 This will always return {@code null} when processing
 {@link #getType}(Uri) or {@link #getStreamTypes(Uri, String)} requests.
@see Binder#getCallingUid()
@see Context#grantUriPermission(String, Uri, int)
@throws SecurityException if the calling package doesn't belong to the
             calling UID.
*/
getCallingPackage : function(  ) {},

<span id='android-content-ContentProvider-method-getCallingPackageUnchecked'>/**{@hide}
</span>*/
getCallingPackageUnchecked : function(  ) {},

<span id='android-content-ContentProvider-method-onCallingPackageChanged'>/**{@hide}
</span>*/
onCallingPackageChanged : function(  ) {},

<span id='android-content-ContentProvider-method-clearCallingIdentity'>/**Reset the identity of the incoming IPC on the current thread.
</span> &lt;p&gt;
 Internally this calls {@link Binder#clearCallingIdentity()} and also
 clears any value stored in {@link #getCallingPackage}().
@return {Object {android.content.ContentProvider.CallingIdentity}} Returns an opaque token that can be used to restore the original
         calling identity by passing it to
         {@link #restoreCallingIdentity}.
*/
clearCallingIdentity : function(  ) {},

<span id='android-content-ContentProvider-method-restoreCallingIdentity'>/**Restore the identity of the incoming IPC on the current thread back to a
</span> previously identity that was returned by {@link #clearCallingIdentity}.
 &lt;p&gt;
 Internally this calls {@link Binder#restoreCallingIdentity(long)} and
 also restores any value stored in {@link #getCallingPackage}().
*/
restoreCallingIdentity : function(  ) {},

<span id='android-content-ContentProvider-method-getReadPermission'>/**Return the name of the permission required for read-only access to
</span> this content provider.  This method can be called from multiple
 threads, as described in
 &lt;a href=&quot;{@docRoot}guide/topics/fundamentals/processes-and-threads.html#Threads&quot;&gt;Processes
 and Threads&lt;/a&gt;.
*/
getReadPermission : function(  ) {},

<span id='android-content-ContentProvider-method-getWritePermission'>/**Return the name of the permission required for read/write access to
</span> this content provider.  This method can be called from multiple
 threads, as described in
 &lt;a href=&quot;{@docRoot}guide/topics/fundamentals/processes-and-threads.html#Threads&quot;&gt;Processes
 and Threads&lt;/a&gt;.
*/
getWritePermission : function(  ) {},

<span id='android-content-ContentProvider-method-getPathPermissions'>/**Return the path-based permissions required for read and/or write access to
</span> this content provider.  This method can be called from multiple
 threads, as described in
 &lt;a href=&quot;{@docRoot}guide/topics/fundamentals/processes-and-threads.html#Threads&quot;&gt;Processes
 and Threads&lt;/a&gt;.
*/
getPathPermissions : function(  ) {},

<span id='android-content-ContentProvider-method-setAppOps'>/**
</span>@hide 
*/
setAppOps : function(  ) {},

<span id='android-content-ContentProvider-method-getAppOpsManager'>/**
</span>@hide 
*/
getAppOpsManager : function(  ) {},

<span id='android-content-ContentProvider-method-setTransportLoggingEnabled'>/**
</span>@hide 
*/
setTransportLoggingEnabled : function(  ) {},

<span id='android-content-ContentProvider-method-onCreate'>/**Implement this to initialize your content provider on startup.
</span> This method is called for all registered content providers on the
 application main thread at application launch time.  It must not perform
 lengthy operations, or application startup will be delayed.

 &lt;p&gt;You should defer nontrivial initialization (such as opening,
 upgrading, and scanning databases) until the content provider is used
 (via {@link #query}, {@link #insert}, etc).  Deferred initialization
 keeps application startup fast, avoids unnecessary work if the provider
 turns out not to be needed, and stops database errors (such as a full
 disk) from halting application launch.

 &lt;p&gt;If you use SQLite, {@link android.database.sqlite.SQLiteOpenHelper}
 is a helpful utility class that makes it easy to manage databases,
 and will automatically defer opening until first use.  If you do use
 SQLiteOpenHelper, make sure to avoid calling
 {@link android.database.sqlite.SQLiteOpenHelper#getReadableDatabase} or
 {@link android.database.sqlite.SQLiteOpenHelper#getWritableDatabase}
 from this method.  (Instead, override
 {@link android.database.sqlite.SQLiteOpenHelper#onOpen} to initialize the
 database when it is first opened.)
@return {Boolean} true if the provider was successfully loaded, false otherwise
*/
onCreate : function(  ) {},

<span id='android-content-ContentProvider-method-onConfigurationChanged'>/**{@inheritDoc}
</span> This method is always called on the application main thread, and must
 not perform lengthy operations.

 &lt;p&gt;The default content provider implementation does nothing.
 Override this method to take appropriate action.
 (Content providers do not usually care about things like screen
 orientation, but may want to know about locale changes.)
*/
onConfigurationChanged : function(  ) {},

<span id='android-content-ContentProvider-method-onLowMemory'>/**{@inheritDoc}
</span> This method is always called on the application main thread, and must
 not perform lengthy operations.

 &lt;p&gt;The default content provider implementation does nothing.
 Subclasses may override this method to take appropriate action.
*/
onLowMemory : function(  ) {},

<span id='android-content-ContentProvider-method-onTrimMemory'>/**
</span>*/
onTrimMemory : function(  ) {},

<span id='android-content-ContentProvider-method-query'>/**Implement this to handle query requests from clients.
</span>
 &lt;p&gt;Apps targeting {@link android.os.Build.VERSION_CODES#O} or higher should override
 {@link #query(Uri, String[], Bundle, CancellationSignal)} and provide a stub
 implementation of this method.

 &lt;p&gt;This method can be called from multiple threads, as described in
 &lt;a href=&quot;{@docRoot}guide/topics/fundamentals/processes-and-threads.html#Threads&quot;&gt;Processes
 and Threads&lt;/a&gt;.
 &lt;p&gt;
 Example client call:&lt;p&gt;
 &lt;pre&gt;// Request a specific record.
 Cursor managedCursor = managedQuery(
                ContentUris.withAppendedId(Contacts.People.CONTENT_URI, 2),
                projection,    // Which columns to return.
                null,          // WHERE clause.
                null,          // WHERE clause value substitution
                People.NAME + &quot; ASC&quot;);   // Sort order.&lt;/pre&gt;
 Example implementation:&lt;p&gt;
 &lt;pre&gt;// SQLiteQueryBuilder is a helper class that creates the
        // proper SQL syntax for us.
        SQLiteQueryBuilder qBuilder = new SQLiteQueryBuilder();

        // Set the table we're querying.
        qBuilder.setTables(DATABASE_TABLE_NAME);

        // If the query ends in a specific record number, we're
        // being asked for a specific record, so set the
        // WHERE clause in our query.
        if((URI_MATCHER.match(uri)) == SPECIFIC_MESSAGE){
            qBuilder.appendWhere(&quot;_id=&quot; + uri.getPathLeafId());
        }

        // Make the query.
        Cursor c = qBuilder.query(mDb,
                projection,
                selection,
                selectionArgs,
                groupBy,
                having,
                sortOrder);
        c.setNotificationUri(getContext().getContentResolver(), uri);
        return c;&lt;/pre&gt;
@param {Object {Uri}} uri The URI to query. This will be the full URI sent by the client;
      if the client is requesting a specific record, the URI will end in a record number
      that the implementation should parse and add to a WHERE or HAVING clause, specifying
      that _id value.
@param {Object {java.lang.String[]}} projection The list of columns to put into the cursor. If
      {@code null} all columns are included.
@param {String} selection A selection criteria to apply when filtering rows.
      If {@code null} then all rows are included.
@param {Object {java.lang.String[]}} selectionArgs You may include ?s in selection, which will be replaced by
      the values from selectionArgs, in order that they appear in the selection.
      The values will be bound as Strings.
@param {String} sortOrder How the rows in the cursor should be sorted.
      If {@code null} then the provider is free to define the sort order.
@return {Object {android.database.Cursor}} a Cursor or {@code null}.
*/
query : function(  ) {},

<span id='android-content-ContentProvider-method-query'>/**Implement this to handle query requests from clients with support for cancellation.
</span>
 &lt;p&gt;Apps targeting {@link android.os.Build.VERSION_CODES#O} or higher should override
 {@link #query(Uri, String[], Bundle, CancellationSignal)} instead of this method.

 &lt;p&gt;This method can be called from multiple threads, as described in
 &lt;a href=&quot;{@docRoot}guide/topics/fundamentals/processes-and-threads.html#Threads&quot;&gt;Processes
 and Threads&lt;/a&gt;.
 &lt;p&gt;
 Example client call:&lt;p&gt;
 &lt;pre&gt;// Request a specific record.
 Cursor managedCursor = managedQuery(
                ContentUris.withAppendedId(Contacts.People.CONTENT_URI, 2),
                projection,    // Which columns to return.
                null,          // WHERE clause.
                null,          // WHERE clause value substitution
                People.NAME + &quot; ASC&quot;);   // Sort order.&lt;/pre&gt;
 Example implementation:&lt;p&gt;
 &lt;pre&gt;// SQLiteQueryBuilder is a helper class that creates the
        // proper SQL syntax for us.
        SQLiteQueryBuilder qBuilder = new SQLiteQueryBuilder();

        // Set the table we're querying.
        qBuilder.setTables(DATABASE_TABLE_NAME);

        // If the query ends in a specific record number, we're
        // being asked for a specific record, so set the
        // WHERE clause in our query.
        if((URI_MATCHER.match(uri)) == SPECIFIC_MESSAGE){
            qBuilder.appendWhere(&quot;_id=&quot; + uri.getPathLeafId());
        }

        // Make the query.
        Cursor c = qBuilder.query(mDb,
                projection,
                selection,
                selectionArgs,
                groupBy,
                having,
                sortOrder);
        c.setNotificationUri(getContext().getContentResolver(), uri);
        return c;&lt;/pre&gt;
 &lt;p&gt;
 If you implement this method then you must also implement the version of
 {@link #query(Uri, String[], String, String[], String)} that does not take a cancellation
 signal to ensure correct operation on older versions of the Android Framework in
 which the cancellation signal overload was not available.
@param {Object {Uri}} uri The URI to query. This will be the full URI sent by the client;
      if the client is requesting a specific record, the URI will end in a record number
      that the implementation should parse and add to a WHERE or HAVING clause, specifying
      that _id value.
@param {Object {java.lang.String[]}} projection The list of columns to put into the cursor. If
      {@code null} all columns are included.
@param {String} selection A selection criteria to apply when filtering rows.
      If {@code null} then all rows are included.
@param {Object {java.lang.String[]}} selectionArgs You may include ?s in selection, which will be replaced by
      the values from selectionArgs, in order that they appear in the selection.
      The values will be bound as Strings.
@param {String} sortOrder How the rows in the cursor should be sorted.
      If {@code null} then the provider is free to define the sort order.
@param {Object {CancellationSignal}} cancellationSignal A signal to cancel the operation in progress, or {@code null} if none.
 If the operation is canceled, then {@link android.os.OperationCanceledException} will be thrown
 when the query is executed.
@return {Object {android.database.Cursor}} a Cursor or {@code null}.
*/
query : function(  ) {},

<span id='android-content-ContentProvider-method-query'>/**Implement this to handle query requests where the arguments are packed into a {@link Bundle}.
</span> Arguments may include traditional SQL style query arguments. When present these
 should be handled  according to the contract established in
 {@link #query(Uri, String[], String, String[], String, CancellationSignal)}.

 &lt;p&gt;Traditional SQL arguments can be found in the bundle using the following keys:
 &lt;li&gt;{@link android.content.ContentResolver#QUERY_ARG_SQL_SELECTION}
 &lt;li&gt;{@link android.content.ContentResolver#QUERY_ARG_SQL_SELECTION_ARGS}
 &lt;li&gt;{@link android.content.ContentResolver#QUERY_ARG_SQL_SORT_ORDER}

 &lt;p&gt;This method can be called from multiple threads, as described in
 &lt;a href=&quot;{@docRoot}guide/topics/fundamentals/processes-and-threads.html#Threads&quot;&gt;Processes
 and Threads&lt;/a&gt;.

 &lt;p&gt;
 Example client call:&lt;p&gt;
 &lt;pre&gt;// Request 20 records starting at row index 30.
       Bundle queryArgs = new Bundle();
       queryArgs.putInt(ContentResolver.QUERY_ARG_OFFSET, 30);
       queryArgs.putInt(ContentResolver.QUERY_ARG_LIMIT, 20);

       Cursor cursor = getContentResolver().query(
                contentUri,    // Content Uri is specific to individual content providers.
                projection,    // String[] describing which columns to return.
                queryArgs,     // Query arguments.
                null);         // Cancellation signal.&lt;/pre&gt;

 Example implementation:&lt;p&gt;
 &lt;pre&gt;

        int recordsetSize = 0x1000;  // Actual value is implementation specific.
        queryArgs = queryArgs != null ? queryArgs : Bundle.EMPTY;  // ensure queryArgs is non-null

        int offset = queryArgs.getInt(ContentResolver.QUERY_ARG_OFFSET, 0);
        int limit = queryArgs.getInt(ContentResolver.QUERY_ARG_LIMIT, Integer.MIN_VALUE);

        MatrixCursor c = new MatrixCursor(PROJECTION, limit);

        // Calculate the number of items to include in the cursor.
        int numItems = MathUtils.constrain(recordsetSize - offset, 0, limit);

        // Build the paged result set....
        for (int i = offset; i &lt; offset + numItems; i++) {
            // populate row from your data.
        }

        Bundle extras = new Bundle();
        c.setExtras(extras);

        // Any QUERY_ARG_* key may be included if honored.
        // In an actual implementation, include only keys that are both present in queryArgs
        // and reflected in the Cursor output. For example, if QUERY_ARG_OFFSET were included
        // in queryArgs, but was ignored because it contained an invalid value (like â€“273),
        // then QUERY_ARG_OFFSET should be omitted.
        extras.putStringArray(ContentResolver.EXTRA_HONORED_ARGS, new String[] {
            ContentResolver.QUERY_ARG_OFFSET,
            ContentResolver.QUERY_ARG_LIMIT
        });

        extras.putInt(ContentResolver.EXTRA_TOTAL_COUNT, recordsetSize);

        cursor.setNotificationUri(getContext().getContentResolver(), uri);

        return cursor;&lt;/pre&gt;
 &lt;p&gt;
 See {@link #query(Uri, String[], String, String[], String, CancellationSignal)}
 for implementation details.
@param {Object {Uri}} uri The URI to query. This will be the full URI sent by the client.
@param {Object {java.lang.String[]}} projection The list of columns to put into the cursor.
            If {@code null} provide a default set of columns.
@param {Object {Bundle}} queryArgs A Bundle containing all additional information necessary for the query.
            Values in the Bundle may include SQL style arguments.
@param {Object {CancellationSignal}} cancellationSignal A signal to cancel the operation in progress,
            or {@code null}.
@return {Object {android.database.Cursor}} a Cursor or {@code null}.
*/
query : function(  ) {},

<span id='android-content-ContentProvider-method-getType'>/**Implement this to handle requests for the MIME type of the data at the
</span> given URI.  The returned MIME type should start with
 &lt;code&gt;vnd.android.cursor.item&lt;/code&gt; for a single record,
 or &lt;code&gt;vnd.android.cursor.dir/&lt;/code&gt; for multiple items.
 This method can be called from multiple threads, as described in
 &lt;a href=&quot;{@docRoot}guide/topics/fundamentals/processes-and-threads.html#Threads&quot;&gt;Processes
 and Threads&lt;/a&gt;.

 &lt;p&gt;Note that there are no permissions needed for an application to
 access this information; if your content provider requires read and/or
 write permissions, or is not exported, all applications can still call
 this method regardless of their access permissions.  This allows them
 to retrieve the MIME type for a URI when dispatching intents.
@param {Object {Uri}} uri the URI to query.
@return {String} a MIME type string, or {@code null} if there is no type.
*/
getType : function(  ) {},

<span id='android-content-ContentProvider-method-canonicalize'>/**Implement this to support canonicalization of URIs that refer to your
</span> content provider.  A canonical URI is one that can be transported across
 devices, backup/restore, and other contexts, and still be able to refer
 to the same data item.  Typically this is implemented by adding query
 params to the URI allowing the content provider to verify that an incoming
 canonical URI references the same data as it was originally intended for and,
 if it doesn't, to find that data (if it exists) in the current environment.

 &lt;p&gt;For example, if the content provider holds people and a normal URI in it
 is created with a row index into that people database, the cananical representation
 may have an additional query param at the end which specifies the name of the
 person it is intended for.  Later calls into the provider with that URI will look
 up the row of that URI's base index and, if it doesn't match or its entry's
 name doesn't match the name in the query param, perform a query on its database
 to find the correct row to operate on.&lt;/p&gt;

 &lt;p&gt;If you implement support for canonical URIs, &lt;b&gt;all&lt;/b&gt; incoming calls with
 URIs (including this one) must perform this verification and recovery of any
 canonical URIs they receive.  In addition, you must also implement
 {@link #uncanonicalize} to strip the canonicalization of any of these URIs.&lt;/p&gt;

 &lt;p&gt;The default implementation of this method returns null, indicating that
 canonical URIs are not supported.&lt;/p&gt;
@param {Object {Uri}} url The Uri to canonicalize.
@return {Object {android.net.Uri}} Return the canonical representation of &lt;var&gt;url&lt;/var&gt;, or null if
 canonicalization of that Uri is not supported.
*/
canonicalize : function(  ) {},

<span id='android-content-ContentProvider-method-uncanonicalize'>/**Remove canonicalization from canonical URIs previously returned by
</span> {@link #canonicalize}.  For example, if your implementation is to add
 a query param to canonicalize a URI, this method can simply trip any
 query params on the URI.  The default implementation always returns the
 same &lt;var&gt;url&lt;/var&gt; that was passed in.
@param {Object {Uri}} url The Uri to remove any canonicalization from.
@return {Object {android.net.Uri}} Return the non-canonical representation of &lt;var&gt;url&lt;/var&gt;, return
 the &lt;var&gt;url&lt;/var&gt; as-is if there is nothing to do, or return null if
 the data identified by the canonical representation can not be found in
 the current environment.
*/
uncanonicalize : function(  ) {},

<span id='android-content-ContentProvider-method-refresh'>/**Implement this to support refresh of content identified by {@code uri}. By default, this
</span> method returns false; providers who wish to implement this should return true to signal the
 client that the provider has tried refreshing with its own implementation.
 &lt;p&gt;
 This allows clients to request an explicit refresh of content identified by {@code uri}.
 &lt;p&gt;
 Client code should only invoke this method when there is a strong indication (such as a user
 initiated pull to refresh gesture) that the content is stale.
 &lt;p&gt;
 Remember to send {@link android.content.ContentResolver#notifyChange(Uri, android.database.ContentObserver)}
 notifications when content changes.
@param {Object {Uri}} uri The Uri identifying the data to refresh.
@param {Object {Bundle}} args Additional options from the client. The definitions of these are specific to the
            content provider being called.
@param {Object {CancellationSignal}} cancellationSignal A signal to cancel the operation in progress, or {@code null} if
            none. For example, if you called refresh on a particular uri, you should call
            {@link CancellationSignal#throwIfCanceled()} to check whether the client has
            canceled the refresh request.
@return {Boolean} true if the provider actually tried refreshing.
*/
refresh : function(  ) {},

<span id='android-content-ContentProvider-method-rejectInsert'>/**
</span>@hide Implementation when a caller has performed an insert on the content
 provider, but that call has been rejected for the operation given
 to {@link #setAppOps(int, int)}.  The default implementation simply
 returns a dummy URI that is the base URI with a 0 path element
 appended.
*/
rejectInsert : function(  ) {},

<span id='android-content-ContentProvider-method-insert'>/**Implement this to handle requests to insert a new row.
</span> As a courtesy, call {@link android.content.ContentResolver#notifyChange(android.net.Uri ,android.database.ContentObserver) notifyChange()}
 after inserting.
 This method can be called from multiple threads, as described in
 &lt;a href=&quot;{@docRoot}guide/topics/fundamentals/processes-and-threads.html#Threads&quot;&gt;Processes
 and Threads&lt;/a&gt;.
@param {Object {Uri}} uri The content:// URI of the insertion request. This must not be {@code null}.
@param {Object {ContentValues}} values A set of column_name/value pairs to add to the database.
     This must not be {@code null}.
@return {Object {android.net.Uri}} The URI for the newly inserted item.
*/
insert : function(  ) {},

<span id='android-content-ContentProvider-method-bulkInsert'>/**Override this to handle requests to insert a set of new rows, or the
</span> default implementation will iterate over the values and call
 {@link #insert} on each of them.
 As a courtesy, call {@link android.content.ContentResolver#notifyChange(android.net.Uri ,android.database.ContentObserver) notifyChange()}
 after inserting.
 This method can be called from multiple threads, as described in
 &lt;a href=&quot;{@docRoot}guide/topics/fundamentals/processes-and-threads.html#Threads&quot;&gt;Processes
 and Threads&lt;/a&gt;.
@param {Object {Uri}} uri The content:// URI of the insertion request.
@param {Object {android.content.ContentValues[]}} values An array of sets of column_name/value pairs to add to the database.
    This must not be {@code null}.
@return {Number} The number of values that were inserted.
*/
bulkInsert : function(  ) {},

<span id='android-content-ContentProvider-method-delete'>/**Implement this to handle requests to delete one or more rows.
</span> The implementation should apply the selection clause when performing
 deletion, allowing the operation to affect multiple rows in a directory.
 As a courtesy, call {@link android.content.ContentResolver#notifyChange(android.net.Uri ,android.database.ContentObserver) notifyChange()}
 after deleting.
 This method can be called from multiple threads, as described in
 &lt;a href=&quot;{@docRoot}guide/topics/fundamentals/processes-and-threads.html#Threads&quot;&gt;Processes
 and Threads&lt;/a&gt;.

 &lt;p&gt;The implementation is responsible for parsing out a row ID at the end
 of the URI, if a specific row is being deleted. That is, the client would
 pass in &lt;code&gt;content://contacts/people/22&lt;/code&gt; and the implementation is
 responsible for parsing the record number (22) when creating a SQL statement.
@param {Object {Uri}} uri The full URI to query, including a row ID (if a specific record is requested).
@param {String} selection An optional restriction to apply to rows when deleting.
@return {Number} The number of rows affected.
@throws SQLException
*/
delete : function(  ) {},

<span id='android-content-ContentProvider-method-update'>/**Implement this to handle requests to update one or more rows.
</span> The implementation should update all rows matching the selection
 to set the columns according to the provided values map.
 As a courtesy, call {@link android.content.ContentResolver#notifyChange(android.net.Uri ,android.database.ContentObserver) notifyChange()}
 after updating.
 This method can be called from multiple threads, as described in
 &lt;a href=&quot;{@docRoot}guide/topics/fundamentals/processes-and-threads.html#Threads&quot;&gt;Processes
 and Threads&lt;/a&gt;.
@param {Object {Uri}} uri The URI to query. This can potentially have a record ID if this
 is an update request for a specific record.
@param {Object {ContentValues}} values A set of column_name/value pairs to update in the database.
     This must not be {@code null}.
@param {String} selection An optional filter to match rows to update.
@return {Number} the number of rows affected.
*/
update : function(  ) {},

<span id='android-content-ContentProvider-method-openFile'>/**Override this to handle requests to open a file blob.
</span> The default implementation always throws {@link FileNotFoundException}.
 This method can be called from multiple threads, as described in
 &lt;a href=&quot;{@docRoot}guide/topics/fundamentals/processes-and-threads.html#Threads&quot;&gt;Processes
 and Threads&lt;/a&gt;.

 &lt;p&gt;This method returns a ParcelFileDescriptor, which is returned directly
 to the caller.  This way large data (such as images and documents) can be
 returned without copying the content.

 &lt;p&gt;The returned ParcelFileDescriptor is owned by the caller, so it is
 their responsibility to close it when done.  That is, the implementation
 of this method should create a new ParcelFileDescriptor for each call.
 &lt;p&gt;
 If opened with the exclusive &quot;r&quot; or &quot;w&quot; modes, the returned
 ParcelFileDescriptor can be a pipe or socket pair to enable streaming
 of data. Opening with the &quot;rw&quot; or &quot;rwt&quot; modes implies a file on disk that
 supports seeking.
 &lt;p&gt;
 If you need to detect when the returned ParcelFileDescriptor has been
 closed, or if the remote process has crashed or encountered some other
 error, you can use {@link ParcelFileDescriptor#open(File, int,
 android.os.Handler, android.os.ParcelFileDescriptor.OnCloseListener)},
 {@link ParcelFileDescriptor#createReliablePipe()}, or
 {@link ParcelFileDescriptor#createReliableSocketPair()}.
 &lt;p&gt;
 If you need to return a large file that isn't backed by a real file on
 disk, such as a file on a network share or cloud storage service,
 consider using
 {@link StorageManager#openProxyFileDescriptor(int, android.os.ProxyFileDescriptorCallback, android.os.Handler)}
 which will let you to stream the content on-demand.

 &lt;p class=&quot;note&quot;&gt;For use in Intents, you will want to implement {@link #getType}
 to return the appropriate MIME type for the data returned here with
 the same URI.  This will allow intent resolution to automatically determine the data MIME
 type and select the appropriate matching targets as part of its operation.&lt;/p&gt;

 &lt;p class=&quot;note&quot;&gt;For better interoperability with other applications, it is recommended
 that for any URIs that can be opened, you also support queries on them
 containing at least the columns specified by {@link android.provider.OpenableColumns}.
 You may also want to support other common columns if you have additional meta-data
 to supply, such as {@link android.provider.MediaStore.MediaColumns#DATE_ADDED}
 in {@link android.provider.MediaStore.MediaColumns}.&lt;/p&gt;
@param {Object {Uri}} uri The URI whose file is to be opened.
@param {String} mode Access mode for the file.  May be &quot;r&quot; for read-only access,
 &quot;rw&quot; for read and write access, or &quot;rwt&quot; for read and write access
 that truncates any existing file.
@return {Object {android.os.ParcelFileDescriptor}} Returns a new ParcelFileDescriptor which you can use to access
 the file.
@throws FileNotFoundException Throws FileNotFoundException if there is
 no file associated with the given URI or the mode is invalid.
@throws SecurityException Throws SecurityException if the caller does
 not have permission to access the file.
@see #openAssetFile(Uri, String)
@see #openFileHelper(Uri, String)
@see #getType(android.net.Uri)
@see ParcelFileDescriptor#parseMode(String)
*/
openFile : function(  ) {},

<span id='android-content-ContentProvider-method-openFile'>/**Override this to handle requests to open a file blob.
</span> The default implementation always throws {@link FileNotFoundException}.
 This method can be called from multiple threads, as described in
 &lt;a href=&quot;{@docRoot}guide/topics/fundamentals/processes-and-threads.html#Threads&quot;&gt;Processes
 and Threads&lt;/a&gt;.

 &lt;p&gt;This method returns a ParcelFileDescriptor, which is returned directly
 to the caller.  This way large data (such as images and documents) can be
 returned without copying the content.

 &lt;p&gt;The returned ParcelFileDescriptor is owned by the caller, so it is
 their responsibility to close it when done.  That is, the implementation
 of this method should create a new ParcelFileDescriptor for each call.
 &lt;p&gt;
 If opened with the exclusive &quot;r&quot; or &quot;w&quot; modes, the returned
 ParcelFileDescriptor can be a pipe or socket pair to enable streaming
 of data. Opening with the &quot;rw&quot; or &quot;rwt&quot; modes implies a file on disk that
 supports seeking.
 &lt;p&gt;
 If you need to detect when the returned ParcelFileDescriptor has been
 closed, or if the remote process has crashed or encountered some other
 error, you can use {@link ParcelFileDescriptor#open(File, int,
 android.os.Handler, android.os.ParcelFileDescriptor.OnCloseListener)},
 {@link ParcelFileDescriptor#createReliablePipe()}, or
 {@link ParcelFileDescriptor#createReliableSocketPair()}.

 &lt;p class=&quot;note&quot;&gt;For use in Intents, you will want to implement {@link #getType}
 to return the appropriate MIME type for the data returned here with
 the same URI.  This will allow intent resolution to automatically determine the data MIME
 type and select the appropriate matching targets as part of its operation.&lt;/p&gt;

 &lt;p class=&quot;note&quot;&gt;For better interoperability with other applications, it is recommended
 that for any URIs that can be opened, you also support queries on them
 containing at least the columns specified by {@link android.provider.OpenableColumns}.
 You may also want to support other common columns if you have additional meta-data
 to supply, such as {@link android.provider.MediaStore.MediaColumns#DATE_ADDED}
 in {@link android.provider.MediaStore.MediaColumns}.&lt;/p&gt;
@param {Object {Uri}} uri The URI whose file is to be opened.
@param {String} mode Access mode for the file. May be &quot;r&quot; for read-only access,
            &quot;w&quot; for write-only access, &quot;rw&quot; for read and write access, or
            &quot;rwt&quot; for read and write access that truncates any existing
            file.
@param {Object {CancellationSignal}} signal A signal to cancel the operation in progress, or
            {@code null} if none. For example, if you are downloading a
            file from the network to service a &quot;rw&quot; mode request, you
            should periodically call
            {@link CancellationSignal#throwIfCanceled()} to check whether
            the client has canceled the request and abort the download.
@return {Object {android.os.ParcelFileDescriptor}} Returns a new ParcelFileDescriptor which you can use to access
 the file.
@throws FileNotFoundException Throws FileNotFoundException if there is
 no file associated with the given URI or the mode is invalid.
@throws SecurityException Throws SecurityException if the caller does
 not have permission to access the file.
@see #openAssetFile(Uri, String)
@see #openFileHelper(Uri, String)
@see #getType(android.net.Uri)
@see ParcelFileDescriptor#parseMode(String)
*/
openFile : function(  ) {},

<span id='android-content-ContentProvider-method-openAssetFile'>/**This is like {@link #openFile}, but can be implemented by providers
</span> that need to be able to return sub-sections of files, often assets
 inside of their .apk.
 This method can be called from multiple threads, as described in
 &lt;a href=&quot;{@docRoot}guide/topics/fundamentals/processes-and-threads.html#Threads&quot;&gt;Processes
 and Threads&lt;/a&gt;.

 &lt;p&gt;If you implement this, your clients must be able to deal with such
 file slices, either directly with
 {@link android.content.ContentResolver#openAssetFileDescriptor}, or by using the higher-level
 {@link android.content.ContentResolver#openInputStream android.content.ContentResolver.openInputStream}
 or {@link android.content.ContentResolver#openOutputStream android.content.ContentResolver.openOutputStream}
 methods.
 &lt;p&gt;
 The returned AssetFileDescriptor can be a pipe or socket pair to enable
 streaming of data.

 &lt;p class=&quot;note&quot;&gt;If you are implementing this to return a full file, you
 should create the AssetFileDescriptor with
 {@link AssetFileDescriptor#UNKNOWN_LENGTH} to be compatible with
 applications that cannot handle sub-sections of files.&lt;/p&gt;

 &lt;p class=&quot;note&quot;&gt;For use in Intents, you will want to implement {@link #getType}
 to return the appropriate MIME type for the data returned here with
 the same URI.  This will allow intent resolution to automatically determine the data MIME
 type and select the appropriate matching targets as part of its operation.&lt;/p&gt;

 &lt;p class=&quot;note&quot;&gt;For better interoperability with other applications, it is recommended
 that for any URIs that can be opened, you also support queries on them
 containing at least the columns specified by {@link android.provider.OpenableColumns}.&lt;/p&gt;
@param {Object {Uri}} uri The URI whose file is to be opened.
@param {String} mode Access mode for the file.  May be &quot;r&quot; for read-only access,
 &quot;w&quot; for write-only access (erasing whatever data is currently in
 the file), &quot;wa&quot; for write-only access to append to any existing data,
 &quot;rw&quot; for read and write access on any existing data, and &quot;rwt&quot; for read
 and write access that truncates any existing file.
@return {Object {android.content.res.AssetFileDescriptor}} Returns a new AssetFileDescriptor which you can use to access
 the file.
@throws FileNotFoundException Throws FileNotFoundException if there is
 no file associated with the given URI or the mode is invalid.
@throws SecurityException Throws SecurityException if the caller does
 not have permission to access the file.
@see #openFile(Uri, String)
@see #openFileHelper(Uri, String)
@see #getType(android.net.Uri)
*/
openAssetFile : function(  ) {},

<span id='android-content-ContentProvider-method-openAssetFile'>/**This is like {@link #openFile}, but can be implemented by providers
</span> that need to be able to return sub-sections of files, often assets
 inside of their .apk.
 This method can be called from multiple threads, as described in
 &lt;a href=&quot;{@docRoot}guide/topics/fundamentals/processes-and-threads.html#Threads&quot;&gt;Processes
 and Threads&lt;/a&gt;.

 &lt;p&gt;If you implement this, your clients must be able to deal with such
 file slices, either directly with
 {@link android.content.ContentResolver#openAssetFileDescriptor}, or by using the higher-level
 {@link android.content.ContentResolver#openInputStream android.content.ContentResolver.openInputStream}
 or {@link android.content.ContentResolver#openOutputStream android.content.ContentResolver.openOutputStream}
 methods.
 &lt;p&gt;
 The returned AssetFileDescriptor can be a pipe or socket pair to enable
 streaming of data.

 &lt;p class=&quot;note&quot;&gt;If you are implementing this to return a full file, you
 should create the AssetFileDescriptor with
 {@link AssetFileDescriptor#UNKNOWN_LENGTH} to be compatible with
 applications that cannot handle sub-sections of files.&lt;/p&gt;

 &lt;p class=&quot;note&quot;&gt;For use in Intents, you will want to implement {@link #getType}
 to return the appropriate MIME type for the data returned here with
 the same URI.  This will allow intent resolution to automatically determine the data MIME
 type and select the appropriate matching targets as part of its operation.&lt;/p&gt;

 &lt;p class=&quot;note&quot;&gt;For better interoperability with other applications, it is recommended
 that for any URIs that can be opened, you also support queries on them
 containing at least the columns specified by {@link android.provider.OpenableColumns}.&lt;/p&gt;
@param {Object {Uri}} uri The URI whose file is to be opened.
@param {String} mode Access mode for the file.  May be &quot;r&quot; for read-only access,
 &quot;w&quot; for write-only access (erasing whatever data is currently in
 the file), &quot;wa&quot; for write-only access to append to any existing data,
 &quot;rw&quot; for read and write access on any existing data, and &quot;rwt&quot; for read
 and write access that truncates any existing file.
@param {Object {CancellationSignal}} signal A signal to cancel the operation in progress, or
            {@code null} if none. For example, if you are downloading a
            file from the network to service a &quot;rw&quot; mode request, you
            should periodically call
            {@link CancellationSignal#throwIfCanceled()} to check whether
            the client has canceled the request and abort the download.
@return {Object {android.content.res.AssetFileDescriptor}} Returns a new AssetFileDescriptor which you can use to access
 the file.
@throws FileNotFoundException Throws FileNotFoundException if there is
 no file associated with the given URI or the mode is invalid.
@throws SecurityException Throws SecurityException if the caller does
 not have permission to access the file.
@see #openFile(Uri, String)
@see #openFileHelper(Uri, String)
@see #getType(android.net.Uri)
*/
openAssetFile : function(  ) {},

<span id='android-content-ContentProvider-method-getStreamTypes'>/**Called by a client to determine the types of data streams that this
</span> content provider supports for the given URI.  The default implementation
 returns {@code null}, meaning no types.  If your content provider stores data
 of a particular type, return that MIME type if it matches the given
 mimeTypeFilter.  If it can perform type conversions, return an array
 of all supported MIME types that match mimeTypeFilter.
@param {Object {Uri}} uri The data in the content provider being queried.
@param {String} mimeTypeFilter The type of data the client desires.  May be
 a pattern, such as *&amp;#47;* to retrieve all possible data types.
@return {String} Returns {@code null} if there are no possible data streams for the
 given mimeTypeFilter.  Otherwise returns an array of all available
 concrete MIME types.
@see #getType(Uri)
@see #openTypedAssetFile(Uri, String, Bundle)
@see ClipDescription#compareMimeTypes(String, String)
*/
getStreamTypes : function(  ) {},

<span id='android-content-ContentProvider-method-openTypedAssetFile'>/**Called by a client to open a read-only stream containing data of a
</span> particular MIME type.  This is like {@link #openAssetFile(Uri, String)},
 except the file can only be read-only and the content provider may
 perform data conversions to generate data of the desired type.

 &lt;p&gt;The default implementation compares the given mimeType against the
 result of {@link #getType}(Uri) and, if they match, simply calls
 {@link #openAssetFile(Uri, String)}.

 &lt;p&gt;See {@link android.content.ClipData} for examples of the use and implementation
 of this method.
 &lt;p&gt;
 The returned AssetFileDescriptor can be a pipe or socket pair to enable
 streaming of data.

 &lt;p class=&quot;note&quot;&gt;For better interoperability with other applications, it is recommended
 that for any URIs that can be opened, you also support queries on them
 containing at least the columns specified by {@link android.provider.OpenableColumns}.
 You may also want to support other common columns if you have additional meta-data
 to supply, such as {@link android.provider.MediaStore.MediaColumns#DATE_ADDED}
 in {@link android.provider.MediaStore.MediaColumns}.&lt;/p&gt;
@param {Object {Uri}} uri The data in the content provider being queried.
@param {String} mimeTypeFilter The type of data the client desires.  May be
 a pattern, such as *&amp;#47;*, if the caller does not have specific type
 requirements; in this case the content provider will pick its best
 type matching the pattern.
@param {Object {Bundle}} opts Additional options from the client.  The definitions of
 these are specific to the content provider being called.
@return {Object {android.content.res.AssetFileDescriptor}} Returns a new AssetFileDescriptor from which the client can
 read data of the desired type.
@throws FileNotFoundException Throws FileNotFoundException if there is
 no file associated with the given URI or the mode is invalid.
@throws SecurityException Throws SecurityException if the caller does
 not have permission to access the data.
@throws IllegalArgumentException Throws IllegalArgumentException if the
 content provider does not support the requested MIME type.
@see #getStreamTypes(Uri, String)
@see #openAssetFile(Uri, String)
@see ClipDescription#compareMimeTypes(String, String)
*/
openTypedAssetFile : function(  ) {},

<span id='android-content-ContentProvider-method-openTypedAssetFile'>/**Called by a client to open a read-only stream containing data of a
</span> particular MIME type.  This is like {@link #openAssetFile(Uri, String)},
 except the file can only be read-only and the content provider may
 perform data conversions to generate data of the desired type.

 &lt;p&gt;The default implementation compares the given mimeType against the
 result of {@link #getType}(Uri) and, if they match, simply calls
 {@link #openAssetFile(Uri, String)}.

 &lt;p&gt;See {@link android.content.ClipData} for examples of the use and implementation
 of this method.
 &lt;p&gt;
 The returned AssetFileDescriptor can be a pipe or socket pair to enable
 streaming of data.

 &lt;p class=&quot;note&quot;&gt;For better interoperability with other applications, it is recommended
 that for any URIs that can be opened, you also support queries on them
 containing at least the columns specified by {@link android.provider.OpenableColumns}.
 You may also want to support other common columns if you have additional meta-data
 to supply, such as {@link android.provider.MediaStore.MediaColumns#DATE_ADDED}
 in {@link android.provider.MediaStore.MediaColumns}.&lt;/p&gt;
@param {Object {Uri}} uri The data in the content provider being queried.
@param {String} mimeTypeFilter The type of data the client desires.  May be
 a pattern, such as *&amp;#47;*, if the caller does not have specific type
 requirements; in this case the content provider will pick its best
 type matching the pattern.
@param {Object {Bundle}} opts Additional options from the client.  The definitions of
 these are specific to the content provider being called.
@param {Object {CancellationSignal}} signal A signal to cancel the operation in progress, or
            {@code null} if none. For example, if you are downloading a
            file from the network to service a &quot;rw&quot; mode request, you
            should periodically call
            {@link CancellationSignal#throwIfCanceled()} to check whether
            the client has canceled the request and abort the download.
@return {Object {android.content.res.AssetFileDescriptor}} Returns a new AssetFileDescriptor from which the client can
 read data of the desired type.
@throws FileNotFoundException Throws FileNotFoundException if there is
 no file associated with the given URI or the mode is invalid.
@throws SecurityException Throws SecurityException if the caller does
 not have permission to access the data.
@throws IllegalArgumentException Throws IllegalArgumentException if the
 content provider does not support the requested MIME type.
@see #getStreamTypes(Uri, String)
@see #openAssetFile(Uri, String)
@see ClipDescription#compareMimeTypes(String, String)
*/
openTypedAssetFile : function(  ) {},

<span id='android-content-ContentProvider-method-openPipeHelper'>/**A helper function for implementing {@link #openTypedAssetFile}, for
</span> creating a data pipe and background thread allowing you to stream
 generated data back to the client.  This function returns a new
 ParcelFileDescriptor that should be returned to the caller (the caller
 is responsible for closing it).
@param {Object {Uri}} uri The URI whose data is to be written.
@param {String} mimeType The desired type of data to be written.
@param {Object {Bundle}} opts Options supplied by caller.
@param {Object {Object}} args Your own custom arguments.
@param {Object {android.content.ContentProvider.PipeDataWriter}} func Interface implementing the function that will actually
 stream the data.
@return {Object {android.os.ParcelFileDescriptor}} Returns a new ParcelFileDescriptor holding the read side of
 the pipe.  This should be returned to the caller for reading; the caller
 is responsible for closing it when done.
*/
openPipeHelper : function(  ) {},

<span id='android-content-ContentProvider-method-getIContentProvider'>/**Returns the Binder object for this provider.
</span>@return {Object {android.content.IContentProvider}} the Binder object for this provider
@hide 
*/
getIContentProvider : function(  ) {},

<span id='android-content-ContentProvider-method-attachInfoForTesting'>/**Like {@link #attachInfo(Context, android.content.pm.ProviderInfo)}, but for use
</span> when directly instantiating the provider for testing.
@hide 
*/
attachInfoForTesting : function(  ) {},

<span id='android-content-ContentProvider-method-attachInfo'>/**After being instantiated, this is called to tell the content provider
</span> about itself.
@param {Object {Context}} context The context this provider is running in
@param {Object {ProviderInfo}} info Registered information about this content provider
*/
attachInfo : function(  ) {},

<span id='android-content-ContentProvider-method-applyBatch'>/**Override this to handle requests to perform a batch of operations, or the
</span> default implementation will iterate over the operations and call
 {@link android.content.ContentProviderOperation#apply} on each of them.
 If all calls to {@link android.content.ContentProviderOperation#apply} succeed
 then a {@link android.content.ContentProviderResult} array with as many
 elements as there were operations will be returned.  If any of the calls
 fail, it is up to the implementation how many of the others take effect.
 This method can be called from multiple threads, as described in
 &lt;a href=&quot;{@docRoot}guide/topics/fundamentals/processes-and-threads.html#Threads&quot;&gt;Processes
 and Threads&lt;/a&gt;.
@param {String} operations the operations to apply
@return {Object {android.content.ContentProviderResult}} the results of the applications
@throws OperationApplicationException thrown if any operation fails.
@see ContentProviderOperation#apply
*/
applyBatch : function(  ) {},

<span id='android-content-ContentProvider-method-applyBatch'>/**
</span>*/
applyBatch : function(  ) {},

<span id='android-content-ContentProvider-method-call'>/**Call a provider-defined method.  This can be used to implement
</span> interfaces that are cheaper and/or unnatural for a table-like
 model.

 &lt;p class=&quot;note&quot;&gt;&lt;strong&gt;WARNING:&lt;/strong&gt; The framework does no permission checking
 on this entry into the content provider besides the basic ability for the application
 to get access to the provider at all.  For example, it has no idea whether the call
 being executed may read or write data in the provider, so can't enforce those
 individual permissions.  Any implementation of this method &lt;strong&gt;must&lt;/strong&gt;
 do its own permission checks on incoming calls to make sure they are allowed.&lt;/p&gt;
@param {String} method method name to call.  Opaque to framework, but should not be {@code null}.
@param {String} arg provider-defined String argument.  May be {@code null}.
@param {String} extras provider-defined Bundle argument.  May be {@code null}.
@return {Object {android.os.Bundle}} provider-defined return value.  May be {@code null}, which is also
   the default for providers which don't implement any call methods.
*/
call : function(  ) {},

<span id='android-content-ContentProvider-method-call'>/**
</span>*/
call : function(  ) {},

<span id='android-content-ContentProvider-method-shutdown'>/**Implement this to shut down the ContentProvider instance. You can then
</span> invoke this method in unit tests.

 &lt;p&gt;
 Android normally handles ContentProvider startup and shutdown
 automatically. You do not need to start up or shut down a
 ContentProvider. When you invoke a test method on a ContentProvider,
 however, a ContentProvider instance is started and keeps running after
 the test finishes, even if a succeeding test instantiates another
 ContentProvider. A conflict develops because the two instances are
 usually running against the same underlying data source (for example, an
 sqlite database).
 &lt;/p&gt;
 &lt;p&gt;
 Implementing shutDown() avoids this conflict by providing a way to
 terminate the ContentProvider. This method can also prevent memory leaks
 from multiple instantiations of the ContentProvider, and it can ensure
 unit test isolation by allowing you to completely clean up the test
 fixture before moving on to the next test.
 &lt;/p&gt;
*/
shutdown : function(  ) {},

<span id='android-content-ContentProvider-method-dump'>/**Print the Provider's state into the given stream.  This gets invoked if
</span> you run &quot;adb shell dumpsys activity provider &amp;lt;provider_component_name&amp;gt;&quot;.
@param {Object {FileDescriptor}} fd The raw file descriptor that the dump is being sent to.
@param {Object {PrintWriter}} writer The PrintWriter to which you should dump your state.  This will be
 closed for you after you return.
@param {Object {java.lang.String[]}} args additional arguments to the dump request.
*/
dump : function(  ) {},

<span id='android-content-ContentProvider-method-validateIncomingUri'>/**
</span>@hide 
*/
validateIncomingUri : function(  ) {},

<span id='android-content-ContentProvider-method-getUserIdFromAuthority'>/**
</span>@hide 
*/
getUserIdFromAuthority : function(  ) {},

<span id='android-content-ContentProvider-method-getUserIdFromAuthority'>/**
</span>@hide 
*/
getUserIdFromAuthority : function(  ) {},

<span id='android-content-ContentProvider-method-getUserIdFromUri'>/**
</span>@hide 
*/
getUserIdFromUri : function(  ) {},

<span id='android-content-ContentProvider-method-getUserIdFromUri'>/**
</span>@hide 
*/
getUserIdFromUri : function(  ) {},

<span id='android-content-ContentProvider-method-getAuthorityWithoutUserId'>/**Removes userId part from authority string. Expects format:
</span> userId@some.authority
 If there is no userId in the authority, it symply returns the argument
@hide 
*/
getAuthorityWithoutUserId : function(  ) {},

<span id='android-content-ContentProvider-method-getUriWithoutUserId'>/**
</span>@hide 
*/
getUriWithoutUserId : function(  ) {},

<span id='android-content-ContentProvider-method-uriHasUserId'>/**
</span>@hide 
*/
uriHasUserId : function(  ) {},

<span id='android-content-ContentProvider-method-maybeAddUserId'>/**
</span>@hide 
*/
maybeAddUserId : function(  ) {},


};</pre>
</body>
</html>
