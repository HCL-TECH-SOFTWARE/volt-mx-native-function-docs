<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='android-media-MediaPlayer2'>/**@class android.media.MediaPlayer2
</span> implements java.lang.AutoCloseable

 implements android.media.AudioRouting

@extends java.lang.Object

 MediaPlayer2 class can be used to control playback of audio/video files and streams.

 &lt;p&gt;
 This API is not generally intended for third party application developers.
 Use the &lt;a href=&quot;{@docRoot}jetpack/androidx.html&quot;&gt;AndroidX&lt;/a&gt;
 &lt;a href=&quot;{@docRoot}reference/androidx/media2/package-summary.html&quot;&gt;Media2 Library&lt;/a&gt;
 for consistent behavior across all devices.

 &lt;p&gt;Topics covered here are:
 &lt;ol&gt;
 &lt;li&gt;&lt;a href=&quot;#PlayerStates&quot;&gt;Player states&lt;/a&gt;
 &lt;li&gt;&lt;a href=&quot;#InvalidStates&quot;&gt;Invalid method calls&lt;/a&gt;
 &lt;li&gt;&lt;a href=&quot;#Permissions&quot;&gt;Permissions&lt;/a&gt;
 &lt;li&gt;&lt;a href=&quot;#Callbacks&quot;&gt;Callbacks&lt;/a&gt;
 &lt;/ol&gt;


 &lt;h3 id=&quot;PlayerStates&quot;&gt;Player states&lt;/h3&gt;

 &lt;p&gt;The playback control of audio/video files is managed as a state machine.&lt;/p&gt;
 &lt;p&gt;&lt;div style=&quot;text-align:center;&quot;&gt;&lt;img src=&quot;../../../images/mediaplayer2_state_diagram.png&quot;
         alt=&quot;MediaPlayer2 State diagram&quot;
         border=&quot;0&quot; /&gt;&lt;/div&gt;&lt;/p&gt;
 &lt;p&gt;The MediaPlayer2 object has five states:&lt;/p&gt;
 &lt;ol&gt;
     &lt;li&gt;&lt;p&gt;{@link #PLAYER_STATE_IDLE}: MediaPlayer2 is in the &lt;strong&gt;Idle&lt;/strong&gt;
         state after it's created, or after calling {@link #reset}().&lt;/p&gt;

         &lt;p&gt;While in this state, you should call
         {@link #setDataSource setDataSource}. It is a good
         programming practice to register an {@link android.media.MediaPlayer2.EventCallback#onCallCompleted onCallCompleted}
         &lt;a href=&quot;#Callbacks&quot;&gt;callback&lt;/a&gt; and watch for {@link #CALL_STATUS_BAD_VALUE} and
         {@link #CALL_STATUS_ERROR_IO}, which might be caused by &lt;code&gt;setDataSource&lt;/code&gt;.
         &lt;/p&gt;

         &lt;p&gt;Calling {@link #prepare}() transfers a MediaPlayer2 object to
         the &lt;strong&gt;Prepared&lt;/strong&gt; state. Note
         that {@link #prepare}() is asynchronous. When the preparation completes,
         if you register an {@link android.media.MediaPlayer2.EventCallback#onInfo onInfo} &lt;a href=&quot;#Callbacks&quot;&gt;callback&lt;/a&gt;,
         the player executes the callback
         with {@link #MEDIA_INFO_PREPARED} and transitions to the
         &lt;strong&gt;Prepared&lt;/strong&gt; state.&lt;/p&gt;
         &lt;/li&gt;

     &lt;li&gt;{@link #PLAYER_STATE_PREPARED}: A MediaPlayer object must be in the
         &lt;strong&gt;Prepared&lt;/strong&gt; state before playback can be started for the first time.
         While in this state, you can set player properties
         such as audio/sound volume and looping by invoking the corresponding set methods.
         Calling {@link #play}() transfers a MediaPlayer2 object to
         the &lt;strong&gt;Playing&lt;/strong&gt; state.
      &lt;/li&gt;

     &lt;li&gt;{@link #PLAYER_STATE_PLAYING}:
         &lt;p&gt;The player plays the data source while in this state.
         If you register an {@link android.media.MediaPlayer2.EventCallback#onInfo onInfo} &lt;a href=&quot;#Callbacks&quot;&gt;callback&lt;/a&gt;,
         the player regularly executes the callback with
         {@link #MEDIA_INFO_BUFFERING_UPDATE}.
         This allows applications to keep track of the buffering status
         while streaming audio/video.&lt;/p&gt;

         &lt;p&gt; When the playback reaches the end of stream, the behavior depends on whether or
         not you've enabled looping by calling {@link #loopCurrent}:&lt;/p&gt;
         &lt;ul&gt;
         &lt;li&gt;If the looping mode was set to &lt;code&gt;false&lt;/code&gt;, the player will transfer
         to the &lt;strong&gt;Paused&lt;/strong&gt; state. If you registered an {@link android.media.MediaPlayer2.EventCallback#onInfo
         onInfo} &lt;a href=&quot;#Callbacks&quot;&gt;callback&lt;/a&gt;
         the player calls the callback with {@link #MEDIA_INFO_DATA_SOURCE_END} and enters
         the &lt;strong&gt;Paused&lt;/strong&gt; state.
         &lt;/li&gt;
         &lt;li&gt;If the looping mode was set to &lt;code&gt;true&lt;/code&gt;,
         the MediaPlayer2 object remains in the &lt;strong&gt;Playing&lt;/strong&gt; state and replays its
         data source from the beginning.&lt;/li&gt;
         &lt;/ul&gt;
         &lt;/li&gt;

     &lt;li&gt;{@link #PLAYER_STATE_PAUSED}: Audio/video playback pauses while in this state.
         Call {@link #play}() to resume playback from the position where it paused.&lt;/li&gt;

     &lt;li&gt;{@link #PLAYER_STATE_ERROR}: &lt;p&gt;In general, playback might fail due to various
          reasons such as unsupported audio/video format, poorly interleaved
          audio/video, resolution too high, streaming timeout, and others.
          In addition, due to programming errors, a playback
          control operation might be performed from an &lt;a href=&quot;#InvalidStates&quot;&gt;invalid state&lt;/a&gt;.
          In these cases the player transitions to the &lt;strong&gt;Error&lt;/strong&gt; state.&lt;/p&gt;

          &lt;p&gt;If you register an {@link android.media.MediaPlayer2.EventCallback#onError onError}}
          &lt;a href=&quot;#Callbacks&quot;&gt;callback&lt;/a&gt;,
          the callback will be performed when entering the state. When programming errors happen,
          such as calling {@link #prepare}() and
          {@link #setDataSource} methods
          from an &lt;a href=&quot;#InvalidStates&quot;&gt;invalid state&lt;/a&gt;, the callback is called with
          {@link #CALL_STATUS_INVALID_OPERATION}. The MediaPlayer2 object enters the
          &lt;strong&gt;Error&lt;/strong&gt; state whether or not a callback exists. &lt;/p&gt;

          &lt;p&gt;To recover from an error and reuse a MediaPlayer2 object that is in the &lt;strong&gt;
          Error&lt;/strong&gt; state,
          call {@link #reset}(). The object will return to the &lt;strong&gt;Idle&lt;/strong&gt;
          state and all state information will be lost.&lt;/p&gt;
          &lt;/li&gt;
 &lt;/ol&gt;

 &lt;p&gt;You should follow these best practices when coding an app that uses MediaPlayer2:&lt;/p&gt;

 &lt;ul&gt;

 &lt;li&gt;Use &lt;a href=&quot;#Callbacks&quot;&gt;callbacks&lt;/a&gt; to respond to state changes and errors.&lt;/li&gt;

 &lt;li&gt;When  a MediaPlayer2 object is no longer being used, call {@link #close}() as soon as
 possible to release the resources used by the internal player engine associated with the
 MediaPlayer2. Failure to call {@link #close}() may cause subsequent instances of
 MediaPlayer2 objects to fallback to software implementations or fail altogether.
 You cannot use MediaPlayer2
 after you call {@link #close}(). There is no way to bring it back to any other state.&lt;/li&gt;

 &lt;li&gt;The current playback position can be retrieved with a call to
 {@link #getCurrentPosition}(),
 which is helpful for applications such as a Music player that need to keep track of the playback
 progress.&lt;/li&gt;

 &lt;li&gt;The playback position can be adjusted with a call to {@link #seekTo}. Although the
 asynchronous {@link #seekTo} call returns right away, the actual seek operation may take a
 while to finish, especially for audio/video being streamed. If you register an
 {@link android.media.MediaPlayer2.EventCallback#onCallCompleted onCallCompleted} &lt;a href=&quot;#Callbacks&quot;&gt;callback&lt;/a&gt;,
 the callback is
 called When the seek operation completes with {@link #CALL_COMPLETED_SEEK_TO}.&lt;/li&gt;

 &lt;li&gt;You can call {@link #seekTo} from the &lt;strong&gt;Paused&lt;/strong&gt; state.
 In this case, if you are playing a video stream and
 the requested position is valid  one video frame is displayed.&lt;/li&gt;

 &lt;/ul&gt;

 &lt;h3 id=&quot;InvalidStates&quot;&gt;Invalid method calls&lt;/h3&gt;

 &lt;p&gt;The only methods you safely call from the &lt;strong&gt;Error&lt;/strong&gt; state are
 {@link #close},
 {@link #reset},
 {@link #notifyWhenCommandLabelReached},
 {@link #clearPendingCommands},
 {@link #registerEventCallback},
 {@link #unregisterEventCallback}
 and {@link #getState}.
 Any other methods might throw an exception, return meaningless data, or invoke a
 {@link android.media.MediaPlayer2.EventCallback#onCallCompleted onCallCompleted} with an error code.&lt;/p&gt;

 &lt;p&gt;Most methods can be called from any non-Error state. They will either perform their work or
 silently have no effect. The following table lists the methods that will invoke a
 {@link android.media.MediaPlayer2.EventCallback#onCallCompleted onCallCompleted} with an error code
 or throw an exception when they are called from the associated invalid states.&lt;/p&gt;

 &lt;table border=&quot;0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;
 &lt;tr&gt;&lt;th&gt;Method Name&lt;/th&gt;
 &lt;th&gt;Invalid States&lt;/th&gt;&lt;/tr&gt;

 &lt;tr&gt;&lt;td&gt;setDataSource&lt;/td&gt; &lt;td&gt;{Prepared, Paused, Playing}&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;prepare&lt;/td&gt; &lt;td&gt;{Prepared, Paused, Playing}&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;play&lt;/td&gt; &lt;td&gt;{Idle}&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;pause&lt;/td&gt; &lt;td&gt;{Idle}&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;seekTo&lt;/td&gt; &lt;td&gt;{Idle}&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;getCurrentPosition&lt;/td&gt; &lt;td&gt;{Idle}&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;getDuration&lt;/td&gt; &lt;td&gt;{Idle}&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;getBufferedPosition&lt;/td&gt; &lt;td&gt;{Idle}&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;getTrackInfo&lt;/td&gt; &lt;td&gt;{Idle}&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;getSelectedTrack&lt;/td&gt; &lt;td&gt;{Idle}&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;selectTrack&lt;/td&gt; &lt;td&gt;{Idle}&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;deselectTrack&lt;/td&gt; &lt;td&gt;{Idle}&lt;/td&gt;&lt;/tr&gt;
 &lt;/table&gt;

 &lt;h3 id=&quot;Permissions&quot;&gt;Permissions&lt;/h3&gt;
 &lt;p&gt;This class requires the {@link android.Manifest.permission#INTERNET} permission
 when used with network-based content.

 &lt;h3 id=&quot;Callbacks&quot;&gt;Callbacks&lt;/h3&gt;
 &lt;p&gt;Many errors do not result in a transition to the  &lt;strong&gt;Error&lt;/strong&gt; state.
 It is good programming practice to register callback listeners using
 {@link #registerEventCallback}.
 You can receive a callback at any time and from any state.&lt;/p&gt;

 &lt;p&gt;If it's important for your app to respond to state changes (for instance, to update the
 controls on a transport UI), you should register an
 {@link android.media.MediaPlayer2.EventCallback#onCallCompleted onCallCompleted} and
 detect state change commands by testing the &lt;code&gt;what&lt;/code&gt; parameter for a callback from one
 of the state transition methods: {@link #CALL_COMPLETED_PREPARE}, {@link #CALL_COMPLETED_PLAY},
 and {@link #CALL_COMPLETED_PAUSE}.
 Then check the &lt;code&gt;status&lt;/code&gt; parameter. The value {@link #CALL_STATUS_NO_ERROR} indicates a
 successful transition. Any other value will be an error. Call {@link #getState}() to
 determine the current state. &lt;/p&gt;

 @hide
*/
var MediaPlayer2 = {

<span id='android-media-MediaPlayer2-property-PLAYER_STATE_IDLE'>/** MediaPlayer2 has not been prepared or just has been reset.
</span> In this state, MediaPlayer2 doesn't fetch data.
*/
PLAYER_STATE_IDLE : &quot;1001&quot;,
<span id='android-media-MediaPlayer2-property-PLAYER_STATE_PREPARED'>/** MediaPlayer2 has been just prepared.
</span> In this state, MediaPlayer2 just fetches data from media source,
 but doesn't actively render data.
*/
PLAYER_STATE_PREPARED : &quot;1002&quot;,
<span id='android-media-MediaPlayer2-property-PLAYER_STATE_PAUSED'>/** MediaPlayer2 is paused.
</span> In this state, MediaPlayer2 has allocated resources to construct playback
 pipeline, but it doesn't actively render data.
*/
PLAYER_STATE_PAUSED : &quot;1003&quot;,
<span id='android-media-MediaPlayer2-property-PLAYER_STATE_PLAYING'>/** MediaPlayer2 is actively playing back data.
</span>*/
PLAYER_STATE_PLAYING : &quot;1004&quot;,
<span id='android-media-MediaPlayer2-property-PLAYER_STATE_ERROR'>/** MediaPlayer2 has hit some fatal error and cannot continue playback.
</span>*/
PLAYER_STATE_ERROR : &quot;1005&quot;,
<span id='android-media-MediaPlayer2-property-SEEK_PREVIOUS_SYNC'>/** This mode is used with {@link #seekTo(long, int)} to move media position to
</span> a sync (or key) frame associated with a data source that is located
 right before or at the given time.

 @see #seekTo(long, int)
*/
SEEK_PREVIOUS_SYNC : &quot;0&quot;,
<span id='android-media-MediaPlayer2-property-SEEK_NEXT_SYNC'>/** This mode is used with {@link #seekTo(long, int)} to move media position to
</span> a sync (or key) frame associated with a data source that is located
 right after or at the given time.

 @see #seekTo(long, int)
*/
SEEK_NEXT_SYNC : &quot;1&quot;,
<span id='android-media-MediaPlayer2-property-SEEK_CLOSEST_SYNC'>/** This mode is used with {@link #seekTo(long, int)} to move media position to
</span> a sync (or key) frame associated with a data source that is located
 closest to (in time) or at the given time.

 @see #seekTo(long, int)
*/
SEEK_CLOSEST_SYNC : &quot;2&quot;,
<span id='android-media-MediaPlayer2-property-SEEK_CLOSEST'>/** This mode is used with {@link #seekTo(long, int)} to move media position to
</span> a frame (not necessarily a key frame) associated with a data source that
 is located closest to or at the given time.

 @see #seekTo(long, int)
*/
SEEK_CLOSEST : &quot;3&quot;,
<span id='android-media-MediaPlayer2-property-MEDIA_ERROR_UNKNOWN'>/**Unspecified media player error.
</span> @see EventCallback#onError
*/
MEDIA_ERROR_UNKNOWN : &quot;1&quot;,
<span id='android-media-MediaPlayer2-property-MEDIA_ERROR_NOT_VALID_FOR_PROGRESSIVE_PLAYBACK'>/** The video is streamed and its container is not valid for progressive
</span> playback i.e the video's index (e.g moov atom) is not at the start of the
 file.
 @see EventCallback#onError
*/
MEDIA_ERROR_NOT_VALID_FOR_PROGRESSIVE_PLAYBACK : &quot;200&quot;,
<span id='android-media-MediaPlayer2-property-MEDIA_ERROR_IO'>/**File or network related operation errors. */
</span>MEDIA_ERROR_IO : &quot;-1004&quot;,
<span id='android-media-MediaPlayer2-property-MEDIA_ERROR_MALFORMED'>/**Bitstream is not conforming to the related coding standard or file spec. */
</span>MEDIA_ERROR_MALFORMED : &quot;-1007&quot;,
<span id='android-media-MediaPlayer2-property-MEDIA_ERROR_UNSUPPORTED'>/**Bitstream is conforming to the related coding standard or file spec, but
</span> the media framework does not support the feature. */
MEDIA_ERROR_UNSUPPORTED : &quot;-1010&quot;,
<span id='android-media-MediaPlayer2-property-MEDIA_ERROR_TIMED_OUT'>/**Some operation takes too long to complete, usually more than 3-5 seconds. */
</span>MEDIA_ERROR_TIMED_OUT : &quot;-110&quot;,
<span id='android-media-MediaPlayer2-property-MEDIA_ERROR_SYSTEM'>/**Unspecified low-level system error. This value originated from UNKNOWN_ERROR in
</span> system/core/include/utils/Errors.h
 @see EventCallback#onError
 @hide
*/
MEDIA_ERROR_SYSTEM : &quot;-2147483648&quot;,
<span id='android-media-MediaPlayer2-property-MEDIA_INFO_UNKNOWN'>/**Unspecified media player info.
</span> @see EventCallback#onInfo
*/
MEDIA_INFO_UNKNOWN : &quot;1&quot;,
<span id='android-media-MediaPlayer2-property-MEDIA_INFO_DATA_SOURCE_START'>/**The player just started the playback of this datas source.
</span> @see EventCallback#onInfo
*/
MEDIA_INFO_DATA_SOURCE_START : &quot;2&quot;,
<span id='android-media-MediaPlayer2-property-MEDIA_INFO_VIDEO_RENDERING_START'>/**The player just pushed the very first video frame for rendering.
</span> @see EventCallback#onInfo
*/
MEDIA_INFO_VIDEO_RENDERING_START : &quot;3&quot;,
<span id='android-media-MediaPlayer2-property-MEDIA_INFO_AUDIO_RENDERING_START'>/**The player just rendered the very first audio sample.
</span> @see EventCallback#onInfo
*/
MEDIA_INFO_AUDIO_RENDERING_START : &quot;4&quot;,
<span id='android-media-MediaPlayer2-property-MEDIA_INFO_DATA_SOURCE_END'>/**The player just completed the playback of this data source.
</span> @see EventCallback#onInfo
*/
MEDIA_INFO_DATA_SOURCE_END : &quot;5&quot;,
<span id='android-media-MediaPlayer2-property-MEDIA_INFO_DATA_SOURCE_LIST_END'>/**The player just completed the playback of all data sources set by {@link #setDataSource},
</span> {@link #setNextDataSource} and {@link #setNextDataSources}.
 @see EventCallback#onInfo
*/
MEDIA_INFO_DATA_SOURCE_LIST_END : &quot;6&quot;,
<span id='android-media-MediaPlayer2-property-MEDIA_INFO_DATA_SOURCE_REPEAT'>/**The player just completed an iteration of playback loop. This event is sent only when
</span>  looping is enabled by {@link #loopCurrent}.
 @see EventCallback#onInfo
*/
MEDIA_INFO_DATA_SOURCE_REPEAT : &quot;7&quot;,
<span id='android-media-MediaPlayer2-property-MEDIA_INFO_PREPARED'>/**The player just prepared a data source.
</span> @see EventCallback#onInfo
*/
MEDIA_INFO_PREPARED : &quot;100&quot;,
<span id='android-media-MediaPlayer2-property-MEDIA_INFO_VIDEO_TRACK_LAGGING'>/**The video is too complex for the decoder: it can't decode frames fast
</span>  enough. Possibly only the audio plays fine at this stage.
 @see EventCallback#onInfo
*/
MEDIA_INFO_VIDEO_TRACK_LAGGING : &quot;700&quot;,
<span id='android-media-MediaPlayer2-property-MEDIA_INFO_BUFFERING_START'>/**MediaPlayer2 is temporarily pausing playback internally in order to
</span> buffer more data.
 @see EventCallback#onInfo
*/
MEDIA_INFO_BUFFERING_START : &quot;701&quot;,
<span id='android-media-MediaPlayer2-property-MEDIA_INFO_BUFFERING_END'>/**MediaPlayer2 is resuming playback after filling buffers.
</span> @see EventCallback#onInfo
*/
MEDIA_INFO_BUFFERING_END : &quot;702&quot;,
<span id='android-media-MediaPlayer2-property-MEDIA_INFO_NETWORK_BANDWIDTH'>/**Estimated network bandwidth information (kbps) is available; currently this event fires
</span> simultaneously as {@link #MEDIA_INFO_BUFFERING_START} and {@link #MEDIA_INFO_BUFFERING_END}
 when playing network files.
 @see EventCallback#onInfo
 @hide
*/
MEDIA_INFO_NETWORK_BANDWIDTH : &quot;703&quot;,
<span id='android-media-MediaPlayer2-property-MEDIA_INFO_BUFFERING_UPDATE'>/** Update status in buffering a media source received through progressive downloading.
</span> The received buffering percentage indicates how much of the content has been buffered
 or played. For example a buffering update of 80 percent when half the content
 has already been played indicates that the next 30 percent of the
 content to play has been buffered.

 The {@code extra} parameter in {@code EventCallback.onInfo} is the
 percentage (0-100) of the content that has been buffered or played thus far.
 @see EventCallback#onInfo
*/
MEDIA_INFO_BUFFERING_UPDATE : &quot;704&quot;,
<span id='android-media-MediaPlayer2-property-MEDIA_INFO_BAD_INTERLEAVING'>/**Bad interleaving means that a media has been improperly interleaved or
</span> not interleaved at all, e.g has all the video samples first then all the
 audio ones. Video is playing but a lot of disk seeks may be happening.
 @see EventCallback#onInfo
*/
MEDIA_INFO_BAD_INTERLEAVING : &quot;800&quot;,
<span id='android-media-MediaPlayer2-property-MEDIA_INFO_NOT_SEEKABLE'>/**The media cannot be seeked (e.g live stream)
</span> @see EventCallback#onInfo
*/
MEDIA_INFO_NOT_SEEKABLE : &quot;801&quot;,
<span id='android-media-MediaPlayer2-property-MEDIA_INFO_METADATA_UPDATE'>/**A new set of metadata is available.
</span> @see EventCallback#onInfo
*/
MEDIA_INFO_METADATA_UPDATE : &quot;802&quot;,
<span id='android-media-MediaPlayer2-property-MEDIA_INFO_AUDIO_NOT_PLAYING'>/**Informs that audio is not playing. Note that playback of the video
</span> is not interrupted.
 @see EventCallback#onInfo
*/
MEDIA_INFO_AUDIO_NOT_PLAYING : &quot;804&quot;,
<span id='android-media-MediaPlayer2-property-MEDIA_INFO_VIDEO_NOT_PLAYING'>/**Informs that video is not playing. Note that playback of the audio
</span> is not interrupted.
 @see EventCallback#onInfo
*/
MEDIA_INFO_VIDEO_NOT_PLAYING : &quot;805&quot;,
<span id='android-media-MediaPlayer2-property-MEDIA_INFO_TIMED_TEXT_ERROR'>/**Failed to handle timed text track properly.
</span> @see EventCallback#onInfo

 {@hide}
*/
MEDIA_INFO_TIMED_TEXT_ERROR : &quot;900&quot;,
<span id='android-media-MediaPlayer2-property-MEDIA_INFO_UNSUPPORTED_SUBTITLE'>/**Subtitle track was not supported by the media framework.
</span> @see EventCallback#onInfo
*/
MEDIA_INFO_UNSUPPORTED_SUBTITLE : &quot;901&quot;,
<span id='android-media-MediaPlayer2-property-MEDIA_INFO_SUBTITLE_TIMED_OUT'>/**Reading the subtitle track takes too long.
</span> @see EventCallback#onInfo
*/
MEDIA_INFO_SUBTITLE_TIMED_OUT : &quot;902&quot;,
<span id='android-media-MediaPlayer2-property-CALL_COMPLETED_ATTACH_AUX_EFFECT'>/**The player just completed a call {@link #attachAuxEffect}.
</span> @see EventCallback#onCallCompleted
*/
CALL_COMPLETED_ATTACH_AUX_EFFECT : &quot;1&quot;,
<span id='android-media-MediaPlayer2-property-CALL_COMPLETED_DESELECT_TRACK'>/**The player just completed a call {@link #deselectTrack}.
</span> @see EventCallback#onCallCompleted
*/
CALL_COMPLETED_DESELECT_TRACK : &quot;2&quot;,
<span id='android-media-MediaPlayer2-property-CALL_COMPLETED_LOOP_CURRENT'>/**The player just completed a call {@link #loopCurrent}.
</span> @see EventCallback#onCallCompleted
*/
CALL_COMPLETED_LOOP_CURRENT : &quot;3&quot;,
<span id='android-media-MediaPlayer2-property-CALL_COMPLETED_PAUSE'>/**The player just completed a call {@link #pause}.
</span> @see EventCallback#onCallCompleted
*/
CALL_COMPLETED_PAUSE : &quot;4&quot;,
<span id='android-media-MediaPlayer2-property-CALL_COMPLETED_PLAY'>/**The player just completed a call {@link #play}.
</span> @see EventCallback#onCallCompleted
*/
CALL_COMPLETED_PLAY : &quot;5&quot;,
<span id='android-media-MediaPlayer2-property-CALL_COMPLETED_PREPARE'>/**The player just completed a call {@link #prepare}.
</span> @see EventCallback#onCallCompleted
*/
CALL_COMPLETED_PREPARE : &quot;6&quot;,
<span id='android-media-MediaPlayer2-property-CALL_COMPLETED_SEEK_TO'>/**The player just completed a call {@link #seekTo}.
</span> @see EventCallback#onCallCompleted
*/
CALL_COMPLETED_SEEK_TO : &quot;14&quot;,
<span id='android-media-MediaPlayer2-property-CALL_COMPLETED_SELECT_TRACK'>/**The player just completed a call {@link #selectTrack}.
</span> @see EventCallback#onCallCompleted
*/
CALL_COMPLETED_SELECT_TRACK : &quot;15&quot;,
<span id='android-media-MediaPlayer2-property-CALL_COMPLETED_SET_AUDIO_ATTRIBUTES'>/**The player just completed a call {@link #setAudioAttributes}.
</span> @see EventCallback#onCallCompleted
*/
CALL_COMPLETED_SET_AUDIO_ATTRIBUTES : &quot;16&quot;,
<span id='android-media-MediaPlayer2-property-CALL_COMPLETED_SET_AUDIO_SESSION_ID'>/**The player just completed a call {@link #setAudioSessionId}.
</span> @see EventCallback#onCallCompleted
*/
CALL_COMPLETED_SET_AUDIO_SESSION_ID : &quot;17&quot;,
<span id='android-media-MediaPlayer2-property-CALL_COMPLETED_SET_AUX_EFFECT_SEND_LEVEL'>/**The player just completed a call {@link #setAuxEffectSendLevel}.
</span> @see EventCallback#onCallCompleted
*/
CALL_COMPLETED_SET_AUX_EFFECT_SEND_LEVEL : &quot;18&quot;,
<span id='android-media-MediaPlayer2-property-CALL_COMPLETED_SET_DATA_SOURCE'>/**The player just completed a call {@link #setDataSource}.
</span> @see EventCallback#onCallCompleted
*/
CALL_COMPLETED_SET_DATA_SOURCE : &quot;19&quot;,
<span id='android-media-MediaPlayer2-property-CALL_COMPLETED_SET_NEXT_DATA_SOURCE'>/**The player just completed a call {@link #setNextDataSource}.
</span> @see EventCallback#onCallCompleted
*/
CALL_COMPLETED_SET_NEXT_DATA_SOURCE : &quot;22&quot;,
<span id='android-media-MediaPlayer2-property-CALL_COMPLETED_SET_NEXT_DATA_SOURCES'>/**The player just completed a call {@link #setNextDataSources}.
</span> @see EventCallback#onCallCompleted
*/
CALL_COMPLETED_SET_NEXT_DATA_SOURCES : &quot;23&quot;,
<span id='android-media-MediaPlayer2-property-CALL_COMPLETED_SET_PLAYBACK_PARAMS'>/**The player just completed a call {@link #setPlaybackParams}.
</span> @see EventCallback#onCallCompleted
*/
CALL_COMPLETED_SET_PLAYBACK_PARAMS : &quot;24&quot;,
<span id='android-media-MediaPlayer2-property-CALL_COMPLETED_SET_PLAYER_VOLUME'>/**The player just completed a call {@link #setPlayerVolume}.
</span> @see EventCallback#onCallCompleted
*/
CALL_COMPLETED_SET_PLAYER_VOLUME : &quot;26&quot;,
<span id='android-media-MediaPlayer2-property-CALL_COMPLETED_SET_SURFACE'>/**The player just completed a call {@link #setSurface}.
</span> @see EventCallback#onCallCompleted
*/
CALL_COMPLETED_SET_SURFACE : &quot;27&quot;,
<span id='android-media-MediaPlayer2-property-CALL_COMPLETED_SET_SYNC_PARAMS'>/**The player just completed a call {@link #setSyncParams}.
</span> @see EventCallback#onCallCompleted
*/
CALL_COMPLETED_SET_SYNC_PARAMS : &quot;28&quot;,
<span id='android-media-MediaPlayer2-property-CALL_COMPLETED_SKIP_TO_NEXT'>/**The player just completed a call {@link #skipToNext}.
</span> @see EventCallback#onCallCompleted
*/
CALL_COMPLETED_SKIP_TO_NEXT : &quot;29&quot;,
<span id='android-media-MediaPlayer2-property-CALL_COMPLETED_CLEAR_NEXT_DATA_SOURCES'>/**The player just completed a call {@link #clearNextDataSources}.
</span> @see EventCallback#onCallCompleted
*/
CALL_COMPLETED_CLEAR_NEXT_DATA_SOURCES : &quot;30&quot;,
<span id='android-media-MediaPlayer2-property-CALL_COMPLETED_SET_BUFFERING_PARAMS'>/**The player just completed a call {@link #setBufferingParams}.
</span> @see EventCallback#onCallCompleted
 @hide
*/
CALL_COMPLETED_SET_BUFFERING_PARAMS : &quot;31&quot;,
<span id='android-media-MediaPlayer2-property-CALL_COMPLETED_SET_DISPLAY'>/**The player just completed a call {@link #setDisplay}.
</span> @see EventCallback#onCallCompleted
*/
CALL_COMPLETED_SET_DISPLAY : &quot;33&quot;,
<span id='android-media-MediaPlayer2-property-CALL_COMPLETED_SET_WAKE_LOCK'>/**The player just completed a call {@link #setWakeLock}.
</span> @see EventCallback#onCallCompleted
*/
CALL_COMPLETED_SET_WAKE_LOCK : &quot;34&quot;,
<span id='android-media-MediaPlayer2-property-CALL_COMPLETED_SET_SCREEN_ON_WHILE_PLAYING'>/**The player just completed a call {@link #setScreenOnWhilePlaying}.
</span> @see EventCallback#onCallCompleted
*/
CALL_COMPLETED_SET_SCREEN_ON_WHILE_PLAYING : &quot;35&quot;,
<span id='android-media-MediaPlayer2-property-SEPARATE_CALL_COMPLETED_CALLBACK_START'>/** The start of the methods which have separate call complete callback.
</span> @hide
*/
SEPARATE_CALL_COMPLETED_CALLBACK_START : &quot;1000&quot;,
<span id='android-media-MediaPlayer2-property-CALL_COMPLETED_NOTIFY_WHEN_COMMAND_LABEL_REACHED'>/**The player just completed a call {@link #notifyWhenCommandLabelReached}.
</span> @see EventCallback#onCommandLabelReached
 @hide
*/
CALL_COMPLETED_NOTIFY_WHEN_COMMAND_LABEL_REACHED : &quot;1000&quot;,
<span id='android-media-MediaPlayer2-property-CALL_COMPLETED_PREPARE_DRM'>/**The player just completed a call {@link #prepareDrm}.
</span> @see DrmEventCallback#onDrmPrepared
 @hide
*/
CALL_COMPLETED_PREPARE_DRM : &quot;1001&quot;,
<span id='android-media-MediaPlayer2-property-CALL_STATUS_NO_ERROR'>/**Status code represents that call is completed without an error.
</span> @see EventCallback#onCallCompleted
*/
CALL_STATUS_NO_ERROR : &quot;0&quot;,
<span id='android-media-MediaPlayer2-property-CALL_STATUS_ERROR_UNKNOWN'>/**Status code represents that call is ended with an unknown error.
</span> @see EventCallback#onCallCompleted
*/
CALL_STATUS_ERROR_UNKNOWN : &quot;-2147483648&quot;,
<span id='android-media-MediaPlayer2-property-CALL_STATUS_INVALID_OPERATION'>/**Status code represents that the player is not in valid state for the operation.
</span> @see EventCallback#onCallCompleted
*/
CALL_STATUS_INVALID_OPERATION : &quot;1&quot;,
<span id='android-media-MediaPlayer2-property-CALL_STATUS_BAD_VALUE'>/**Status code represents that the argument is illegal.
</span> @see EventCallback#onCallCompleted
*/
CALL_STATUS_BAD_VALUE : &quot;2&quot;,
<span id='android-media-MediaPlayer2-property-CALL_STATUS_PERMISSION_DENIED'>/**Status code represents that the operation is not allowed.
</span> @see EventCallback#onCallCompleted
*/
CALL_STATUS_PERMISSION_DENIED : &quot;3&quot;,
<span id='android-media-MediaPlayer2-property-CALL_STATUS_ERROR_IO'>/**Status code represents a file or network related operation error.
</span> @see EventCallback#onCallCompleted
*/
CALL_STATUS_ERROR_IO : &quot;4&quot;,
<span id='android-media-MediaPlayer2-property-CALL_STATUS_SKIPPED'>/**Status code represents that the call has been skipped. For example, a {@link #seekTo}
</span> request may be skipped if it is followed by another {@link #seekTo} request.
 @see EventCallback#onCallCompleted
*/
CALL_STATUS_SKIPPED : &quot;5&quot;,
<span id='android-media-MediaPlayer2-property-CALL_STATUS_NO_DRM_SCHEME'>/**Status code represents that DRM operation is called before preparing a DRM scheme through
</span>  {@code prepareDrm}.
 @see EventCallback#onCallCompleted
*/
CALL_STATUS_NO_DRM_SCHEME : &quot;6&quot;,
<span id='android-media-MediaPlayer2-property-PREPARE_DRM_STATUS_SUCCESS'>/** A status code for {@link android.media.MediaDrm.DrmEventCallback#onDrmPrepared} listener.
</span> &lt;p&gt;

 DRM preparation has succeeded.
*/
PREPARE_DRM_STATUS_SUCCESS : &quot;0&quot;,
<span id='android-media-MediaPlayer2-property-PREPARE_DRM_STATUS_PROVISIONING_NETWORK_ERROR'>/** A status code for {@link android.media.MediaDrm.DrmEventCallback#onDrmPrepared} listener.
</span> &lt;p&gt;

 The device required DRM provisioning but couldn't reach the provisioning server.
*/
PREPARE_DRM_STATUS_PROVISIONING_NETWORK_ERROR : &quot;1&quot;,
<span id='android-media-MediaPlayer2-property-PREPARE_DRM_STATUS_PROVISIONING_SERVER_ERROR'>/** A status code for {@link android.media.MediaDrm.DrmEventCallback#onDrmPrepared} listener.
</span> &lt;p&gt;

 The device required DRM provisioning but the provisioning server denied the request.
*/
PREPARE_DRM_STATUS_PROVISIONING_SERVER_ERROR : &quot;2&quot;,
<span id='android-media-MediaPlayer2-property-PREPARE_DRM_STATUS_PREPARATION_ERROR'>/** A status code for {@link android.media.MediaDrm.DrmEventCallback#onDrmPrepared} listener.
</span> &lt;p&gt;

 The DRM preparation has failed .
*/
PREPARE_DRM_STATUS_PREPARATION_ERROR : &quot;3&quot;,
<span id='android-media-MediaPlayer2-property-PREPARE_DRM_STATUS_UNSUPPORTED_SCHEME'>/** A status code for {@link android.media.MediaDrm.DrmEventCallback#onDrmPrepared} listener.
</span> &lt;p&gt;

 The crypto scheme UUID is not supported by the device.
*/
PREPARE_DRM_STATUS_UNSUPPORTED_SCHEME : &quot;4&quot;,
<span id='android-media-MediaPlayer2-property-PREPARE_DRM_STATUS_RESOURCE_BUSY'>/** A status code for {@link android.media.MediaDrm.DrmEventCallback#onDrmPrepared} listener.
</span> &lt;p&gt;

 The hardware resources are not available, due to being in use.
*/
PREPARE_DRM_STATUS_RESOURCE_BUSY : &quot;5&quot;,
<span id='android-media-MediaPlayer2-property-PREPARE_DRM_STATUS_RESTORE_ERROR'>/** A status code for {@link android.media.MediaDrm.DrmEventCallback#onDrmPrepared} listener.
</span> &lt;p&gt;

 Restoring persisted offline keys failed.
*/
PREPARE_DRM_STATUS_RESTORE_ERROR : &quot;6&quot;,
<span id='android-media-MediaPlayer2-property-PREPARE_DRM_STATUS_KEY_EXCHANGE_ERROR'>/** A status code for {@link android.media.MediaDrm.DrmEventCallback#onDrmPrepared} listener.
</span> &lt;p&gt;

 Error during key request/response exchange with license server.
*/
PREPARE_DRM_STATUS_KEY_EXCHANGE_ERROR : &quot;7&quot;,
<span id='android-media-MediaPlayer2-method-close'>/**Releases the resources held by this {@code MediaPlayer2} object.
</span>
 It is considered good practice to call this method when you're
 done using the MediaPlayer2. In particular, whenever an Activity
 of an application is paused (its onPause() method is called),
 or stopped (its onStop() method is called), this method should be
 invoked to release the MediaPlayer2 object, unless the application
 has a special need to keep the object around. In addition to
 unnecessary resources (such as memory and instances of codecs)
 being held, failure to call this method immediately if a
 MediaPlayer2 object is no longer needed may also lead to
 continuous battery consumption for mobile devices, and playback
 failure for other applications if no multiple instances of the
 same codec are supported on a device. Even if multiple instances
 of the same codec are supported, some performance degradation
 may be expected when unnecessary multiple instances are used
 at the same time.

 {@code close()} may be safely called after a prior {@code close()}.
 This class implements the Java {@code AutoCloseable} interface and
 may be used with try-with-resources.
*/
close : function(  ) {},

<span id='android-media-MediaPlayer2-method-reset'>/**Resets the MediaPlayer2 to its uninitialized state. After calling
</span> this method, you will have to initialize it again by setting the
 data source and calling prepare().
*/
reset : function(  ) {},

<span id='android-media-MediaPlayer2-method-play'>/**Starts or resumes playback. If playback had previously been paused,
</span> playback will continue from where it was paused. If playback had
 reached end of stream and been paused, or never started before,
 playback will start at the beginning.
@return {Object {java.lang.Object}} a token which can be used to cancel the operation later with {@link #cancelCommand}.
*/
play : function(  ) {},

<span id='android-media-MediaPlayer2-method-prepare'>/**Prepares the player for playback, asynchronously.
</span>
 After setting the datasource and the display surface, you need to call prepare().
@return {Object {java.lang.Object}} a token which can be used to cancel the operation later with {@link #cancelCommand}.
*/
prepare : function(  ) {},

<span id='android-media-MediaPlayer2-method-pause'>/**Pauses playback. Call play() to resume.
</span>@return {Object {java.lang.Object}} a token which can be used to cancel the operation later with {@link #cancelCommand}.
*/
pause : function(  ) {},

<span id='android-media-MediaPlayer2-method-skipToNext'>/**Tries to play next data source if applicable.
</span>@return {Object {java.lang.Object}} a token which can be used to cancel the operation later with {@link #cancelCommand}.
*/
skipToNext : function(  ) {},

<span id='android-media-MediaPlayer2-method-getCurrentPosition'>/**Gets the current playback position.
</span>@return {Number} the current position in milliseconds
*/
getCurrentPosition : function(  ) {},

<span id='android-media-MediaPlayer2-method-getDuration'>/**Gets the duration of the current data source.
</span> Same as {@link #getDuration}(DataSourceDesc) with
 {@code dsd = getCurrentDataSource()}.
@return {Number} the duration in milliseconds, if no duration is available
         (for example, if streaming live content), -1 is returned.
@throws NullPointerException if current data source is null
*/
getDuration : function(  ) {},

<span id='android-media-MediaPlayer2-method-getDuration'>/**Gets the duration of the dsd.
</span>@param {Object {DataSourceDesc}} dsd the descriptor of data source of which you want to get duration
@return {Number} the duration in milliseconds, if no duration is available
         (for example, if streaming live content), -1 is returned.
@throws NullPointerException if dsd is null
*/
getDuration : function(  ) {},

<span id='android-media-MediaPlayer2-method-getBufferedPosition'>/**Gets the buffered media source position of current data source.
</span> Same as {@link #getBufferedPosition}(DataSourceDesc) with
 {@code dsd = getCurrentDataSource()}.
@return {Number} the current buffered media source position in milliseconds
@throws NullPointerException if current data source is null
*/
getBufferedPosition : function(  ) {},

<span id='android-media-MediaPlayer2-method-getBufferedPosition'>/**Gets the buffered media source position of given dsd.
</span> For example a buffering update of 8000 milliseconds when 5000 milliseconds of the content
 has already been played indicates that the next 3000 milliseconds of the
 content to play has been buffered.
@param {Object {DataSourceDesc}} dsd the descriptor of data source of which you want to get buffered position
@return {Number} the current buffered media source position in milliseconds
@throws NullPointerException if dsd is null
*/
getBufferedPosition : function(  ) {},

<span id='android-media-MediaPlayer2-method-getState'>/**Gets the current player state.
</span>@return {Number} the current player state.
*/
getState : function(  ) {},

<span id='android-media-MediaPlayer2-method-setAudioAttributes'>/**Sets the audio attributes for this MediaPlayer2.
</span> See {@link android.media.AudioAttributes} for how to build and configure an instance of this class.
 You must call this method before {@link #play}() and {@link #pause}() in order
 for the audio attributes to become effective thereafter.
@param {Object {AudioAttributes}} attributes a non-null set of audio attributes
@return {Object {java.lang.Object}} a token which can be used to cancel the operation later with {@link #cancelCommand}.
*/
setAudioAttributes : function(  ) {},

<span id='android-media-MediaPlayer2-method-getAudioAttributes'>/**Gets the audio attributes for this MediaPlayer2.
</span>@return {Object {android.media.AudioAttributes}} attributes a set of audio attributes
*/
getAudioAttributes : function(  ) {},

<span id='android-media-MediaPlayer2-method-setDataSource'>/**Sets the data source as described by a DataSourceDesc.
</span> When the data source is of {@link android.media.FileDataSourceDesc} type, the {@link ParcelFileDescriptor}
 in the {@link android.media.FileDataSourceDesc} will be closed by the player.
@param {Object {DataSourceDesc}} dsd the descriptor of data source you want to play
@return {Object {java.lang.Object}} a token which can be used to cancel the operation later with {@link #cancelCommand}.
*/
setDataSource : function(  ) {},

<span id='android-media-MediaPlayer2-method-setNextDataSource'>/**Sets a single data source as described by a DataSourceDesc which will be played
</span> after current data source is finished.
 When the data source is of {@link android.media.FileDataSourceDesc} type, the {@link ParcelFileDescriptor}
 in the {@link android.media.FileDataSourceDesc} will be closed by the player.
@param {Object {DataSourceDesc}} dsd the descriptor of data source you want to play after current one
@return {Object {java.lang.Object}} a token which can be used to cancel the operation later with {@link #cancelCommand}.
*/
setNextDataSource : function(  ) {},

<span id='android-media-MediaPlayer2-method-setNextDataSources'>/**Sets a list of data sources to be played sequentially after current data source is done.
</span> When the data source is of {@link android.media.FileDataSourceDesc} type, the {@link ParcelFileDescriptor}
 in the {@link android.media.FileDataSourceDesc} will be closed by the player.
@param {Object {java.util.List}} dsds the list of data sources you want to play after current one
@return {Object {java.lang.Object}} a token which can be used to cancel the operation later with {@link #cancelCommand}.
*/
setNextDataSources : function(  ) {},

<span id='android-media-MediaPlayer2-method-clearNextDataSources'>/**Removes all data sources pending to be played.
</span>@return {Object {java.lang.Object}} a token which can be used to cancel the operation later with {@link #cancelCommand}.
*/
clearNextDataSources : function(  ) {},

<span id='android-media-MediaPlayer2-method-getCurrentDataSource'>/**Gets the current data source as described by a DataSourceDesc.
</span>@return {Object {android.media.DataSourceDesc}} the current DataSourceDesc
*/
getCurrentDataSource : function(  ) {},

<span id='android-media-MediaPlayer2-method-loopCurrent'>/**Configures the player to loop on the current data source.
</span>@param {Boolean} loop true if the current data source is meant to loop.
@return {Object {java.lang.Object}} a token which can be used to cancel the operation later with {@link #cancelCommand}.
*/
loopCurrent : function(  ) {},

<span id='android-media-MediaPlayer2-method-setPlayerVolume'>/**Sets the volume of the audio of the media to play, expressed as a linear multiplier
</span> on the audio samples.
 Note that this volume is specific to the player, and is separate from stream volume
 used across the platform.&lt;br&gt;
 A value of 0.0f indicates muting, a value of 1.0f is the nominal unattenuated and unamplified
 gain. See {@link #getMaxPlayerVolume}() for the volume range supported by this player.
@param {Number} volume a value between 0.0f and {@link #getMaxPlayerVolume()}.
@return {Object {java.lang.Object}} a token which can be used to cancel the operation later with {@link #cancelCommand}.
*/
setPlayerVolume : function(  ) {},

<span id='android-media-MediaPlayer2-method-getPlayerVolume'>/**Returns the current volume of this player.
</span> Note that it does not take into account the associated stream volume.
@return {Number} the player volume.
*/
getPlayerVolume : function(  ) {},

<span id='android-media-MediaPlayer2-method-getMaxPlayerVolume'>/**
</span>@return {Number} the maximum volume that can be used in {@link #setPlayerVolume(float)}.
*/
getMaxPlayerVolume : function(  ) {},

<span id='android-media-MediaPlayer2-method-notifyWhenCommandLabelReached'>/**Insert a task in the command queue to help the client to identify whether a batch
</span> of commands has been finished. When this command is processed, a notification
 {@link android.media.MediaPlayer2.EventCallback#onCommandLabelReached onCommandLabelReached} will be fired with the
 given {@code label}.
@param {Object {Object}} label An application specific Object used to help to identify the completeness
 of a batch of commands.
@param label An application specific Object used to help to identify the completeness
 of a batch of commands.
@return {Object {java.lang.Object}} a token which can be used to cancel the operation later with {@link #cancelCommand}.
*/
notifyWhenCommandLabelReached : function(  ) {},

<span id='android-media-MediaPlayer2-method-setDisplay'>/**Sets the {@link SurfaceHolder} to use for displaying the video
</span> portion of the media.

 Either a surface holder or surface must be set if a display or video sink
 is needed. Not calling this method or {@link #setSurface}(Surface)
 when playing back a video will result in only the audio track being played.
 A null surface holder or surface will result in only the audio track being
 played.
@param {Object {SurfaceHolder}} sh the SurfaceHolder to use for video display
@return {Object {java.lang.Object}} a token which can be used to cancel the operation later with {@link #cancelCommand}.
*/
setDisplay : function(  ) {},

<span id='android-media-MediaPlayer2-method-setSurface'>/**Sets the {@link Surface} to be used as the sink for the video portion of
</span> the media.  Setting a
 Surface will un-set any Surface or SurfaceHolder that was previously set.
 A null surface will result in only the audio track being played.

 If the Surface sends frames to a {@link SurfaceTexture}, the timestamps
 returned from {@link SurfaceTexture#getTimestamp()} will have an
 unspecified zero point.  These timestamps cannot be directly compared
 between different media sources, different instances of the same media
 source, or multiple runs of the same program.  The timestamp is normally
 monotonically increasing and is unaffected by time-of-day adjustments,
 but it is reset when the position is set.
@param {Object {Surface}} surface The {@link Surface} to be used for the video portion of
 the media.
@return {Object {java.lang.Object}} a token which can be used to cancel the operation later with {@link #cancelCommand}.
*/
setSurface : function(  ) {},

<span id='android-media-MediaPlayer2-method-setWakeLock'>/**Set the low-level power management behavior for this MediaPlayer2. This
</span> can be used when the MediaPlayer2 is not playing through a SurfaceHolder
 set with {@link #setDisplay}(SurfaceHolder) and thus can use the
 high-level {@link #setScreenOnWhilePlaying}(boolean) feature.

 &lt;p&gt;This function has the MediaPlayer2 access the low-level power manager
 service to control the device's power usage while playing is occurring.
 The parameter is a {@link android.os.PowerManager.WakeLock}.
 Use of this method requires {@link android.Manifest.permission#WAKE_LOCK}
 permission.
 By default, no attempt is made to keep the device awake during playback.
@param {Object {PowerManager.WakeLock}} wakeLock the power wake lock used during playback.
@return {Object {java.lang.Object}} a token which can be used to cancel the operation later with {@link #cancelCommand}.
@see android.os.PowerManager
*/
setWakeLock : function(  ) {},

<span id='android-media-MediaPlayer2-method-setScreenOnWhilePlaying'>/**Control whether we should use the attached SurfaceHolder to keep the
</span> screen on while video playback is occurring.  This is the preferred
 method over {@link #setWakeLock} where possible, since it doesn't
 require that the application have permission for low-level wake lock
 access.
@param {Boolean} screenOn Supply true to keep the screen on, false to allow it to turn off.
@return {Object {java.lang.Object}} a token which can be used to cancel the operation later with {@link #cancelCommand}.
*/
setScreenOnWhilePlaying : function(  ) {},

<span id='android-media-MediaPlayer2-method-cancelCommand'>/**Cancels a pending command.
</span>@param {Object {Object}} token the command to be canceled. This is the returned Object when command is issued.
@return {Boolean} {@code false} if the task could not be cancelled; {@code true} otherwise.
@throws IllegalArgumentException if argument token is null.
*/
cancelCommand : function(  ) {},

<span id='android-media-MediaPlayer2-method-clearPendingCommands'>/**Discards all pending commands.
</span>*/
clearPendingCommands : function(  ) {},

<span id='android-media-MediaPlayer2-method-setPreferredDevice'>/**Specifies an audio device (via an {@link android.media.AudioDeviceInfo} object) to route
</span> the output from this MediaPlayer2.
@param {Object {AudioDeviceInfo}} deviceInfo The {@link AudioDeviceInfo} specifying the audio sink or source.
  If deviceInfo is null, default routing is restored.
@return {Boolean} true if succesful, false if the specified {@link AudioDeviceInfo} is non-null and
 does not correspond to a valid audio device.
*/
setPreferredDevice : function(  ) {},

<span id='android-media-MediaPlayer2-method-getPreferredDevice'>/**Returns the selected output specified by {@link #setPreferredDevice}. Note that this
</span> is not guaranteed to correspond to the actual device being used for playback.
*/
getPreferredDevice : function(  ) {},

<span id='android-media-MediaPlayer2-method-getRoutedDevice'>/**Returns an {@link android.media.AudioDeviceInfo} identifying the current routing of this MediaPlayer2
</span> Note: The query is only valid if the MediaPlayer2 is currently playing.
 If the player is not playing, the returned device can be null or correspond to previously
 selected device when the player was last active.
*/
getRoutedDevice : function(  ) {},

<span id='android-media-MediaPlayer2-method-addOnRoutingChangedListener'>/**Adds an {@link android.media.AudioRouting.OnRoutingChangedListener} to receive notifications of routing
</span> changes on this MediaPlayer2.
@param {Object {AudioRouting.OnRoutingChangedListener}} listener The {@link AudioRouting.OnRoutingChangedListener} interface to receive
 notifications of rerouting events.
@param {Object {Handler}} handler  Specifies the {@link Handler} object for the thread on which to execute
 the callback. If &lt;code&gt;null&lt;/code&gt;, the handler on the main looper will be used.
*/
addOnRoutingChangedListener : function(  ) {},

<span id='android-media-MediaPlayer2-method-removeOnRoutingChangedListener'>/**Removes an {@link android.media.AudioRouting.OnRoutingChangedListener} which has been previously added
</span> to receive rerouting notifications.
@param {Object {AudioRouting.OnRoutingChangedListener}} listener The previously added {@link AudioRouting.OnRoutingChangedListener} interface
 to remove.
*/
removeOnRoutingChangedListener : function(  ) {},

<span id='android-media-MediaPlayer2-method-getVideoSize'>/**Returns the size of the video.
</span>@return {Object {android.util.Size}} the size of the video. The width and height of size could be 0 if there is no video,
 or the size has not been determined yet.
 The {@code EventCallback} can be registered via
 {@link #registerEventCallback(Executor, EventCallback)} to provide a
 notification {@code EventCallback.onVideoSizeChanged} when the size
 is available.
*/
getVideoSize : function(  ) {},

<span id='android-media-MediaPlayer2-method-getMetrics'>/**Return Metrics data about the current player.
</span>@return {Object {android.os.PersistableBundle}} a {@link PersistableBundle} containing the set of attributes and values
 available for the media being handled by this instance of MediaPlayer2
 The attributes are descibed in {@link MetricsConstants}.

 Additional vendor-specific fields may also be present in the return value.
*/
getMetrics : function(  ) {},

<span id='android-media-MediaPlayer2-method-setPlaybackParams'>/**Sets playback rate using {@link android.media.PlaybackParams}. The object sets its internal
</span> PlaybackParams to the input. This allows the object to resume at previous speed
 when play() is called. Speed of zero is not allowed. Calling it does not change
 the object state.
@param {Object {PlaybackParams}} params the playback params.
@return {Object {java.lang.Object}} a token which can be used to cancel the operation later with {@link #cancelCommand}.
*/
setPlaybackParams : function(  ) {},

<span id='android-media-MediaPlayer2-method-getPlaybackParams'>/**Gets the playback params, containing the current playback rate.
</span>@return {Object {android.media.PlaybackParams}} the playback params.
@throws IllegalStateException if the internal player engine has not been initialized.
*/
getPlaybackParams : function(  ) {},

<span id='android-media-MediaPlayer2-method-setSyncParams'>/**Sets A/V sync mode.
</span>@param {Object {SyncParams}} params the A/V sync params to apply
@return {Object {java.lang.Object}} a token which can be used to cancel the operation later with {@link #cancelCommand}.
*/
setSyncParams : function(  ) {},

<span id='android-media-MediaPlayer2-method-getSyncParams'>/**Gets the A/V sync mode.
</span>@return {Object {android.media.SyncParams}} the A/V sync params
@throws IllegalStateException if the internal player engine has not been initialized.
*/
getSyncParams : function(  ) {},

<span id='android-media-MediaPlayer2-method-seekTo'>/**Moves the media to specified time position.
</span> Same as {@link #seekTo(long, int)} with {@code mode = SEEK_PREVIOUS_SYNC}.
@param {Number} msec the offset in milliseconds from the start to seek to
@return {Object {java.lang.Object}} a token which can be used to cancel the operation later with {@link #cancelCommand}.
*/
seekTo : function(  ) {},

<span id='android-media-MediaPlayer2-method-seekTo'>/**Moves the media to specified time position by considering the given mode.
</span> &lt;p&gt;
 When seekTo is finished, the user will be notified via
 {@link android.media.MediaPlayer2.EventCallback#onCallCompleted} with {@link #CALL_COMPLETED_SEEK_TO}.
 There is at most one active seekTo processed at any time. If there is a to-be-completed
 seekTo, new seekTo requests will be queued in such a way that only the last request
 is kept. When current seekTo is completed, the queued request will be processed if
 that request is different from just-finished seekTo operation, i.e., the requested
 position or mode is different.
@param {Number} msec the offset in milliseconds from the start to seek to.
 When seeking to the given time position, there is no guarantee that the data source
 has a frame located at the position. When this happens, a frame nearby will be rendered.
 If msec is negative, time position zero will be used.
 If msec is larger than duration, duration will be used.
@param {Number} mode the mode indicating where exactly to seek to.
@return {Object {java.lang.Object}} a token which can be used to cancel the operation later with {@link #cancelCommand}.
*/
seekTo : function(  ) {},

<span id='android-media-MediaPlayer2-method-getTimestamp'>/**Get current playback position as a {@link android.media.MediaTimestamp}.
</span> &lt;p&gt;
 The MediaTimestamp represents how the media time correlates to the system time in
 a linear fashion using an anchor and a clock rate. During regular playback, the media
 time moves fairly constantly (though the anchor frame may be rebased to a current
 system time, the linear correlation stays steady). Therefore, this method does not
 need to be called often.
 &lt;p&gt;
 To help users get current playback position, this method always anchors the timestamp
 to the current {@link System#nanoTime system time}, so
 {@link android.media.MediaTimestamp#getAnchorMediaTimeUs} can be used as current playback position.
@return {Object {android.media.MediaTimestamp}} a MediaTimestamp object if a timestamp is available, or {@code null} if no timestamp
         is available, e.g. because the media player has not been initialized.
@see MediaTimestamp
*/
getTimestamp : function(  ) {},

<span id='android-media-MediaPlayer2-method-isLooping'>/**Checks whether the MediaPlayer2 is looping or non-looping.
</span>@return {Boolean} true if the MediaPlayer2 is currently looping, false otherwise
*/
isLooping : function(  ) {},

<span id='android-media-MediaPlayer2-method-setAudioSessionId'>/**Sets the audio session ID.
</span>@param {Number} sessionId the audio session ID.
 The audio session ID is a system wide unique identifier for the audio stream played by
 this MediaPlayer2 instance.
 The primary use of the audio session ID  is to associate audio effects to a particular
 instance of MediaPlayer2: if an audio session ID is provided when creating an audio effect,
 this effect will be applied only to the audio content of media players within the same
 audio session and not to the output mix.
 When created, a MediaPlayer2 instance automatically generates its own audio session ID.
 However, it is possible to force this player to be part of an already existing audio session
 by calling this method.
 This method must be called when player is in {@link #PLAYER_STATE_IDLE} or
 {@link #PLAYER_STATE_PREPARED} state in order to have sessionId take effect.
@return {Object {java.lang.Object}} a token which can be used to cancel the operation later with {@link #cancelCommand}.
*/
setAudioSessionId : function(  ) {},

<span id='android-media-MediaPlayer2-method-getAudioSessionId'>/**Returns the audio session ID.
</span>@return {Number} the audio session ID. {@see #setAudioSessionId(int)}
 Note that the audio session ID is 0 only if a problem occured when the MediaPlayer2 was
 contructed.
*/
getAudioSessionId : function(  ) {},

<span id='android-media-MediaPlayer2-method-attachAuxEffect'>/**Attaches an auxiliary effect to the player. A typical auxiliary effect is a reverberation
</span> effect which can be applied on any sound source that directs a certain amount of its
 energy to this effect. This amount is defined by setAuxEffectSendLevel().
 See {@link #setAuxEffectSendLevel}(float).
 &lt;p&gt;After creating an auxiliary effect (e.g.
 {@link android.media.audiofx.EnvironmentalReverb}), retrieve its ID with
 {@link android.media.audiofx.AudioEffect#getId()} and use it when calling this method
 to attach the player to the effect.
 &lt;p&gt;To detach the effect from the player, call this method with a null effect id.
 &lt;p&gt;This method must be called after one of the overloaded &lt;code&gt; setDataSource &lt;/code&gt;
 methods.
@param {Number} effectId system wide unique id of the effect to attach
@return {Object {java.lang.Object}} a token which can be used to cancel the operation later with {@link #cancelCommand}.
*/
attachAuxEffect : function(  ) {},

<span id='android-media-MediaPlayer2-method-setAuxEffectSendLevel'>/**Sets the send level of the player to the attached auxiliary effect.
</span> See {@link #attachAuxEffect}(int). The level value range is 0 to 1.0.
 &lt;p&gt;By default the send level is 0, so even if an effect is attached to the player
 this method must be called for the effect to be applied.
 &lt;p&gt;Note that the passed level value is a raw scalar. UI controls should be scaled
 logarithmically: the gain applied by audio framework ranges from -72dB to 0dB,
 so an appropriate conversion from linear UI input x to level is:
 x == 0 -&gt; level = 0
 0 &lt; x &lt;= R -&gt; level = 10^(72*(x-R)/20/R)
@param {Number} level send level scalar
@return {Object {java.lang.Object}} a token which can be used to cancel the operation later with {@link #cancelCommand}.
*/
setAuxEffectSendLevel : function(  ) {},

<span id='android-media-MediaPlayer2-method-getTrackInfo'>/**Returns a List of track information of current data source.
</span> Same as {@link #getTrackInfo}(DataSourceDesc) with
 {@code dsd = getCurrentDataSource()}.
@return {Object {java.util.List}} List of track info. The total number of tracks is the array length.
 Must be called again if an external timed text source has been added after
 addTimedTextSource method is called.
@throws IllegalStateException if it is called in an invalid state.
@throws NullPointerException if current data source is null
*/
getTrackInfo : function(  ) {},

<span id='android-media-MediaPlayer2-method-getTrackInfo'>/**Returns a List of track information.
</span>@param {Object {DataSourceDesc}} dsd the descriptor of data source of which you want to get track info
@return {Object {java.util.List}} List of track info. The total number of tracks is the array length.
 Must be called again if an external timed text source has been added after
 addTimedTextSource method is called.
@throws IllegalStateException if it is called in an invalid state.
@throws NullPointerException if dsd is null
*/
getTrackInfo : function(  ) {},

<span id='android-media-MediaPlayer2-method-getSelectedTrack'>/**Returns the index of the audio, video, or subtitle track currently selected for playback.
</span> The return value is an index into the array returned by {@link #getTrackInfo}, and can
 be used in calls to {@link #selectTrack}(TrackInfo) or {@link #deselectTrack}(TrackInfo).
 Same as {@link #getSelectedTrack(DataSourceDesc, int)} with
 {@code dsd = getCurrentDataSource()}.
@param {Number} trackType should be one of {@link TrackInfo#MEDIA_TRACK_TYPE_VIDEO},
 {@link TrackInfo#MEDIA_TRACK_TYPE_AUDIO}, or
 {@link TrackInfo#MEDIA_TRACK_TYPE_SUBTITLE}
@return {Object {android.media.MediaPlayer2.TrackInfo}} metadata corresponding to the audio, video, or subtitle track currently selected for
 playback; {@code null} is returned when there is no selected track for {@code trackType} or
 when {@code trackType} is not one of audio, video, or subtitle.
@throws IllegalStateException if called after {@link #close()}
@throws NullPointerException if current data source is null
@see #getTrackInfo()
@see #selectTrack(TrackInfo)
@see #deselectTrack(TrackInfo)
*/
getSelectedTrack : function(  ) {},

<span id='android-media-MediaPlayer2-method-getSelectedTrack'>/**Returns the index of the audio, video, or subtitle track currently selected for playback.
</span> The return value is an index into the array returned by {@link #getTrackInfo}, and can
 be used in calls to {@link #selectTrack(DataSourceDesc, android.media.MediaPlayer.TrackInfo)} or
 {@link #deselectTrack(DataSourceDesc, android.media.MediaPlayer.TrackInfo)}.
@param {Object {DataSourceDesc}} dsd the descriptor of data source of which you want to get selected track
@param {Number} trackType should be one of {@link TrackInfo#MEDIA_TRACK_TYPE_VIDEO},
 {@link TrackInfo#MEDIA_TRACK_TYPE_AUDIO}, or
 {@link TrackInfo#MEDIA_TRACK_TYPE_SUBTITLE}
@return {Object {android.media.MediaPlayer2.TrackInfo}} metadata corresponding to the audio, video, or subtitle track currently selected for
 playback; {@code null} is returned when there is no selected track for {@code trackType} or
 when {@code trackType} is not one of audio, video, or subtitle.
@throws IllegalStateException if called after {@link #close()}
@throws NullPointerException if dsd is null
@see #getTrackInfo(DataSourceDesc)
@see #selectTrack(DataSourceDesc, TrackInfo)
@see #deselectTrack(DataSourceDesc, TrackInfo)
*/
getSelectedTrack : function(  ) {},

<span id='android-media-MediaPlayer2-method-selectTrack'>/**Selects a track of current data source.
</span> Same as {@link #selectTrack(DataSourceDesc, android.media.MediaPlayer.TrackInfo)} with
 {@code dsd = getCurrentDataSource()}.
@param {Object {MediaPlayer2.TrackInfo}} trackInfo metadata corresponding to the track to be selected. A {@code trackInfo}
 object can be obtained from {@link #getTrackInfo()}.
@return {Object {java.lang.Object}} a token which can be used to cancel the operation later with {@link #cancelCommand}.

 This is an asynchronous call.
@see MediaPlayer2#getTrackInfo()
*/
selectTrack : function(  ) {},

<span id='android-media-MediaPlayer2-method-selectTrack'>/**Selects a track.
</span> &lt;p&gt;
 If a MediaPlayer2 is in invalid state, it throws an IllegalStateException exception.
 If a MediaPlayer2 is in &lt;em&gt;Started&lt;/em&gt; state, the selected track is presented immediately.
 If a MediaPlayer2 is not in Started state, it just marks the track to be played.
 &lt;/p&gt;
 &lt;p&gt;
 In any valid state, if it is called multiple times on the same type of track (ie. Video,
 Audio, Timed Text), the most recent one will be chosen.
 &lt;/p&gt;
 &lt;p&gt;
 The first audio and video tracks are selected by default if available, even though
 this method is not called. However, no timed text track will be selected until
 this function is called.
 &lt;/p&gt;
 &lt;p&gt;
 Currently, only timed text tracks or audio tracks can be selected via this method.
 In addition, the support for selecting an audio track at runtime is pretty limited
 in that an audio track can only be selected in the &lt;em&gt;Prepared&lt;/em&gt; state.
 &lt;/p&gt;
@param {Object {DataSourceDesc}} dsd the descriptor of data source of which you want to select track
@param {Object {MediaPlayer2.TrackInfo}} trackInfo metadata corresponding to the track to be selected. A {@code trackInfo}
 object can be obtained from {@link #getTrackInfo()}.
@return {Object {java.lang.Object}} a token which can be used to cancel the operation later with {@link #cancelCommand}.

 This is an asynchronous call.
@see MediaPlayer2#getTrackInfo(DataSourceDesc)
*/
selectTrack : function(  ) {},

<span id='android-media-MediaPlayer2-method-deselectTrack'>/**Deselect a track of current data source.
</span> Same as {@link #deselectTrack(DataSourceDesc, android.media.MediaPlayer.TrackInfo)} with
 {@code dsd = getCurrentDataSource()}.
@param {Object {MediaPlayer2.TrackInfo}} trackInfo metadata corresponding to the track to be selected. A {@code trackInfo}
 object can be obtained from {@link #getTrackInfo()}.
@return {Object {java.lang.Object}} a token which can be used to cancel the operation later with {@link #cancelCommand}.

 This is an asynchronous call.
@see MediaPlayer2#getTrackInfo()
*/
deselectTrack : function(  ) {},

<span id='android-media-MediaPlayer2-method-deselectTrack'>/**Deselect a track.
</span> &lt;p&gt;
 Currently, the track must be a timed text track and no audio or video tracks can be
 deselected. If the timed text track identified by index has not been
 selected before, it throws an exception.
 &lt;/p&gt;
@param {Object {DataSourceDesc}} dsd the descriptor of data source of which you want to deselect track
@param {Object {MediaPlayer2.TrackInfo}} trackInfo metadata corresponding to the track to be selected. A {@code trackInfo}
 object can be obtained from {@link #getTrackInfo()}.
@return {Object {java.lang.Object}} a token which can be used to cancel the operation later with {@link #cancelCommand}.

 This is an asynchronous call.
@see MediaPlayer2#getTrackInfo(DataSourceDesc)
*/
deselectTrack : function(  ) {},

<span id='android-media-MediaPlayer2-method-registerEventCallback'>/**Registers the callback to be invoked for various events covered by {@link android.media.MediaPlayer2.EventCallback}.
</span>@param {Object {Executor}} executor the executor through which the callback should be invoked
@param {Object {MediaPlayer2.EventCallback}} eventCallback the callback that will be run
*/
registerEventCallback : function(  ) {},

<span id='android-media-MediaPlayer2-method-unregisterEventCallback'>/**Unregisters the {@link android.media.MediaPlayer2.EventCallback}.
</span>@param {Object {MediaPlayer2.EventCallback}} eventCallback the callback to be unregistered
*/
unregisterEventCallback : function(  ) {},

<span id='android-media-MediaPlayer2-method-setDrmEventCallback'>/**Registers the callback to be invoked for various DRM events.
</span>
 This is a synchronous call.
@param {Object {Executor}} eventCallback the callback that will be run
@param {Object {MediaPlayer2.DrmEventCallback}} executor the executor through which the callback should be invoked
*/
setDrmEventCallback : function(  ) {},

<span id='android-media-MediaPlayer2-method-clearDrmEventCallback'>/**Clear the {@link android.media.MediaDrm.DrmEventCallback}.
</span>
 This is a synchronous call.
*/
clearDrmEventCallback : function(  ) {},

<span id='android-media-MediaPlayer2-method-getDrmInfo'>/**Retrieves the DRM Info associated with the given source
</span>@param {Object {DataSourceDesc}} dsd The DRM protected data source
@throws IllegalStateException if called before being prepared
@hide 
*/
getDrmInfo : function(  ) {},

<span id='android-media-MediaPlayer2-method-prepareDrm'>/**Prepares the DRM for the given data source
</span> &lt;p&gt;
 If {@link android.media.MediaDrm.DrmEventCallback} is registered, it will be called during
 preparation to allow configuration of the DRM properties before opening the
 DRM session. It should be used only for a series of
 {@link #getDrmPropertyString(DataSourceDesc, String)} and
 {@link #setDrmPropertyString(DataSourceDesc, String, String)} calls
 and refrain from any lengthy operation.
 &lt;p&gt;
 If the device has not been provisioned before, this call also provisions the device
 which involves accessing the provisioning server and can take a variable time to
 complete depending on the network connectivity.
 When needed, the provisioning will be launched  in the background.
 The listener {@link android.media.MediaDrm.DrmEventCallback#onDrmPrepared}
 will be called when provisioning and preparation are finished. The application should
 check the status code returned with {@link android.media.MediaDrm.DrmEventCallback#onDrmPrepared} to proceed.
 &lt;p&gt;
 The registered {@link android.media.MediaDrm.DrmEventCallback#onDrmPrepared} is called to indicate the DRM
 session being ready. The application should not make any assumption about its call
 sequence (e.g., before or after prepareDrm returns).
 &lt;p&gt;
@param {Object {DataSourceDesc}} dsd The DRM protected data source
@param {Object {UUID}} uuid The UUID of the crypto scheme. If not known beforehand, it can be retrieved
 from the source listening to {@link DrmEventCallback#onDrmInfo}.
@return {Object {java.lang.Object}} a token which can be used to cancel the operation later with {@link #cancelCommand}.
@hide 
*/
prepareDrm : function(  ) {},

<span id='android-media-MediaPlayer2-method-releaseDrm'>/**Releases the DRM session for the given data source
</span> &lt;p&gt;
 The player has to have an active DRM session and be in stopped, or prepared
 state before this call is made.
 A {@link #reset}() call will release the DRM session implicitly.
@param {Object {DataSourceDesc}} dsd The DRM protected data source
@throws NoDrmSchemeException if there is no active DRM session to release
@hide 
*/
releaseDrm : function(  ) {},

<span id='android-media-MediaPlayer2-method-getDrmKeyRequest'>/**A key request/response exchange occurs between the app and a license server
</span> to obtain or release keys used to decrypt the given data source.
 &lt;p&gt;
 {@code getDrmKeyRequest()} is used to obtain an opaque key request byte array that is
 delivered to the license server.  The opaque key request byte array is returned
 in KeyRequest.data.  The recommended URL to deliver the key request to is
 returned in {@code KeyRequest.defaultUrl}.
 &lt;p&gt;
 After the app has received the key request response from the server,
 it should deliver to the response to the DRM engine plugin using the method
 {@link #provideDrmKeyResponse(DataSourceDesc, byte[], byte[])}.
@param {Object {DataSourceDesc}} dsd the DRM protected data source
@param {Object {byte[]}} keySetId is the key-set identifier of the offline keys being released when keyType is
 {@link MediaDrm#KEY_TYPE_RELEASE}. It should be set to null for other key requests, when
 keyType is {@link MediaDrm#KEY_TYPE_STREAMING} or {@link MediaDrm#KEY_TYPE_OFFLINE}.
@param {Object {byte[]}} initData is the container-specific initialization data when the keyType is
 {@link MediaDrm#KEY_TYPE_STREAMING} or {@link MediaDrm#KEY_TYPE_OFFLINE}. Its meaning is
 interpreted based on the mime type provided in the mimeType parameter.  It could
 contain, for example, the content ID, key ID or other data obtained from the content
 metadata that is required in generating the key request.
 When the keyType is {@link MediaDrm#KEY_TYPE_RELEASE}, it should be set to null.
@param {String} mimeType identifies the mime type of the content
@param {Number} keyType specifies the type of the request. The request may be to acquire
 keys for streaming, {@link MediaDrm#KEY_TYPE_STREAMING}, or for offline content
 {@link MediaDrm#KEY_TYPE_OFFLINE}, or to release previously acquired
 keys ({@link MediaDrm#KEY_TYPE_RELEASE}), which are identified by a keySetId.
@param {Object {java.util.Map}} optionalParameters are included in the key request message to
 allow a client application to provide additional message parameters to the server.
 This may be {@code null} if no additional parameters are to be sent.
@throws NoDrmSchemeException if there is no active DRM session
@hide 
*/
getDrmKeyRequest : function(  ) {},

<span id='android-media-MediaPlayer2-method-provideDrmKeyResponse'>/**A key response is received from the license server by the app for the given DRM protected
</span> data source, then provided to the DRM engine plugin using {@code provideDrmKeyResponse}.
 &lt;p&gt;
 When the response is for an offline key request, a key-set identifier is returned that
 can be used to later restore the keys to a new session with the method
 {@link #restoreDrmKeys(DataSourceDesc, byte[])}.
 When the response is for a streaming or release request, null is returned.
@param {Object {DataSourceDesc}} dsd the DRM protected data source
@param {Object {byte[]}} keySetId When the response is for a release request, keySetId identifies the saved
 key associated with the release request (i.e., the same keySetId passed to the earlier
 {@link # getDrmKeyRequest(DataSourceDesc, byte[], byte[], String, int, Map)} call).
 It MUST be null when the response is for either streaming or offline key requests.
@param {Object {byte[]}} response the byte array response from the server
@throws NoDrmSchemeException if there is no active DRM session
@throws DeniedByServerException if the response indicates that the
 server rejected the request
@hide 
*/
provideDrmKeyResponse : function(  ) {},

<span id='android-media-MediaPlayer2-method-restoreDrmKeys'>/**Restore persisted offline keys into a new session for the given DRM protected data source.
</span> {@code keySetId} identifies the keys to load, obtained from a prior call to
 {@link #provideDrmKeyResponse(DataSourceDesc, byte[], byte[])}.
@param {Object {DataSourceDesc}} dsd the DRM protected data source
@param {Object {byte[]}} keySetId identifies the saved key set to restore
@throws NoDrmSchemeException if there is no active DRM session
@hide 
*/
restoreDrmKeys : function(  ) {},

<span id='android-media-MediaPlayer2-method-getDrmPropertyString'>/**Read a DRM engine plugin String property value, given the DRM protected data source
</span> and property name string.
@param {Object {DataSourceDesc}} dsd the DRM protected data source
@param {String} propertyName the property name

 Standard fields names are:
 {@link MediaDrm#PROPERTY_VENDOR}, {@link MediaDrm#PROPERTY_VERSION},
 {@link MediaDrm#PROPERTY_DESCRIPTION}, {@link MediaDrm#PROPERTY_ALGORITHMS}
@throws NoDrmSchemeException if there is no active DRM session
@hide 
*/
getDrmPropertyString : function(  ) {},

<span id='android-media-MediaPlayer2-method-setDrmPropertyString'>/**Set a DRM engine plugin String property value for the given data source.
</span>@param {Object {DataSourceDesc}} dsd the DRM protected data source
@param {String} propertyName the property name
@param {String} value the property value

 Standard fields names are:
 {@link MediaDrm#PROPERTY_VENDOR}, {@link MediaDrm#PROPERTY_VERSION},
 {@link MediaDrm#PROPERTY_DESCRIPTION}, {@link MediaDrm#PROPERTY_ALGORITHMS}
@throws NoDrmSchemeException if there is no active DRM session
@hide 
*/
setDrmPropertyString : function(  ) {},


};</pre>
</body>
</html>
