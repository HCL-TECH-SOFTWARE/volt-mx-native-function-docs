<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='java-time-chrono-ChronoPeriod'>/**@class java.time.chrono.ChronoPeriod
</span> implements java.time.temporal.TemporalAmount

 A date-based amount of time, such as '3 years, 4 months and 5 days' in an
 arbitrary chronology, intended for advanced globalization use cases.
 &lt;p&gt;
 This interface models a date-based amount of time in a calendar system.
 While most calendar systems use years, months and days, some do not.
 Therefore, this interface operates solely in terms of a set of supported
 units that are defined by the {@code Chronology}.
 The set of supported units is fixed for a given chronology.
 The amount of a supported unit may be set to zero.
 &lt;p&gt;
 The period is modeled as a directed amount of time, meaning that individual
 parts of the period may be negative.

 @implSpec
 This interface must be implemented with care to ensure other classes operate correctly.
 All implementations that can be instantiated must be final, immutable and thread-safe.
 Subclasses should be Serializable wherever possible.

 @since 1.8
*/
var ChronoPeriod = {

<span id='java-time-chrono-ChronoPeriod-method-between'>/**Obtains a {@code ChronoPeriod} consisting of amount of time between two dates.
</span> &lt;p&gt;
 The start date is included, but the end date is not.
 The period is calculated using {@link java.time.chrono.ChronoLocalDate#until(java.time.chrono.ChronoLocalDate)}.
 As such, the calculation is chronology specific.
 &lt;p&gt;
 The chronology of the first date is used.
 The chronology of the second date is ignored, with the date being converted
 to the target chronology system before the calculation starts.
 &lt;p&gt;
 The result of this method can be a negative period if the end is before the start.
 In most cases, the positive/negative sign will be the same in each of the supported fields.
@param {Object {ChronoLocalDate}} startDateInclusive  the start date, inclusive, specifying the chronology of the calculation, not null
@param {Object {ChronoLocalDate}} endDateExclusive  the end date, exclusive, in any chronology, not null
@return {Object {java.time.chrono.ChronoPeriod}} the period between this date and the end date, not null
@see ChronoLocalDate#until(ChronoLocalDate)
*/
between : function(  ) {},

<span id='java-time-chrono-ChronoPeriod-method-get'>/**Gets the value of the requested unit.
</span> &lt;p&gt;
 The supported units are chronology specific.
 They will typically be {@link ChronoUnit#YEARS YEARS},
 {@link ChronoUnit#MONTHS MONTHS} and {@link ChronoUnit#DAYS DAYS}.
 Requesting an unsupported unit will throw an exception.
@param {Object {TemporalUnit}} unit the {@code TemporalUnit} for which to return the value
@return {Number} the long value of the unit
@throws DateTimeException if the unit is not supported
@throws UnsupportedTemporalTypeException if the unit is not supported
*/
get : function(  ) {},

<span id='java-time-chrono-ChronoPeriod-method-getUnits'>/**Gets the set of units supported by this period.
</span> &lt;p&gt;
 The supported units are chronology specific.
 They will typically be {@link ChronoUnit#YEARS YEARS},
 {@link ChronoUnit#MONTHS MONTHS} and {@link ChronoUnit#DAYS DAYS}.
 They are returned in order from largest to smallest.
 &lt;p&gt;
 This set can be used in conjunction with {@link #get}(TemporalUnit)
 to access the entire state of the period.
@return {Object {java.util.List}} a list containing the supported units, not null
*/
getUnits : function(  ) {},

<span id='java-time-chrono-ChronoPeriod-method-getChronology'>/**Gets the chronology that defines the meaning of the supported units.
</span> &lt;p&gt;
 The period is defined by the chronology.
 It controls the supported units and restricts addition/subtraction
 to {@code ChronoLocalDate} instances of the same chronology.
@return {Object {java.time.chrono.Chronology}} the chronology defining the period, not null
*/
getChronology : function(  ) {},

<span id='java-time-chrono-ChronoPeriod-method-isZero'>/**Checks if all the supported units of this period are zero.
</span>@return {Boolean} true if this period is zero-length
*/
isZero : function(  ) {},

<span id='java-time-chrono-ChronoPeriod-method-isNegative'>/**Checks if any of the supported units of this period are negative.
</span>@return {Boolean} true if any unit of this period is negative
*/
isNegative : function(  ) {},

<span id='java-time-chrono-ChronoPeriod-method-plus'>/**Returns a copy of this period with the specified period added.
</span> &lt;p&gt;
 If the specified amount is a {@code ChronoPeriod} then it must have
 the same chronology as this period. Implementations may choose to
 accept or reject other {@code TemporalAmount} implementations.
 &lt;p&gt;
 This instance is immutable and unaffected by this method call.
@param {Object {TemporalAmount}} amountToAdd  the period to add, not null
@return {Object {java.time.chrono.ChronoPeriod}} a {@code ChronoPeriod} based on this period with the requested period added, not null
@throws ArithmeticException if numeric overflow occurs
*/
plus : function(  ) {},

<span id='java-time-chrono-ChronoPeriod-method-minus'>/**Returns a copy of this period with the specified period subtracted.
</span> &lt;p&gt;
 If the specified amount is a {@code ChronoPeriod} then it must have
 the same chronology as this period. Implementations may choose to
 accept or reject other {@code TemporalAmount} implementations.
 &lt;p&gt;
 This instance is immutable and unaffected by this method call.
@param {Object {TemporalAmount}} amountToSubtract  the period to subtract, not null
@return {Object {java.time.chrono.ChronoPeriod}} a {@code ChronoPeriod} based on this period with the requested period subtracted, not null
@throws ArithmeticException if numeric overflow occurs
*/
minus : function(  ) {},

<span id='java-time-chrono-ChronoPeriod-method-multipliedBy'>/**Returns a new instance with each amount in this period in this period
</span> multiplied by the specified scalar.
 &lt;p&gt;
 This returns a period with each supported unit individually multiplied.
 For example, a period of &quot;2 years, -3 months and 4 days&quot; multiplied by
 3 will return &quot;6 years, -9 months and 12 days&quot;.
 No normalization is performed.
@param {Number} scalar  the scalar to multiply by, not null
@return {Object {java.time.chrono.ChronoPeriod}} a {@code ChronoPeriod} based on this period with the amounts multiplied
  by the scalar, not null
@throws ArithmeticException if numeric overflow occurs
*/
multipliedBy : function(  ) {},

<span id='java-time-chrono-ChronoPeriod-method-negated'>/**Returns a new instance with each amount in this period negated.
</span> &lt;p&gt;
 This returns a period with each supported unit individually negated.
 For example, a period of &quot;2 years, -3 months and 4 days&quot; will be
 negated to &quot;-2 years, 3 months and -4 days&quot;.
 No normalization is performed.
@return {Object {java.time.chrono.ChronoPeriod}} a {@code ChronoPeriod} based on this period with the amounts negated, not null
@throws ArithmeticException if numeric overflow occurs, which only happens if
  one of the units has the value {@code Long.MIN_VALUE}
*/
negated : function(  ) {},

<span id='java-time-chrono-ChronoPeriod-method-normalized'>/**Returns a copy of this period with the amounts of each unit normalized.
</span> &lt;p&gt;
 The process of normalization is specific to each calendar system.
 For example, in the ISO calendar system, the years and months are
 normalized but the days are not, such that &quot;15 months&quot; would be
 normalized to &quot;1 year and 3 months&quot;.
 &lt;p&gt;
 This instance is immutable and unaffected by this method call.
@return {Object {java.time.chrono.ChronoPeriod}} a {@code ChronoPeriod} based on this period with the amounts of each
  unit normalized, not null
@throws ArithmeticException if numeric overflow occurs
*/
normalized : function(  ) {},

<span id='java-time-chrono-ChronoPeriod-method-addTo'>/**Adds this period to the specified temporal object.
</span> &lt;p&gt;
 This returns a temporal object of the same observable type as the input
 with this period added.
 &lt;p&gt;
 In most cases, it is clearer to reverse the calling pattern by using
 {@link Temporal#plus(TemporalAmount)}.
 &lt;pre&gt;
   // these two lines are equivalent, but the second approach is recommended
   dateTime = thisPeriod.addTo(dateTime);
   dateTime = dateTime.plus(thisPeriod);
 &lt;/pre&gt;
 &lt;p&gt;
 The specified temporal must have the same chronology as this period.
 This returns a temporal with the non-zero supported units added.
 &lt;p&gt;
 This instance is immutable and unaffected by this method call.
@param {Object {Temporal}} temporal  the temporal object to adjust, not null
@return {Object {java.time.temporal.Temporal}} an object of the same type with the adjustment made, not null
@throws DateTimeException if unable to add
@throws ArithmeticException if numeric overflow occurs
*/
addTo : function(  ) {},

<span id='java-time-chrono-ChronoPeriod-method-subtractFrom'>/**Subtracts this period from the specified temporal object.
</span> &lt;p&gt;
 This returns a temporal object of the same observable type as the input
 with this period subtracted.
 &lt;p&gt;
 In most cases, it is clearer to reverse the calling pattern by using
 {@link Temporal#minus(TemporalAmount)}.
 &lt;pre&gt;
   // these two lines are equivalent, but the second approach is recommended
   dateTime = thisPeriod.subtractFrom(dateTime);
   dateTime = dateTime.minus(thisPeriod);
 &lt;/pre&gt;
 &lt;p&gt;
 The specified temporal must have the same chronology as this period.
 This returns a temporal with the non-zero supported units subtracted.
 &lt;p&gt;
 This instance is immutable and unaffected by this method call.
@param {Object {Temporal}} temporal  the temporal object to adjust, not null
@return {Object {java.time.temporal.Temporal}} an object of the same type with the adjustment made, not null
@throws DateTimeException if unable to subtract
@throws ArithmeticException if numeric overflow occurs
*/
subtractFrom : function(  ) {},

<span id='java-time-chrono-ChronoPeriod-method-equals'>/**Checks if this period is equal to another period, including the chronology.
</span> &lt;p&gt;
 Compares this period with another ensuring that the type, each amount and
 the chronology are the same.
 Note that this means that a period of &quot;15 Months&quot; is not equal to a period
 of &quot;1 Year and 3 Months&quot;.
@param {Object {Object}} obj  the object to check, null returns false
@return {Boolean} true if this is equal to the other period
*/
equals : function(  ) {},

<span id='java-time-chrono-ChronoPeriod-method-hashCode'>/**A hash code for this period.
</span>@return {Number} a suitable hash code
*/
hashCode : function(  ) {},

<span id='java-time-chrono-ChronoPeriod-method-toString'>/**Outputs this period as a {@code String}.
</span> &lt;p&gt;
 The output will include the period amounts and chronology.
@return {String} a string representation of this period, not null
*/
toString : function(  ) {},


};</pre>
</body>
</html>
