<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='jsr166-PhaserTest'>/**@class jsr166.PhaserTest
</span>@extends jsr166.JSR166TestCase

*/
var PhaserTest = {

<span id='jsr166-PhaserTest-method-testConstructorDefaultValues'>/**Empty constructor builds a new Phaser with no parent, no registered
</span> parties and initial phase number of 0
*/
testConstructorDefaultValues : function(  ) {},

<span id='jsr166-PhaserTest-method-testConstructorNegativeParties'>/**Constructing with a negative number of parties throws
</span> IllegalArgumentException
*/
testConstructorNegativeParties : function(  ) {},

<span id='jsr166-PhaserTest-method-testConstructorNegativeParties2'>/**Constructing with a negative number of parties throws
</span> IllegalArgumentException
*/
testConstructorNegativeParties2 : function(  ) {},

<span id='jsr166-PhaserTest-method-testConstructorPartiesExceedsLimit'>/**Constructing with a number of parties &gt; 65535 throws
</span> IllegalArgumentException
*/
testConstructorPartiesExceedsLimit : function(  ) {},

<span id='jsr166-PhaserTest-method-testConstructor3'>/**The parent provided to the constructor should be returned from
</span> a later call to getParent
*/
testConstructor3 : function(  ) {},

<span id='jsr166-PhaserTest-method-testConstructor5'>/**The parent being input into the parameter should equal the original
</span> parent when being returned
*/
testConstructor5 : function(  ) {},

<span id='jsr166-PhaserTest-method-testRegister1'>/**register() will increment the number of unarrived parties by
</span> one and not affect its arrived parties
*/
testRegister1 : function(  ) {},

<span id='jsr166-PhaserTest-method-testRegister2'>/**Registering more than 65536 parties causes IllegalStateException
</span>*/
testRegister2 : function(  ) {},

<span id='jsr166-PhaserTest-method-testRegister3'>/**register() correctly returns the current barrier phase number
</span> when invoked
*/
testRegister3 : function(  ) {},

<span id='jsr166-PhaserTest-method-testRegister4'>/**register causes the next arrive to not increment the phase
</span> rather retain the phase number
*/
testRegister4 : function(  ) {},

<span id='jsr166-PhaserTest-method-testRegisterEmptySubPhaser'>/**register on a subphaser that is currently empty succeeds, even
</span> in the presence of another non-empty subphaser
*/
testRegisterEmptySubPhaser : function(  ) {},

<span id='jsr166-PhaserTest-method-testBulkRegister1'>/**Invoking bulkRegister with a negative parameter throws an
</span> IllegalArgumentException
*/
testBulkRegister1 : function(  ) {},

<span id='jsr166-PhaserTest-method-testBulkRegister2'>/**bulkRegister should correctly record the number of unarrived
</span> parties with the number of parties being registered
*/
testBulkRegister2 : function(  ) {},

<span id='jsr166-PhaserTest-method-testBulkRegister3'>/**Registering with a number of parties greater than or equal to 1&lt;&lt;16
</span> throws IllegalStateException.
*/
testBulkRegister3 : function(  ) {},

<span id='jsr166-PhaserTest-method-testPhaseIncrement1'>/**the phase number increments correctly when tripping the barrier
</span>*/
testPhaseIncrement1 : function(  ) {},

<span id='jsr166-PhaserTest-method-testArrive1'>/**arrive() on a registered phaser increments phase.
</span>*/
testArrive1 : function(  ) {},

<span id='jsr166-PhaserTest-method-testArriveAndDeregister'>/**arriveAndDeregister does not wait for others to arrive at barrier
</span>*/
testArriveAndDeregister : function(  ) {},

<span id='jsr166-PhaserTest-method-testArrive2'>/**arriveAndDeregister does not wait for others to arrive at barrier
</span>*/
testArrive2 : function(  ) {},

<span id='jsr166-PhaserTest-method-testArrive3'>/**arrive() returns a negative number if the Phaser is terminated
</span>*/
testArrive3 : function(  ) {},

<span id='jsr166-PhaserTest-method-testArriveAndDeregister1'>/**arriveAndDeregister() throws IllegalStateException if number of
</span> registered or unarrived parties would become negative
*/
testArriveAndDeregister1 : function(  ) {},

<span id='jsr166-PhaserTest-method-testArriveAndDeregister2'>/**arriveAndDeregister reduces the number of arrived parties
</span>*/
testArriveAndDeregister2 : function(  ) {},

<span id='jsr166-PhaserTest-method-testArriveAndDeregister3'>/**arriveAndDeregister arrives at the barrier on a phaser with a parent and
</span> when a deregistration occurs and causes the phaser to have zero parties
 its parent will be deregistered as well
*/
testArriveAndDeregister3 : function(  ) {},

<span id='jsr166-PhaserTest-method-testArriveAndDeregister4'>/**arriveAndDeregister deregisters one party from its parent when
</span> the number of parties of child is zero after deregistration
*/
testArriveAndDeregister4 : function(  ) {},

<span id='jsr166-PhaserTest-method-testArriveAndDeregister5'>/**arriveAndDeregister deregisters one party from its parent when
</span> the number of parties of root is nonzero after deregistration.
*/
testArriveAndDeregister5 : function(  ) {},

<span id='jsr166-PhaserTest-method-testArriveAndDeregister6'>/**arriveAndDeregister returns the phase in which it leaves the
</span> phaser in after deregistration
*/
testArriveAndDeregister6 : function(  ) {},

<span id='jsr166-PhaserTest-method-testAwaitAdvance1'>/**awaitAdvance succeeds upon advance
</span>*/
testAwaitAdvance1 : function(  ) {},

<span id='jsr166-PhaserTest-method-testAwaitAdvance2'>/**awaitAdvance with a negative parameter will return without affecting the
</span> phaser
*/
testAwaitAdvance2 : function(  ) {},

<span id='jsr166-PhaserTest-method-testAwaitAdvanceInterruptibly_interruptible'>/**awaitAdvanceInterruptibly blocks interruptibly
</span>*/
testAwaitAdvanceInterruptibly_interruptible : function(  ) {},

<span id='jsr166-PhaserTest-method-testAwaitAdvanceAfterInterrupt'>/**awaitAdvance continues waiting if interrupted before waiting
</span>*/
testAwaitAdvanceAfterInterrupt : function(  ) {},

<span id='jsr166-PhaserTest-method-testAwaitAdvanceBeforeInterrupt'>/**awaitAdvance continues waiting if interrupted while waiting
</span>*/
testAwaitAdvanceBeforeInterrupt : function(  ) {},

<span id='jsr166-PhaserTest-method-testArriveAndAwaitAdvanceAfterInterrupt'>/**arriveAndAwaitAdvance continues waiting if interrupted before waiting
</span>*/
testArriveAndAwaitAdvanceAfterInterrupt : function(  ) {},

<span id='jsr166-PhaserTest-method-testArriveAndAwaitAdvanceBeforeInterrupt'>/**arriveAndAwaitAdvance continues waiting if interrupted while waiting
</span>*/
testArriveAndAwaitAdvanceBeforeInterrupt : function(  ) {},

<span id='jsr166-PhaserTest-method-testAwaitAdvance4'>/**awaitAdvance atomically waits for all parties within the same phase to
</span> complete before continuing
*/
testAwaitAdvance4 : function(  ) {},

<span id='jsr166-PhaserTest-method-testAwaitAdvance5'>/**awaitAdvance returns the current phase
</span>*/
testAwaitAdvance5 : function(  ) {},

<span id='jsr166-PhaserTest-method-testAwaitAdvanceTieredPhaser'>/**awaitAdvance returns the current phase in child phasers
</span>*/
testAwaitAdvanceTieredPhaser : function(  ) {},

<span id='jsr166-PhaserTest-method-testAwaitAdvance6'>/**awaitAdvance returns when the phaser is externally terminated
</span>*/
testAwaitAdvance6 : function(  ) {},

<span id='jsr166-PhaserTest-method-testArriveAndAwaitAdvance1'>/**arriveAndAwaitAdvance throws IllegalStateException with no
</span> unarrived parties
*/
testArriveAndAwaitAdvance1 : function(  ) {},

<span id='jsr166-PhaserTest-method-testArriveAndAwaitAdvance3'>/**arriveAndAwaitAdvance waits for all threads to arrive, the
</span> number of arrived parties is the same number that is accounted
 for when the main thread awaitsAdvance
*/
testArriveAndAwaitAdvance3 : function(  ) {},


};</pre>
</body>
</html>
