<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='android-app-Application'>/**@class android.app.Application
</span> implements android.content.ComponentCallbacks2

@extends android.content.ContextWrapper

 Base class for maintaining global application state. You can provide your own
 implementation by creating a subclass and specifying the fully-qualified name
 of this subclass as the &lt;code&gt;&quot;android:name&quot;&lt;/code&gt; attribute in your
 AndroidManifest.xml's &lt;code&gt;&amp;lt;application&amp;gt;&lt;/code&gt; tag. The Application
 class, or your subclass of the Application class, is instantiated before any
 other class when the process for your application/package is created.

 &lt;p class=&quot;note&quot;&gt;&lt;strong&gt;Note: &lt;/strong&gt;There is normally no need to subclass
 Application.  In most situations, static singletons can provide the same
 functionality in a more modular way.  If your singleton needs a global
 context (for example to register broadcast receivers), include
 {@link android.content.Context#getApplicationContext() Context.getApplicationContext()}
 as a {@link android.content.Context} argument when invoking your singleton's
 &lt;code&gt;getInstance()&lt;/code&gt; method.
 &lt;/p&gt;
*/
var Application = {

<span id='android-app-Application-property-mLoadedApk'>/**@hide */
</span>mLoadedApk : &quot;null&quot;,
<span id='android-app-Application-method-onCreate'>/**Called when the application is starting, before any activity, service,
</span> or receiver objects (excluding content providers) have been created.

 &lt;p&gt;Implementations should be as quick as possible (for example using
 lazy initialization of state) since the time spent in this function
 directly impacts the performance of starting the first activity,
 service, or receiver in a process.&lt;/p&gt;

 &lt;p&gt;If you override this method, be sure to call {@code super.onCreate()}.&lt;/p&gt;

 &lt;p class=&quot;note&quot;&gt;Be aware that direct boot may also affect callback order on
 Android {@link android.os.Build.VERSION_CODES#N} and later devices.
 Until the user unlocks the device, only direct boot aware components are
 allowed to run. You should consider that all direct boot unaware
 components, including such {@link android.content.ContentProvider}, are
 disabled until user unlock happens, especially when component callback
 order matters.&lt;/p&gt;
*/
onCreate : function(  ) {},

<span id='android-app-Application-method-onTerminate'>/**This method is for use in emulated process environments.  It will
</span> never be called on a production Android device, where processes are
 removed by simply killing them; no user code (including this callback)
 is executed when doing so.
*/
onTerminate : function(  ) {},

<span id='android-app-Application-method-onConfigurationChanged'>/**
</span>*/
onConfigurationChanged : function(  ) {},

<span id='android-app-Application-method-onLowMemory'>/**
</span>*/
onLowMemory : function(  ) {},

<span id='android-app-Application-method-onTrimMemory'>/**
</span>*/
onTrimMemory : function(  ) {},

<span id='android-app-Application-method-registerComponentCallbacks'>/**
</span>*/
registerComponentCallbacks : function(  ) {},

<span id='android-app-Application-method-unregisterComponentCallbacks'>/**
</span>*/
unregisterComponentCallbacks : function(  ) {},

<span id='android-app-Application-method-registerActivityLifecycleCallbacks'>/**
</span>*/
registerActivityLifecycleCallbacks : function(  ) {},

<span id='android-app-Application-method-unregisterActivityLifecycleCallbacks'>/**
</span>*/
unregisterActivityLifecycleCallbacks : function(  ) {},

<span id='android-app-Application-method-registerOnProvideAssistDataListener'>/**
</span>*/
registerOnProvideAssistDataListener : function(  ) {},

<span id='android-app-Application-method-unregisterOnProvideAssistDataListener'>/**
</span>*/
unregisterOnProvideAssistDataListener : function(  ) {},

<span id='android-app-Application-method-getProcessName'>/**Returns the name of the current process. A package's default process name
</span> is the same as its package name. Non-default processes will look like
 &quot;$PACKAGE_NAME:$NAME&quot;, where $NAME corresponds to an android:process
 attribute within AndroidManifest.xml.
*/
getProcessName : function(  ) {},

<span id='android-app-Application-method-getAutofillClient'>/**
</span>@hide 
*/
getAutofillClient : function(  ) {},


};</pre>
</body>
</html>
