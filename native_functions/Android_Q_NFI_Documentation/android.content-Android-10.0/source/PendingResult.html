<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='android-content-BroadcastReceiver-PendingResult'>/**@class android.content.BroadcastReceiver.PendingResult
</span>@extends java.lang.Object

 State for a result that is pending for a broadcast receiver.  Returned
 by {@link android.content.BroadcastReceiver#goAsync() goAsync()}
 while in {@link android.content.BroadcastReceiver#onReceive android.content.BroadcastReceiver.onReceive()}.
 This allows you to return from onReceive() without having the broadcast
 terminate; you must call {@link #finish}() once you are done with the
 broadcast.  This allows you to process the broadcast off of the main
 thread of your app.

 &lt;p&gt;Note on threading: the state inside of this class is not itself
 thread-safe, however you can use it from any thread if you properly
 sure that you do not have races.  Typically this means you will hand
 the entire object to another thread, which will be solely responsible
 for setting any results and finally calling {@link #finish}().
*/
var PendingResult = {

<span id='android-content-BroadcastReceiver-PendingResult-property-TYPE_COMPONENT'>/**@hide */
</span>TYPE_COMPONENT : &quot;0&quot;,
<span id='android-content-BroadcastReceiver-PendingResult-property-TYPE_REGISTERED'>/**@hide */
</span>TYPE_REGISTERED : &quot;1&quot;,
<span id='android-content-BroadcastReceiver-PendingResult-property-TYPE_UNREGISTERED'>/**@hide */
</span>TYPE_UNREGISTERED : &quot;2&quot;,
<span id='android-content-BroadcastReceiver-PendingResult-method-setResultCode'>/**Version of {@link android.content.BroadcastReceiver#setResultCode(int)
</span> android.content.BroadcastReceiver.setResultCode(int)} for
 asynchronous broadcast handling.
*/
setResultCode : function(  ) {},

<span id='android-content-BroadcastReceiver-PendingResult-method-getResultCode'>/**Version of {@link android.content.BroadcastReceiver#getResultCode()
</span> android.content.BroadcastReceiver.getResultCode()} for
 asynchronous broadcast handling.
*/
getResultCode : function(  ) {},

<span id='android-content-BroadcastReceiver-PendingResult-method-setResultData'>/**Version of {@link android.content.BroadcastReceiver#setResultData(String)
</span> android.content.BroadcastReceiver.setResultData(String)} for
 asynchronous broadcast handling.
*/
setResultData : function(  ) {},

<span id='android-content-BroadcastReceiver-PendingResult-method-getResultData'>/**Version of {@link android.content.BroadcastReceiver#getResultData()
</span> android.content.BroadcastReceiver.getResultData()} for
 asynchronous broadcast handling.
*/
getResultData : function(  ) {},

<span id='android-content-BroadcastReceiver-PendingResult-method-setResultExtras'>/**Version of {@link android.content.BroadcastReceiver#setResultExtras(Bundle)
</span> android.content.BroadcastReceiver.setResultExtras(Bundle)} for
 asynchronous broadcast handling.
*/
setResultExtras : function(  ) {},

<span id='android-content-BroadcastReceiver-PendingResult-method-getResultExtras'>/**Version of {@link android.content.BroadcastReceiver#getResultExtras(boolean)
</span> android.content.BroadcastReceiver.getResultExtras(boolean)} for
 asynchronous broadcast handling.
*/
getResultExtras : function(  ) {},

<span id='android-content-BroadcastReceiver-PendingResult-method-setResult'>/**Version of {@link android.content.BroadcastReceiver#setResult(int, String, Bundle)
</span> android.content.BroadcastReceiver.setResult(int, String, Bundle)} for
 asynchronous broadcast handling.
*/
setResult : function(  ) {},

<span id='android-content-BroadcastReceiver-PendingResult-method-getAbortBroadcast'>/**Version of {@link android.content.BroadcastReceiver#getAbortBroadcast()
</span> android.content.BroadcastReceiver.getAbortBroadcast()} for
 asynchronous broadcast handling.
*/
getAbortBroadcast : function(  ) {},

<span id='android-content-BroadcastReceiver-PendingResult-method-abortBroadcast'>/**Version of {@link android.content.BroadcastReceiver#abortBroadcast()
</span> android.content.BroadcastReceiver.abortBroadcast()} for
 asynchronous broadcast handling.
*/
abortBroadcast : function(  ) {},

<span id='android-content-BroadcastReceiver-PendingResult-method-clearAbortBroadcast'>/**Version of {@link android.content.BroadcastReceiver#clearAbortBroadcast()
</span> android.content.BroadcastReceiver.clearAbortBroadcast()} for
 asynchronous broadcast handling.
*/
clearAbortBroadcast : function(  ) {},

<span id='android-content-BroadcastReceiver-PendingResult-method-finish'>/**Finish the broadcast.  The current result will be sent and the
</span> next broadcast will proceed.
*/
finish : function(  ) {},

<span id='android-content-BroadcastReceiver-PendingResult-method-setExtrasClassLoader'>/**
</span>@hide 
*/
setExtrasClassLoader : function(  ) {},

<span id='android-content-BroadcastReceiver-PendingResult-method-sendFinished'>/**
</span>@hide 
*/
sendFinished : function(  ) {},

<span id='android-content-BroadcastReceiver-PendingResult-method-getSendingUserId'>/**
</span>@hide 
*/
getSendingUserId : function(  ) {},


};</pre>
</body>
</html>
