<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='android-transition-Transition'>/**@class android.transition.Transition
</span> implements java.lang.Cloneable

@extends java.lang.Object

 A Transition holds information about animations that will be run on its
 targets during a scene change. Subclasses of this abstract class may
 choreograph several child transitions ({@link android.transition.TransitionSet} or they may
 perform custom animations themselves. Any Transition has two main jobs:
 (1) capture property values, and (2) play animations based on changes to
 captured property values. A custom transition knows what property values
 on View objects are of interest to it, and also knows how to animate
 changes to those values. For example, the {@link android.transition.Fade} transition tracks
 changes to visibility-related properties and is able to construct and run
 animations that fade items in or out based on changes to those properties.

 &lt;p&gt;Note: Transitions may not work correctly with either {@link SurfaceView}
 or {@link TextureView}, due to the way that these views are displayed
 on the screen. For SurfaceView, the problem is that the view is updated from
 a non-UI thread, so changes to the view due to transitions (such as moving
 and resizing the view) may be out of sync with the display inside those bounds.
 TextureView is more compatible with transitions in general, but some
 specific transitions (such as {@link android.transition.Fade}) may not be compatible
 with TextureView because they rely on {@link ViewOverlay} functionality,
 which does not currently work with TextureView.&lt;/p&gt;

 &lt;p&gt;Transitions can be declared in XML resource files inside the &lt;code&gt;res/transition&lt;/code&gt;
 directory. Transition resources consist of a tag name for one of the Transition
 subclasses along with attributes to define some of the attributes of that transition.
 For example, here is a minimal resource file that declares a {@link android.transition.ChangeBounds} transition:

 {@sample development/samples/ApiDemos/res/transition/changebounds.xml ChangeBounds}

 &lt;p&gt;This TransitionSet contains {@link android.transition.Explode} for visibility,
 {@link android.transition.ChangeBounds}, {@link android.transition.ChangeTransform},
 and {@link android.transition.ChangeClipBounds} and
 {@link android.transition.ChangeImageTransform}:&lt;/p&gt;

 {@sample development/samples/ApiDemos/res/transition/explode_move_together.xml MultipleTransform}

 &lt;p&gt;Custom transition classes may be instantiated with a &lt;code&gt;transition&lt;/code&gt; tag:&lt;/p&gt;
 &lt;pre&gt;&amp;lt;transition class=&quot;my.app.transition.CustomTransition&quot;/&gt;&lt;/pre&gt;
 &lt;p&gt;Custom transition classes loaded from XML should have a public constructor taking
 a {@link android.content.Context} and {@link android.util.AttributeSet}.&lt;/p&gt;

 &lt;p&gt;Note that attributes for the transition are not required, just as they are
 optional when declared in code; Transitions created from XML resources will use
 the same defaults as their code-created equivalents. Here is a slightly more
 elaborate example which declares a {@link android.transition.TransitionSet} transition with
 {@link android.transition.ChangeBounds} and {@link android.transition.Fade} child transitions:&lt;/p&gt;

 {@sample
 development/samples/ApiDemos/res/transition/changebounds_fadeout_sequential.xml TransitionSet}

 &lt;p&gt;In this example, the transitionOrdering attribute is used on the TransitionSet
 object to change from the default {@link android.transition.TransitionSet#ORDERING_TOGETHER} behavior
 to be {@link android.transition.TransitionSet#ORDERING_SEQUENTIAL} instead. Also, the {@link android.transition.Fade}
 transition uses a fadingMode of {@link android.transition.Fade#OUT} instead of the default
 out-in behavior. Finally, note the use of the &lt;code&gt;targets&lt;/code&gt; sub-tag, which
 takes a set of {@link android.R.styleable#TransitionTarget target} tags, each
 of which lists a specific &lt;code&gt;targetId&lt;/code&gt;, &lt;code&gt;targetClass&lt;/code&gt;,
 &lt;code&gt;targetName&lt;/code&gt;, &lt;code&gt;excludeId&lt;/code&gt;, &lt;code&gt;excludeClass&lt;/code&gt;, or
 &lt;code&gt;excludeName&lt;/code&gt;, which this transition acts upon.
 Use of targets is optional, but can be used to either limit the time spent checking
 attributes on unchanging views, or limiting the types of animations run on specific views.
 In this case, we know that only the &lt;code&gt;grayscaleContainer&lt;/code&gt; will be
 disappearing, so we choose to limit the {@link android.transition.Fade} transition to only that view.&lt;/p&gt;

 Further information on XML resource descriptions for transitions can be found for
 {@link android.R.styleable#Transition}, {@link android.R.styleable#TransitionSet},
 {@link android.R.styleable#TransitionTarget}, {@link android.R.styleable#Fade},
 {@link android.R.styleable#Slide}, and {@link android.R.styleable#ChangeTransform}.

*/
var Transition = {

<span id='android-transition-Transition-property-MATCH_INSTANCE'>/** With {@link #setMatchOrder(int...)}, chooses to match by View instance.
</span>*/
MATCH_INSTANCE : &quot;1&quot;,
<span id='android-transition-Transition-property-MATCH_NAME'>/** With {@link #setMatchOrder(int...)}, chooses to match by
</span> {@link android.view.View#getTransitionName()}. Null names will not be matched.
*/
MATCH_NAME : &quot;2&quot;,
<span id='android-transition-Transition-property-MATCH_ID'>/** With {@link #setMatchOrder(int...)}, chooses to match by
</span> {@link android.view.View#getId()}. Negative IDs will not be matched.
*/
MATCH_ID : &quot;3&quot;,
<span id='android-transition-Transition-property-MATCH_ITEM_ID'>/** With {@link #setMatchOrder(int...)}, chooses to match by the {@link android.widget.Adapter}
</span> item id. When {@link android.widget.Adapter#hasStableIds()} returns false, no match
 will be made for items.
*/
MATCH_ITEM_ID : &quot;4&quot;,
<span id='android-transition-Transition-method-setDuration'>/**Sets the duration of this transition. By default, there is no duration
</span> (indicated by a negative number), which means that the Animator created by
 the transition will have its own specified duration. If the duration of a
 Transition is set, that duration will override the Animator duration.
@param {Number} duration The length of the animation, in milliseconds.
@return {Object {android.transition.Transition}} This transition object.
@attr ref android.R.styleable#Transition_duration
*/
setDuration : function(  ) {},

<span id='android-transition-Transition-method-getDuration'>/**Returns the duration set on this transition. If no duration has been set,
</span> the returned value will be negative, indicating that resulting animators will
 retain their own durations.
@return {Number} The duration set on this transition, in milliseconds, if one has been
 set, otherwise returns a negative number.
*/
getDuration : function(  ) {},

<span id='android-transition-Transition-method-setStartDelay'>/**Sets the startDelay of this transition. By default, there is no delay
</span> (indicated by a negative number), which means that the Animator created by
 the transition will have its own specified startDelay. If the delay of a
 Transition is set, that delay will override the Animator delay.
@param {Number} startDelay The length of the delay, in milliseconds.
@return {Object {android.transition.Transition}} This transition object.
@attr ref android.R.styleable#Transition_startDelay
*/
setStartDelay : function(  ) {},

<span id='android-transition-Transition-method-getStartDelay'>/**Returns the startDelay set on this transition. If no startDelay has been set,
</span> the returned value will be negative, indicating that resulting animators will
 retain their own startDelays.
@return {Number} The startDelay set on this transition, in milliseconds, if one has
 been set, otherwise returns a negative number.
*/
getStartDelay : function(  ) {},

<span id='android-transition-Transition-method-setInterpolator'>/**Sets the interpolator of this transition. By default, the interpolator
</span> is null, which means that the Animator created by the transition
 will have its own specified interpolator. If the interpolator of a
 Transition is set, that interpolator will override the Animator interpolator.
@param {Object {TimeInterpolator}} interpolator The time interpolator used by the transition
@return {Object {android.transition.Transition}} This transition object.
@attr ref android.R.styleable#Transition_interpolator
*/
setInterpolator : function(  ) {},

<span id='android-transition-Transition-method-getInterpolator'>/**Returns the interpolator set on this transition. If no interpolator has been set,
</span> the returned value will be null, indicating that resulting animators will
 retain their own interpolators.
@return {Object {android.animation.TimeInterpolator}} The interpolator set on this transition, if one has been set, otherwise
 returns null.
*/
getInterpolator : function(  ) {},

<span id='android-transition-Transition-method-getTransitionProperties'>/**Returns the set of property names used stored in the {@link android.transition.TransitionValues}
</span> object passed into {@link #captureStartValues}(TransitionValues) that
 this transition cares about for the purposes of canceling overlapping animations.
 When any transition is started on a given scene root, all transitions
 currently running on that same scene root are checked to see whether the
 properties on which they based their animations agree with the end values of
 the same properties in the new transition. If the end values are not equal,
 then the old animation is canceled since the new transition will start a new
 animation to these new values. If the values are equal, the old animation is
 allowed to continue and no new animation is started for that transition.

 &lt;p&gt;A transition does not need to override this method. However, not doing so
 will mean that the cancellation logic outlined in the previous paragraph
 will be skipped for that transition, possibly leading to artifacts as
 old transitions and new transitions on the same targets run in parallel,
 animating views toward potentially different end values.&lt;/p&gt;
@return {String} An array of property names as described in the class documentation for
 {@link TransitionValues}. The default implementation returns &lt;code&gt;null&lt;/code&gt;.
*/
getTransitionProperties : function(  ) {},

<span id='android-transition-Transition-method-createAnimator'>/**This method creates an animation that will be run for this transition
</span> given the information in the startValues and endValues structures captured
 earlier for the start and end scenes. Subclasses of Transition should override
 this method. The method should only be called by the transition system; it is
 not intended to be called from external classes.

 &lt;p&gt;This method is called by the transition's parent (all the way up to the
 topmost Transition in the hierarchy) with the sceneRoot and start/end
 values that the transition may need to set up initial target values
 and construct an appropriate animation. For example, if an overall
 Transition is a {@link android.transition.TransitionSet} consisting of several
 child transitions in sequence, then some of the child transitions may
 want to set initial values on target views prior to the overall
 Transition commencing, to put them in an appropriate state for the
 delay between that start and the child Transition start time. For
 example, a transition that fades an item in may wish to set the starting
 alpha value to 0, to avoid it blinking in prior to the transition
 actually starting the animation. This is necessary because the scene
 change that triggers the Transition will automatically set the end-scene
 on all target views, so a Transition that wants to animate from a
 different value should set that value prior to returning from this method.&lt;/p&gt;

 &lt;p&gt;Additionally, a Transition can perform logic to determine whether
 the transition needs to run on the given target and start/end values.
 For example, a transition that resizes objects on the screen may wish
 to avoid running for views which are not present in either the start
 or end scenes.&lt;/p&gt;

 &lt;p&gt;If there is an animator created and returned from this method, the
 transition mechanism will apply any applicable duration, startDelay,
 and interpolator to that animation and start it. A return value of
 &lt;code&gt;null&lt;/code&gt; indicates that no animation should run. The default
 implementation returns null.&lt;/p&gt;

 &lt;p&gt;The method is called for every applicable target object, which is
 stored in the {@link android.transition.TransitionValues#view} field.&lt;/p&gt;
@param {Object {ViewGroup}} sceneRoot The root of the transition hierarchy.
@param {Object {TransitionValues}} startValues The values for a specific target in the start scene.
@param {Object {TransitionValues}} endValues The values for the target in the end scene.
@return {Object {android.animation.Animator}} A Animator to be started at the appropriate time in the
 overall transition for this scene change. A null value means no animation
 should be run.
*/
createAnimator : function(  ) {},

<span id='android-transition-Transition-method-setMatchOrder'>/**Sets the order in which Transition matches View start and end values.
</span> &lt;p&gt;
 The default behavior is to match first by {@link android.view.View#getTransitionName()},
 then by View instance, then by {@link android.view.View#getId()} and finally
 by its item ID if it is in a direct child of ListView. The caller can
 choose to have only some or all of the values of {@link #MATCH_INSTANCE},
 {@link #MATCH_NAME}, {@link #MATCH_ITEM_ID}, and {@link #MATCH_ID}. Only
 the match algorithms supplied will be used to determine whether Views are the
 the same in both the start and end Scene. Views that do not match will be considered
 as entering or leaving the Scene.
 &lt;/p&gt;
@param {Object {int[]}} matches A list of zero or more of {@link #MATCH_INSTANCE},
                {@link #MATCH_NAME}, {@link #MATCH_ITEM_ID}, and {@link #MATCH_ID}.
                If none are provided, then the default match order will be set.
*/
setMatchOrder : function(  ) {},

<span id='android-transition-Transition-method-isValidTarget'>/**Internal utility method for checking whether a given view/id
</span> is valid for this transition, where &quot;valid&quot; means that either
 the Transition has no target/targetId list (the default, in which
 cause the transition should act on all views in the hiearchy), or
 the given view is in the target list or the view id is in the
 targetId list. If the target parameter is null, then the target list
 is not checked (this is in the case of ListView items, where the
 views are ignored and only the ids are used).
@hide 
*/
isValidTarget : function(  ) {},

<span id='android-transition-Transition-method-captureStartValues'>/**Captures the values in the start scene for the properties that this
</span> transition monitors. These values are then passed as the startValues
 structure in a later call to
 {@link #createAnimator(ViewGroup, android.transition.TransitionValues, android.transition.TransitionValues)}.
 The main concern for an implementation is what the
 properties are that the transition cares about and what the values are
 for all of those properties. The start and end values will be compared
 later during the
 {@link #createAnimator(android.view.ViewGroup, android.transition.TransitionValues, android.transition.TransitionValues)}
 method to determine what, if any, animations, should be run.

 &lt;p&gt;Subclasses must implement this method. The method should only be called by the
 transition system; it is not intended to be called from external classes.&lt;/p&gt;
@param {Object {TransitionValues}} transitionValues The holder for any values that the Transition
 wishes to store. Values are stored in the &lt;code&gt;values&lt;/code&gt; field
 of this TransitionValues object and are keyed from
 a String value. For example, to store a view's rotation value,
 a transition might call
 &lt;code&gt;transitionValues.values.put(&quot;appname:transitionname:rotation&quot;,
 view.getRotation())&lt;/code&gt;. The target view will already be stored in
 the transitionValues structure when this method is called.
@see #captureEndValues(TransitionValues)
@see #createAnimator(ViewGroup, TransitionValues, TransitionValues)
*/
captureStartValues : function(  ) {},

<span id='android-transition-Transition-method-captureEndValues'>/**Captures the values in the end scene for the properties that this
</span> transition monitors. These values are then passed as the endValues
 structure in a later call to
 {@link #createAnimator(ViewGroup, android.transition.TransitionValues, android.transition.TransitionValues)}.
 The main concern for an implementation is what the
 properties are that the transition cares about and what the values are
 for all of those properties. The start and end values will be compared
 later during the
 {@link #createAnimator(android.view.ViewGroup, android.transition.TransitionValues, android.transition.TransitionValues)}
 method to determine what, if any, animations, should be run.

 &lt;p&gt;Subclasses must implement this method. The method should only be called by the
 transition system; it is not intended to be called from external classes.&lt;/p&gt;
@param {Object {TransitionValues}} transitionValues The holder for any values that the Transition
 wishes to store. Values are stored in the &lt;code&gt;values&lt;/code&gt; field
 of this TransitionValues object and are keyed from
 a String value. For example, to store a view's rotation value,
 a transition might call
 &lt;code&gt;transitionValues.values.put(&quot;appname:transitionname:rotation&quot;,
 view.getRotation())&lt;/code&gt;. The target view will already be stored in
 the transitionValues structure when this method is called.
@see #captureStartValues(TransitionValues)
@see #createAnimator(ViewGroup, TransitionValues, TransitionValues)
*/
captureEndValues : function(  ) {},

<span id='android-transition-Transition-method-addTarget'>/**Adds the id of a target view that this Transition is interested in
</span> animating. By default, there are no targetIds, and a Transition will
 listen for changes on every view in the hierarchy below the sceneRoot
 of the Scene being transitioned into. Setting targetIds constrains
 the Transition to only listen for, and act on, views with these IDs.
 Views with different IDs, or no IDs whatsoever, will be ignored.

 &lt;p&gt;Note that using ids to specify targets implies that ids should be unique
 within the view hierarchy underneath the scene root.&lt;/p&gt;
@param {Number} targetId The id of a target view, must be a positive number.
@param targetId The id of a target view, must be a positive number.
@return {Object {android.transition.Transition}} The Transition to which the targetId is added.
 Returning the same object makes it easier to chain calls during
 construction, such as
 &lt;code&gt;transitionSet.addTransitions(new Fade()).addTarget(someId);&lt;/code&gt;
*/
addTarget : function(  ) {},

<span id='android-transition-Transition-method-addTarget'>/**Adds the transitionName of a target view that this Transition is interested in
</span> animating. By default, there are no targetNames, and a Transition will
 listen for changes on every view in the hierarchy below the sceneRoot
 of the Scene being transitioned into. Setting targetNames constrains
 the Transition to only listen for, and act on, views with these transitionNames.
 Views with different transitionNames, or no transitionName whatsoever, will be ignored.

 &lt;p&gt;Note that transitionNames should be unique within the view hierarchy.&lt;/p&gt;
@param {String} targetName The transitionName of a target view, must be non-null.
@param targetName The transitionName of a target view, must be non-null.
@return {Object {android.transition.Transition}} The Transition to which the target transitionName is added.
 Returning the same object makes it easier to chain calls during
 construction, such as
 &lt;code&gt;transitionSet.addTransitions(new Fade()).addTarget(someName);&lt;/code&gt;
*/
addTarget : function(  ) {},

<span id='android-transition-Transition-method-addTarget'>/**Adds the Class of a target view that this Transition is interested in
</span> animating. By default, there are no targetTypes, and a Transition will
 listen for changes on every view in the hierarchy below the sceneRoot
 of the Scene being transitioned into. Setting targetTypes constrains
 the Transition to only listen for, and act on, views with these classes.
 Views with different classes will be ignored.

 &lt;p&gt;Note that any View that can be cast to targetType will be included, so
 if targetType is &lt;code&gt;View.class&lt;/code&gt;, all Views will be included.&lt;/p&gt;
@param {Object {java.lang.Class}} targetType The type to include when running this transition.
@see #addTarget(android.view.View)
@see #excludeTarget(Class, boolean)
@see #excludeChildren(Class, boolean)
@param targetType The type to include when running this transition.
@return {Object {android.transition.Transition}} The Transition to which the target class was added.
 Returning the same object makes it easier to chain calls during
 construction, such as
 &lt;code&gt;transitionSet.addTransitions(new Fade()).addTarget(ImageView.class);&lt;/code&gt;
*/
addTarget : function(  ) {},

<span id='android-transition-Transition-method-removeTarget'>/**Removes the given targetId from the list of ids that this Transition
</span> is interested in animating.
@param {Number} targetId The id of a target view, must be a positive number.
@return {Object {android.transition.Transition}} The Transition from which the targetId is removed.
 Returning the same object makes it easier to chain calls during
 construction, such as
 &lt;code&gt;transitionSet.addTransitions(new Fade()).removeTargetId(someId);&lt;/code&gt;
*/
removeTarget : function(  ) {},

<span id='android-transition-Transition-method-removeTarget'>/**Removes the given targetName from the list of transitionNames that this Transition
</span> is interested in animating.
@param {String} targetName The transitionName of a target view, must not be null.
@return {Object {android.transition.Transition}} The Transition from which the targetName is removed.
 Returning the same object makes it easier to chain calls during
 construction, such as
 &lt;code&gt;transitionSet.addTransitions(new Fade()).removeTargetName(someName);&lt;/code&gt;
*/
removeTarget : function(  ) {},

<span id='android-transition-Transition-method-excludeTarget'>/**Whether to add the given id to the list of target ids to exclude from this
</span> transition. The &lt;code&gt;exclude&lt;/code&gt; parameter specifies whether the target
 should be added to or removed from the excluded list.

 &lt;p&gt;Excluding targets is a general mechanism for allowing transitions to run on
 a view hierarchy while skipping target views that should not be part of
 the transition. For example, you may want to avoid animating children
 of a specific ListView or Spinner. Views can be excluded either by their
 id, or by their instance reference, or by the Class of that view
 (eg, {@link Spinner}).&lt;/p&gt;
@param {Number} targetId The id of a target to ignore when running this transition.
@param {Boolean} exclude Whether to add the target to or remove the target from the
 current list of excluded targets.
@see #excludeTarget(Class, boolean)
@param targetId The id of a target to ignore when running this transition.
@param exclude Whether to add the target to or remove the target from the
 current list of excluded targets.
@return {Object {android.transition.Transition}} This transition object.
*/
excludeTarget : function(  ) {},

<span id='android-transition-Transition-method-excludeTarget'>/**Whether to add the given transitionName to the list of target transitionNames to exclude
</span> from this transition. The &lt;code&gt;exclude&lt;/code&gt; parameter specifies whether the target
 should be added to or removed from the excluded list.

 &lt;p&gt;Excluding targets is a general mechanism for allowing transitions to run on
 a view hierarchy while skipping target views that should not be part of
 the transition. For example, you may want to avoid animating children
 of a specific ListView or Spinner. Views can be excluded by their
 id, their instance reference, their transitionName, or by the Class of that view
 (eg, {@link Spinner}).&lt;/p&gt;
@param {String} targetName The name of a target to ignore when running this transition.
@param {Boolean} exclude Whether to add the target to or remove the target from the
 current list of excluded targets.
@see #excludeTarget(Class, boolean)
@param targetName The name of a target to ignore when running this transition.
@param exclude Whether to add the target to or remove the target from the
 current list of excluded targets.
@return {Object {android.transition.Transition}} This transition object.
*/
excludeTarget : function(  ) {},

<span id='android-transition-Transition-method-excludeChildren'>/**Whether to add the children of the given id to the list of targets to exclude
</span> from this transition. The &lt;code&gt;exclude&lt;/code&gt; parameter specifies whether
 the children of the target should be added to or removed from the excluded list.
 Excluding children in this way provides a simple mechanism for excluding all
 children of specific targets, rather than individually excluding each
 child individually.

 &lt;p&gt;Excluding targets is a general mechanism for allowing transitions to run on
 a view hierarchy while skipping target views that should not be part of
 the transition. For example, you may want to avoid animating children
 of a specific ListView or Spinner. Views can be excluded either by their
 id, or by their instance reference, or by the Class of that view
 (eg, {@link Spinner}).&lt;/p&gt;
@param {Number} targetId The id of a target whose children should be ignored when running
 this transition.
@param {Boolean} exclude Whether to add the target to or remove the target from the
 current list of excluded-child targets.
@see #excludeChildren(Class, boolean)
@param targetId The id of a target whose children should be ignored when running
 this transition.
@param exclude Whether to add the target to or remove the target from the
 current list of excluded-child targets.
@return {Object {android.transition.Transition}} This transition object.
*/
excludeChildren : function(  ) {},

<span id='android-transition-Transition-method-excludeTarget'>/**Whether to add the given target to the list of targets to exclude from this
</span> transition. The &lt;code&gt;exclude&lt;/code&gt; parameter specifies whether the target
 should be added to or removed from the excluded list.

 &lt;p&gt;Excluding targets is a general mechanism for allowing transitions to run on
 a view hierarchy while skipping target views that should not be part of
 the transition. For example, you may want to avoid animating children
 of a specific ListView or Spinner. Views can be excluded either by their
 id, or by their instance reference, or by the Class of that view
 (eg, {@link Spinner}).&lt;/p&gt;
@param {Object {View}} target The target to ignore when running this transition.
@param {Boolean} exclude Whether to add the target to or remove the target from the
 current list of excluded targets.
@see #excludeTarget(Class, boolean)
@param target The target to ignore when running this transition.
@param exclude Whether to add the target to or remove the target from the
 current list of excluded targets.
@return {Object {android.transition.Transition}} This transition object.
*/
excludeTarget : function(  ) {},

<span id='android-transition-Transition-method-excludeChildren'>/**Whether to add the children of given target to the list of target children
</span> to exclude from this transition. The &lt;code&gt;exclude&lt;/code&gt; parameter specifies
 whether the target should be added to or removed from the excluded list.

 &lt;p&gt;Excluding targets is a general mechanism for allowing transitions to run on
 a view hierarchy while skipping target views that should not be part of
 the transition. For example, you may want to avoid animating children
 of a specific ListView or Spinner. Views can be excluded either by their
 id, or by their instance reference, or by the Class of that view
 (eg, {@link Spinner}).&lt;/p&gt;
@param {Object {View}} target The target to ignore when running this transition.
@param {Boolean} exclude Whether to add the target to or remove the target from the
 current list of excluded targets.
@see #excludeChildren(Class, boolean)
@param target The target to ignore when running this transition.
@param exclude Whether to add the target to or remove the target from the
 current list of excluded targets.
@return {Object {android.transition.Transition}} This transition object.
*/
excludeChildren : function(  ) {},

<span id='android-transition-Transition-method-excludeTarget'>/**Whether to add the given type to the list of types to exclude from this
</span> transition. The &lt;code&gt;exclude&lt;/code&gt; parameter specifies whether the target
 type should be added to or removed from the excluded list.

 &lt;p&gt;Excluding targets is a general mechanism for allowing transitions to run on
 a view hierarchy while skipping target views that should not be part of
 the transition. For example, you may want to avoid animating children
 of a specific ListView or Spinner. Views can be excluded either by their
 id, or by their instance reference, or by the Class of that view
 (eg, {@link Spinner}).&lt;/p&gt;
@param {Object {java.lang.Class}} type The type to ignore when running this transition.
@param {Boolean} exclude Whether to add the target type to or remove it from the
 current list of excluded target types.
@see #excludeTarget(View, boolean)
@param type The type to ignore when running this transition.
@param exclude Whether to add the target type to or remove it from the
 current list of excluded target types.
@return {Object {android.transition.Transition}} This transition object.
*/
excludeTarget : function(  ) {},

<span id='android-transition-Transition-method-excludeChildren'>/**Whether to add the given type to the list of types whose children should
</span> be excluded from this transition. The &lt;code&gt;exclude&lt;/code&gt; parameter
 specifies whether the target type should be added to or removed from
 the excluded list.

 &lt;p&gt;Excluding targets is a general mechanism for allowing transitions to run on
 a view hierarchy while skipping target views that should not be part of
 the transition. For example, you may want to avoid animating children
 of a specific ListView or Spinner. Views can be excluded either by their
 id, or by their instance reference, or by the Class of that view
 (eg, {@link Spinner}).&lt;/p&gt;
@param {Object {java.lang.Class}} type The type to ignore when running this transition.
@param {Boolean} exclude Whether to add the target type to or remove it from the
 current list of excluded target types.
@see #excludeChildren(View, boolean)
@param type The type to ignore when running this transition.
@param exclude Whether to add the target type to or remove it from the
 current list of excluded target types.
@return {Object {android.transition.Transition}} This transition object.
*/
excludeChildren : function(  ) {},

<span id='android-transition-Transition-method-addTarget'>/**Sets the target view instances that this Transition is interested in
</span> animating. By default, there are no targets, and a Transition will
 listen for changes on every view in the hierarchy below the sceneRoot
 of the Scene being transitioned into. Setting targets constrains
 the Transition to only listen for, and act on, these views.
 All other views will be ignored.

 &lt;p&gt;The target list is like the {@link #addTarget(int) targetId}
 list except this list specifies the actual View instances, not the ids
 of the views. This is an important distinction when scene changes involve
 view hierarchies which have been inflated separately; different views may
 share the same id but not actually be the same instance. If the transition
 should treat those views as the same, then {@link #addTarget}(int) should be used
 instead of {@link #addTarget}(View). If, on the other hand, scene changes involve
 changes all within the same view hierarchy, among views which do not
 necessarily have ids set on them, then the target list of views may be more
 convenient.&lt;/p&gt;
@param {Object {View}} target A View on which the Transition will act, must be non-null.
@param target A View on which the Transition will act, must be non-null.
@return {Object {android.transition.Transition}} The Transition to which the target is added.
 Returning the same object makes it easier to chain calls during
 construction, such as
 &lt;code&gt;transitionSet.addTransitions(new Fade()).addTarget(someView);&lt;/code&gt;
*/
addTarget : function(  ) {},

<span id='android-transition-Transition-method-removeTarget'>/**Removes the given target from the list of targets that this Transition
</span> is interested in animating.
@param {Object {View}} target The target view, must be non-null.
@return {Object {android.transition.Transition}} Transition The Transition from which the target is removed.
 Returning the same object makes it easier to chain calls during
 construction, such as
 &lt;code&gt;transitionSet.addTransitions(new Fade()).removeTarget(someView);&lt;/code&gt;
*/
removeTarget : function(  ) {},

<span id='android-transition-Transition-method-removeTarget'>/**Removes the given target from the list of targets that this Transition
</span> is interested in animating.
@param {Object {java.lang.Class}} target The type of the target view, must be non-null.
@return {Object {android.transition.Transition}} Transition The Transition from which the target is removed.
 Returning the same object makes it easier to chain calls during
 construction, such as
 &lt;code&gt;transitionSet.addTransitions(new Fade()).removeTarget(someType);&lt;/code&gt;
*/
removeTarget : function(  ) {},

<span id='android-transition-Transition-method-getTargetIds'>/**Returns the list of target IDs that this transition limits itself to
</span> tracking and animating. If the list is null or empty for
 {@link #getTargetIds}(), {@link #getTargets}(), {@link #getTargetNames}(), and
 {@link #getTargetTypes}() then this transition is
 not limited to specific views, and will handle changes to any views
 in the hierarchy of a scene change.
@return {Object {java.util.List}} the list of target IDs
*/
getTargetIds : function(  ) {},

<span id='android-transition-Transition-method-getTargets'>/**Returns the list of target views that this transition limits itself to
</span> tracking and animating. If the list is null or empty for
 {@link #getTargetIds}(), {@link #getTargets}(), {@link #getTargetNames}(), and
 {@link #getTargetTypes}() then this transition is
 not limited to specific views, and will handle changes to any views
 in the hierarchy of a scene change.
@return {Object {java.util.List}} the list of target views
*/
getTargets : function(  ) {},

<span id='android-transition-Transition-method-getTargetNames'>/**Returns the list of target transitionNames that this transition limits itself to
</span> tracking and animating. If the list is null or empty for
 {@link #getTargetIds}(), {@link #getTargets}(), {@link #getTargetNames}(), and
 {@link #getTargetTypes}() then this transition is
 not limited to specific views, and will handle changes to any views
 in the hierarchy of a scene change.
@return {Object {java.util.List}} the list of target transitionNames
*/
getTargetNames : function(  ) {},

<span id='android-transition-Transition-method-getTargetViewNames'>/**To be removed before L release.
</span>@hide 
*/
getTargetViewNames : function(  ) {},

<span id='android-transition-Transition-method-getTargetTypes'>/**Returns the list of target transitionNames that this transition limits itself to
</span> tracking and animating. If the list is null or empty for
 {@link #getTargetIds}(), {@link #getTargets}(), {@link #getTargetNames}(), and
 {@link #getTargetTypes}() then this transition is
 not limited to specific views, and will handle changes to any views
 in the hierarchy of a scene change.
@return {Object {java.util.List}} the list of target Types
*/
getTargetTypes : function(  ) {},

<span id='android-transition-Transition-method-getTransitionValues'>/**This method can be called by transitions to get the TransitionValues for
</span> any particular view during the transition-playing process. This might be
 necessary, for example, to query the before/after state of related views
 for a given transition.
*/
getTransitionValues : function(  ) {},

<span id='android-transition-Transition-method-pause'>/**Pauses this transition, sending out calls to {@link android.transition.Transition.TransitionListener#onTransitionPause(Transition)} to all listeners
</span> and pausing all running animators started by this transition.
@hide 
*/
pause : function(  ) {},

<span id='android-transition-Transition-method-resume'>/**Resumes this transition, sending out calls to {@link android.transition.Transition.TransitionListener#onTransitionPause(Transition)} to all listeners
</span> and pausing all running animators started by this transition.
@hide 
*/
resume : function(  ) {},

<span id='android-transition-Transition-method-isTransitionRequired'>/**Returns whether or not the transition should create an Animator, based on the values
</span> captured during {@link #captureStartValues}(TransitionValues) and
 {@link #captureEndValues}(TransitionValues). The default implementation compares the
 property values returned from {@link #getTransitionProperties}(), or all property values if
 {@code getTransitionProperties()} returns null. Subclasses may override this method to
 provide logic more specific to the transition implementation.
@param {Object {TransitionValues}} startValues the values from captureStartValues, This may be {@code null} if the
                    View did not exist in the start state.
@param {Object {TransitionValues}} endValues the values from captureEndValues. This may be {@code null} if the View
                  did not exist in the end state.
*/
isTransitionRequired : function(  ) {},

<span id='android-transition-Transition-method-addListener'>/**Adds a listener to the set of listeners that are sent events through the
</span> life of an animation, such as start, repeat, and end.
@param {Object {Transition.TransitionListener}} listener the listener to be added to the current set of listeners
 for this animation.
@return {Object {android.transition.Transition}} This transition object.
*/
addListener : function(  ) {},

<span id='android-transition-Transition-method-removeListener'>/**Removes a listener from the set listening to this animation.
</span>@param {Object {Transition.TransitionListener}} listener the listener to be removed from the current set of
 listeners for this transition.
@return {Object {android.transition.Transition}} This transition object.
*/
removeListener : function(  ) {},

<span id='android-transition-Transition-method-setEpicenterCallback'>/**Sets the callback to use to find the epicenter of a Transition. A null value indicates
</span> that there is no epicenter in the Transition and onGetEpicenter() will return null.
 Transitions like {@link android.transition.Explode} use a point or Rect to orient
 the direction of travel. This is called the epicenter of the Transition and is
 typically centered on a touched View. The
 {@link android.transition.Transition.EpicenterCallback} allows a Transition to
 dynamically retrieve the epicenter during a Transition.
@param {Object {Transition.EpicenterCallback}} epicenterCallback The callback to use to find the epicenter of the Transition.
*/
setEpicenterCallback : function(  ) {},

<span id='android-transition-Transition-method-getEpicenterCallback'>/**Returns the callback used to find the epicenter of the Transition.
</span> Transitions like {@link android.transition.Explode} use a point or Rect to orient
 the direction of travel. This is called the epicenter of the Transition and is
 typically centered on a touched View. The
 {@link android.transition.Transition.EpicenterCallback} allows a Transition to
 dynamically retrieve the epicenter during a Transition.
@return {Object {android.transition.Transition.EpicenterCallback}} the callback used to find the epicenter of the Transition.
*/
getEpicenterCallback : function(  ) {},

<span id='android-transition-Transition-method-getEpicenter'>/**Returns the epicenter as specified by the
</span> {@link android.transition.Transition.EpicenterCallback} or null if no callback exists.
@return {Object {android.graphics.Rect}} the epicenter as specified by the
 {@link android.transition.Transition.EpicenterCallback} or null if no callback exists.
@see #setEpicenterCallback(android.transition.Transition.EpicenterCallback)
*/
getEpicenter : function(  ) {},

<span id='android-transition-Transition-method-setPathMotion'>/**Sets the algorithm used to calculate two-dimensional interpolation.
</span> &lt;p&gt;
     Transitions such as {@link android.transition.ChangeBounds} move Views, typically
     in a straight path between the start and end positions. Applications that desire to
     have these motions move in a curve can change how Views interpolate in two dimensions
     by extending PathMotion and implementing
     {@link android.transition.PathMotion#getPath(float, float, float, float)}.
 &lt;/p&gt;
 &lt;p&gt;
     When describing in XML, use a nested XML tag for the path motion. It can be one of
     the built-in tags &lt;code&gt;arcMotion&lt;/code&gt; or &lt;code&gt;patternPathMotion&lt;/code&gt; or it can
     be a custom PathMotion using &lt;code&gt;pathMotion&lt;/code&gt; with the &lt;code&gt;class&lt;/code&gt;
     attributed with the fully-described class name. For example:&lt;/p&gt;
 &lt;pre&gt;
 {@code
 &lt;changeBounds&gt;
     &lt;pathMotion class=&quot;my.app.transition.MyPathMotion&quot;/&gt;
 &lt;/changeBounds&gt;
 }
 &lt;/pre&gt;
 &lt;p&gt;or&lt;/p&gt;
 &lt;pre&gt;
 {@code
 &lt;changeBounds&gt;
   &lt;arcMotion android:minimumHorizontalAngle=&quot;15&quot;
     android:minimumVerticalAngle=&quot;0&quot; android:maximumAngle=&quot;90&quot;/&gt;
 &lt;/changeBounds&gt;
 }
 &lt;/pre&gt;
@param {Object {PathMotion}} pathMotion Algorithm object to use for determining how to interpolate in two
                   dimensions. If null, a straight-path algorithm will be used.
@see android.transition.ArcMotion
@see PatternPathMotion
@see android.transition.PathMotion
*/
setPathMotion : function(  ) {},

<span id='android-transition-Transition-method-getPathMotion'>/**Returns the algorithm object used to interpolate along two dimensions. This is typically
</span> used to determine the View motion between two points.

 &lt;p&gt;
     When describing in XML, use a nested XML tag for the path motion. It can be one of
     the built-in tags &lt;code&gt;arcMotion&lt;/code&gt; or &lt;code&gt;patternPathMotion&lt;/code&gt; or it can
     be a custom PathMotion using &lt;code&gt;pathMotion&lt;/code&gt; with the &lt;code&gt;class&lt;/code&gt;
     attributed with the fully-described class name. For example:&lt;/p&gt;
 &lt;pre&gt;{@code
 &lt;changeBounds&gt;
     &lt;pathMotion class=&quot;my.app.transition.MyPathMotion&quot;/&gt;
 &lt;/changeBounds&gt;}
 &lt;/pre&gt;
 &lt;p&gt;or&lt;/p&gt;
 &lt;pre&gt;{@code
 &lt;changeBounds&gt;
   &lt;arcMotion android:minimumHorizontalAngle=&quot;15&quot;
              android:minimumVerticalAngle=&quot;0&quot;
              android:maximumAngle=&quot;90&quot;/&gt;
 &lt;/changeBounds&gt;}
 &lt;/pre&gt;
@return {Object {android.transition.PathMotion}} The algorithm object used to interpolate along two dimensions.
@see android.transition.ArcMotion
@see PatternPathMotion
@see android.transition.PathMotion
*/
getPathMotion : function(  ) {},

<span id='android-transition-Transition-method-setPropagation'>/**Sets the method for determining Animator start delays.
</span> When a Transition affects several Views like {@link android.transition.Explode} or
 {@link android.transition.Slide}, there may be a desire to have a &quot;wave-front&quot; effect
 such that the Animator start delay depends on position of the View. The
 TransitionPropagation specifies how the start delays are calculated.
@param {Object {TransitionPropagation}} transitionPropagation The class used to determine the start delay of
                              Animators created by this Transition. A null value
                              indicates that no delay should be used.
*/
setPropagation : function(  ) {},

<span id='android-transition-Transition-method-getPropagation'>/**Returns the {@link android.transition.TransitionPropagation} used to calculate Animator start
</span> delays.
 When a Transition affects several Views like {@link android.transition.Explode} or
 {@link android.transition.Slide}, there may be a desire to have a &quot;wave-front&quot; effect
 such that the Animator start delay depends on position of the View. The
 TransitionPropagation specifies how the start delays are calculated.
@return {Object {android.transition.TransitionPropagation}} the {@link android.transition.TransitionPropagation} used to calculate Animator start
 delays. This is null by default.
*/
getPropagation : function(  ) {},

<span id='android-transition-Transition-method-canRemoveViews'>/**
</span>*/
canRemoveViews : function(  ) {},

<span id='android-transition-Transition-method-setNameOverrides'>/**Sets the shared element names -- a mapping from a name at the start state to
</span> a different name at the end state.
@hide 
*/
setNameOverrides : function(  ) {},

<span id='android-transition-Transition-method-getNameOverrides'>/**
</span>@hide 
*/
getNameOverrides : function(  ) {},

<span id='android-transition-Transition-method-toString'>/**
</span>*/
toString : function(  ) {},

<span id='android-transition-Transition-method-clone'>/**
</span>*/
clone : function(  ) {},

<span id='android-transition-Transition-method-getName'>/**Returns the name of this Transition. This name is used internally to distinguish
</span> between different transitions to determine when interrupting transitions overlap.
 For example, a ChangeBounds running on the same target view as another ChangeBounds
 should determine whether the old transition is animating to different end values
 and should be canceled in favor of the new transition.

 &lt;p&gt;By default, a Transition's name is simply the value of {@link Class#getName()},
 but subclasses are free to override and return something different.&lt;/p&gt;
@return {String} The name of this transition.
*/
getName : function(  ) {},


};</pre>
</body>
</html>
