<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='android-app-admin-DelegatedAdminReceiver'>/**@class android.app.admin.DelegatedAdminReceiver
</span>@extends android.content.BroadcastReceiver

 Base class for delegated apps to handle callbacks related to their delegated capabilities.

 &lt;p&gt;Delegated apps are apps that receive additional capabilities from the profile owner or
 device owner apps. Some of these capabilities involve the framework calling into the apps.
 To receive these callbacks, delegated apps should subclass this class and override the
 appropriate methods here. The subclassed receiver needs to be published in the app's
 manifest, with appropriate intent filters to mark which callbacks the receiver is interested
 in. An app can have multiple receivers as long as they listen for disjoint set of callbacks.
 For the manifest definitions, it must be protected by the
 {@link android.Manifest.permission#BIND_DEVICE_ADMIN} permission to ensure only
 the system can trigger these callbacks.

 &lt;p&gt;The callback methods happen on the main thread of the process.  Thus long running
 operations must be done on another thread.  Note that because a receiver
 is done once returning from its onReceive function, such long-running operations
 should probably be done in a {@link Service}.

 @see DevicePolicyManager#setDelegatedScopes
 @see DeviceAdminReceiver
*/
var DelegatedAdminReceiver = {

<span id='android-app-admin-DelegatedAdminReceiver-method-onChoosePrivateKeyAlias'>/**Allows this receiver to select the alias for a private key and certificate pair for
</span> authentication.  If this method returns null, the default {@link android.app.Activity} will
 be shown that lets the user pick a private key and certificate pair.

 &lt;p&gt; This callback is only applicable if the delegated app has
 {@link android.app.admin.DevicePolicyManager#DELEGATION_CERT_SELECTION} capability. Additionally, it must
 declare an intent filter for {@link android.app.admin.DeviceAdminReceiver#ACTION_CHOOSE_PRIVATE_KEY_ALIAS}
 in the receiver's manifest in order to receive this callback. The default implementation
 simply throws {@link UnsupportedOperationException}.
@param {Object {Context}} context The running context as per {@link #onReceive}.
@param {Object {Intent}} intent The received intent as per {@link #onReceive}.
@param {Number} uid The uid of the app asking for the private key and certificate pair.
@param {Object {Uri}} uri The URI to authenticate, may be null.
@param {String} alias The alias preselected by the client, or null.
@return {String} The private key alias to return and grant access to.
@see KeyChain#choosePrivateKeyAlias
*/
onChoosePrivateKeyAlias : function(  ) {},

<span id='android-app-admin-DelegatedAdminReceiver-method-onNetworkLogsAvailable'>/**Called each time a new batch of network logs can be retrieved. This callback method will only
</span> ever be called when network logging is enabled. The logs can only be retrieved while network
 logging is enabled.

 &lt;p&gt;If a secondary user or profile is created, this callback won't be received until all users
 become affiliated again (even if network logging is enabled). It will also no longer be
 possible to retrieve the network logs batch with the most recent {@code batchToken} provided
 by this callback. See {@link android.app.admin.DevicePolicyManager#setAffiliationIds}.

 &lt;p&gt; This callback is only applicable if the delegated app has
 {@link android.app.admin.DevicePolicyManager#DELEGATION_NETWORK_LOGGING} capability. Additionally, it must
 declare an intent filter for {@link android.app.admin.DeviceAdminReceiver#ACTION_NETWORK_LOGS_AVAILABLE} in the
 receiver's manifest in order to receive this callback. The default implementation
 simply throws {@link UnsupportedOperationException}.
@param {Object {Context}} context The running context as per {@link #onReceive}.
@param {Object {Intent}} intent The received intent as per {@link #onReceive}.
@param {Number} batchToken The token representing the current batch of network logs.
@param {Number} networkLogsCount The total count of events in the current batch of network logs.
@see DevicePolicyManager#retrieveNetworkLogs
*/
onNetworkLogsAvailable : function(  ) {},

<span id='android-app-admin-DelegatedAdminReceiver-method-onReceive'>/**Intercept delegated device administrator broadcasts. Implementations should not override
</span> this method; implement the convenience callbacks for each action instead.
*/
onReceive : function(  ) {},


};</pre>
</body>
</html>
