<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='java-time-chrono-ChronoZonedDateTime'>/**@class java.time.chrono.ChronoZonedDateTime
</span> implements java.time.temporal.Temporal

 implements java.lang.Comparable

 A date-time with a time-zone in an arbitrary chronology,
 intended for advanced globalization use cases.
 &lt;p&gt;
 &lt;b&gt;Most applications should declare method signatures, fields and variables
 as {@link ZonedDateTime}, not this interface.&lt;/b&gt;
 &lt;p&gt;
 A {@code ChronoZonedDateTime} is the abstract representation of an offset date-time
 where the {@code Chronology chronology}, or calendar system, is pluggable.
 The date-time is defined in terms of fields expressed by {@link TemporalField},
 where most common implementations are defined in {@link ChronoField}.
 The chronology defines how the calendar system operates and the meaning of
 the standard fields.

 &lt;h3&gt;When to use this interface&lt;/h3&gt;
 The design of the API encourages the use of {@code ZonedDateTime} rather than this
 interface, even in the case where the application needs to deal with multiple
 calendar systems. The rationale for this is explored in detail in {@link java.time.chrono.ChronoLocalDate}.
 &lt;p&gt;
 Ensure that the discussion in {@code ChronoLocalDate} has been read and understood
 before using this interface.

 @implSpec
 This interface must be implemented with care to ensure other classes operate correctly.
 All implementations that can be instantiated must be final, immutable and thread-safe.
 Subclasses should be Serializable wherever possible.

 @param &lt;D&gt; the concrete type for the date of this date-time
 @since 1.8
*/
var ChronoZonedDateTime = {

<span id='java-time-chrono-ChronoZonedDateTime-method-timeLineOrder'>/**Gets a comparator that compares {@code ChronoZonedDateTime} in
</span> time-line order ignoring the chronology.
 &lt;p&gt;
 This comparator differs from the comparison in {@link #compareTo} in that it
 only compares the underlying instant and not the chronology.
 This allows dates in different calendar systems to be compared based
 on the position of the date-time on the instant time-line.
 The underlying comparison is equivalent to comparing the epoch-second and nano-of-second.
@return {Object {java.util.Comparator}} a comparator that compares in time-line order ignoring the chronology
@see #isAfter
@see #isBefore
@see #isEqual
*/
timeLineOrder : function(  ) {},

<span id='java-time-chrono-ChronoZonedDateTime-method-from'>/**Obtains an instance of {@code ChronoZonedDateTime} from a temporal object.
</span> &lt;p&gt;
 This creates a zoned date-time based on the specified temporal.
 A {@code TemporalAccessor} represents an arbitrary set of date and time information,
 which this factory converts to an instance of {@code ChronoZonedDateTime}.
 &lt;p&gt;
 The conversion extracts and combines the chronology, date, time and zone
 from the temporal object. The behavior is equivalent to using
 {@link java.time.chrono.Chronology#zonedDateTime(TemporalAccessor)} with the extracted chronology.
 Implementations are permitted to perform optimizations such as accessing
 those fields that are equivalent to the relevant objects.
 &lt;p&gt;
 This method matches the signature of the functional interface {@link TemporalQuery}
 allowing it to be used as a query via method reference, {@code ChronoZonedDateTime::from}.
@param {Object {TemporalAccessor}} temporal  the temporal object to convert, not null
@return {Object {java.time.chrono.ChronoZonedDateTime}} the date-time, not null
@throws DateTimeException if unable to convert to a {@code ChronoZonedDateTime}
@see Chronology#zonedDateTime(TemporalAccessor)
*/
from : function(  ) {},

<span id='java-time-chrono-ChronoZonedDateTime-method-range'>/**
</span>*/
range : function(  ) {},

<span id='java-time-chrono-ChronoZonedDateTime-method-get'>/**
</span>*/
get : function(  ) {},

<span id='java-time-chrono-ChronoZonedDateTime-method-getLong'>/**
</span>*/
getLong : function(  ) {},

<span id='java-time-chrono-ChronoZonedDateTime-method-toLocalDate'>/**Gets the local date part of this date-time.
</span> &lt;p&gt;
 This returns a local date with the same year, month and day
 as this date-time.
@return {Object {java.time.chrono.ChronoLocalDate}} the date part of this date-time, not null
*/
toLocalDate : function(  ) {},

<span id='java-time-chrono-ChronoZonedDateTime-method-toLocalTime'>/**Gets the local time part of this date-time.
</span> &lt;p&gt;
 This returns a local time with the same hour, minute, second and
 nanosecond as this date-time.
@return {Object {java.time.LocalTime}} the time part of this date-time, not null
*/
toLocalTime : function(  ) {},

<span id='java-time-chrono-ChronoZonedDateTime-method-toLocalDateTime'>/**Gets the local date-time part of this date-time.
</span> &lt;p&gt;
 This returns a local date with the same year, month and day
 as this date-time.
@return {Object {java.time.chrono.ChronoLocalDateTime}} the local date-time part of this date-time, not null
*/
toLocalDateTime : function(  ) {},

<span id='java-time-chrono-ChronoZonedDateTime-method-getChronology'>/**Gets the chronology of this date-time.
</span> &lt;p&gt;
 The {@code Chronology} represents the calendar system in use.
 The era and other fields in {@link ChronoField} are defined by the chronology.
@return {Object {java.time.chrono.Chronology}} the chronology, not null
*/
getChronology : function(  ) {},

<span id='java-time-chrono-ChronoZonedDateTime-method-getOffset'>/**Gets the zone offset, such as '+01:00'.
</span> &lt;p&gt;
 This is the offset of the local date-time from UTC/Greenwich.
@return {Object {java.time.ZoneOffset}} the zone offset, not null
*/
getOffset : function(  ) {},

<span id='java-time-chrono-ChronoZonedDateTime-method-getZone'>/**Gets the zone ID, such as 'Europe/Paris'.
</span> &lt;p&gt;
 This returns the stored time-zone id used to determine the time-zone rules.
@return {Object {java.time.ZoneId}} the zone ID, not null
*/
getZone : function(  ) {},

<span id='java-time-chrono-ChronoZonedDateTime-method-withEarlierOffsetAtOverlap'>/**Returns a copy of this date-time changing the zone offset to the
</span> earlier of the two valid offsets at a local time-line overlap.
 &lt;p&gt;
 This method only has any effect when the local time-line overlaps, such as
 at an autumn daylight savings cutover. In this scenario, there are two
 valid offsets for the local date-time. Calling this method will return
 a zoned date-time with the earlier of the two selected.
 &lt;p&gt;
 If this method is called when it is not an overlap, {@code this}
 is returned.
 &lt;p&gt;
 This instance is immutable and unaffected by this method call.
@return {Object {java.time.chrono.ChronoZonedDateTime}} a {@code ChronoZonedDateTime} based on this date-time with the earlier offset, not null
@throws DateTimeException if no rules can be found for the zone
@throws DateTimeException if no rules are valid for this date-time
*/
withEarlierOffsetAtOverlap : function(  ) {},

<span id='java-time-chrono-ChronoZonedDateTime-method-withLaterOffsetAtOverlap'>/**Returns a copy of this date-time changing the zone offset to the
</span> later of the two valid offsets at a local time-line overlap.
 &lt;p&gt;
 This method only has any effect when the local time-line overlaps, such as
 at an autumn daylight savings cutover. In this scenario, there are two
 valid offsets for the local date-time. Calling this method will return
 a zoned date-time with the later of the two selected.
 &lt;p&gt;
 If this method is called when it is not an overlap, {@code this}
 is returned.
 &lt;p&gt;
 This instance is immutable and unaffected by this method call.
@return {Object {java.time.chrono.ChronoZonedDateTime}} a {@code ChronoZonedDateTime} based on this date-time with the later offset, not null
@throws DateTimeException if no rules can be found for the zone
@throws DateTimeException if no rules are valid for this date-time
*/
withLaterOffsetAtOverlap : function(  ) {},

<span id='java-time-chrono-ChronoZonedDateTime-method-withZoneSameLocal'>/**Returns a copy of this date-time with a different time-zone,
</span> retaining the local date-time if possible.
 &lt;p&gt;
 This method changes the time-zone and retains the local date-time.
 The local date-time is only changed if it is invalid for the new zone.
 &lt;p&gt;
 To change the zone and adjust the local date-time,
 use {@link #withZoneSameInstant}(ZoneId).
 &lt;p&gt;
 This instance is immutable and unaffected by this method call.
@param {Object {ZoneId}} zone  the time-zone to change to, not null
@return {Object {java.time.chrono.ChronoZonedDateTime}} a {@code ChronoZonedDateTime} based on this date-time with the requested zone, not null
*/
withZoneSameLocal : function(  ) {},

<span id='java-time-chrono-ChronoZonedDateTime-method-withZoneSameInstant'>/**Returns a copy of this date-time with a different time-zone,
</span> retaining the instant.
 &lt;p&gt;
 This method changes the time-zone and retains the instant.
 This normally results in a change to the local date-time.
 &lt;p&gt;
 This method is based on retaining the same instant, thus gaps and overlaps
 in the local time-line have no effect on the result.
 &lt;p&gt;
 To change the offset while keeping the local time,
 use {@link #withZoneSameLocal}(ZoneId).
@param {Object {ZoneId}} zone  the time-zone to change to, not null
@return {Object {java.time.chrono.ChronoZonedDateTime}} a {@code ChronoZonedDateTime} based on this date-time with the requested zone, not null
@throws DateTimeException if the result exceeds the supported date range
*/
withZoneSameInstant : function(  ) {},

<span id='java-time-chrono-ChronoZonedDateTime-method-isSupported'>/**Checks if the specified field is supported.
</span> &lt;p&gt;
 This checks if the specified field can be queried on this date-time.
 If false, then calling the {@link #range(TemporalField) range},
 {@link #get(TemporalField) get} and {@link #with(TemporalField, long)}
 methods will throw an exception.
 &lt;p&gt;
 The set of supported fields is defined by the chronology and normally includes
 all {@code ChronoField} fields.
 &lt;p&gt;
 If the field is not a {@code ChronoField}, then the result of this method
 is obtained by invoking {@code TemporalField.isSupportedBy(TemporalAccessor)}
 passing {@code this} as the argument.
 Whether the field is supported is determined by the field.
@param {Object {TemporalField}} field  the field to check, null returns false
@return {Boolean} true if the field can be queried, false if not
*/
isSupported : function(  ) {},

<span id='java-time-chrono-ChronoZonedDateTime-method-isSupported'>/**Checks if the specified unit is supported.
</span> &lt;p&gt;
 This checks if the specified unit can be added to or subtracted from this date-time.
 If false, then calling the {@link #plus(long, TemporalUnit)} and
 {@link #minus(long, TemporalUnit) minus} methods will throw an exception.
 &lt;p&gt;
 The set of supported units is defined by the chronology and normally includes
 all {@code ChronoUnit} units except {@code FOREVER}.
 &lt;p&gt;
 If the unit is not a {@code ChronoUnit}, then the result of this method
 is obtained by invoking {@code TemporalUnit.isSupportedBy(Temporal)}
 passing {@code this} as the argument.
 Whether the unit is supported is determined by the unit.
@param {Object {TemporalUnit}} unit  the unit to check, null returns false
@return {Boolean} true if the unit can be added/subtracted, false if not
*/
isSupported : function(  ) {},

<span id='java-time-chrono-ChronoZonedDateTime-method-with'>/**{@inheritDoc}
</span>@throws DateTimeException {@inheritDoc}
@throws ArithmeticException {@inheritDoc}
*/
with : function(  ) {},

<span id='java-time-chrono-ChronoZonedDateTime-method-with'>/**{@inheritDoc}
</span>@throws DateTimeException {@inheritDoc}
@throws ArithmeticException {@inheritDoc}
*/
with : function(  ) {},

<span id='java-time-chrono-ChronoZonedDateTime-method-plus'>/**{@inheritDoc}
</span>@throws DateTimeException {@inheritDoc}
@throws ArithmeticException {@inheritDoc}
*/
plus : function(  ) {},

<span id='java-time-chrono-ChronoZonedDateTime-method-plus'>/**{@inheritDoc}
</span>@throws DateTimeException {@inheritDoc}
@throws ArithmeticException {@inheritDoc}
*/
plus : function(  ) {},

<span id='java-time-chrono-ChronoZonedDateTime-method-minus'>/**{@inheritDoc}
</span>@throws DateTimeException {@inheritDoc}
@throws ArithmeticException {@inheritDoc}
*/
minus : function(  ) {},

<span id='java-time-chrono-ChronoZonedDateTime-method-minus'>/**{@inheritDoc}
</span>@throws DateTimeException {@inheritDoc}
@throws ArithmeticException {@inheritDoc}
*/
minus : function(  ) {},

<span id='java-time-chrono-ChronoZonedDateTime-method-query'>/**Queries this date-time using the specified query.
</span> &lt;p&gt;
 This queries this date-time using the specified query strategy object.
 The {@code TemporalQuery} object defines the logic to be used to
 obtain the result. Read the documentation of the query to understand
 what the result of this method will be.
 &lt;p&gt;
 The result of this method is obtained by invoking the
 {@link TemporalQuery#queryFrom(TemporalAccessor)} method on the
 specified query passing {@code this} as the argument.
@param {Object {java.time.temporal.TemporalQuery}} query  the query to invoke, not null
@param query  the query to invoke, not null
@return {Object {java.lang.Object}} the query result, null may be returned (defined by the query)
@throws DateTimeException if unable to query (defined by the query)
@throws ArithmeticException if numeric overflow occurs (defined by the query)
*/
query : function(  ) {},

<span id='java-time-chrono-ChronoZonedDateTime-method-format'>/**Formats this date-time using the specified formatter.
</span> &lt;p&gt;
 This date-time will be passed to the formatter to produce a string.
 &lt;p&gt;
 The default implementation must behave as follows:
 &lt;pre&gt;
  return formatter.format(this);
 &lt;/pre&gt;
@param {Object {DateTimeFormatter}} formatter  the formatter to use, not null
@return {String} the formatted date-time string, not null
@throws DateTimeException if an error occurs during printing
*/
format : function(  ) {},

<span id='java-time-chrono-ChronoZonedDateTime-method-toInstant'>/**Converts this date-time to an {@code Instant}.
</span> &lt;p&gt;
 This returns an {@code Instant} representing the same point on the
 time-line as this date-time. The calculation combines the
 {@linkplain #toLocalDateTime() local date-time} and
 {@linkplain #getOffset() offset}.
@return {Object {java.time.Instant}} an {@code Instant} representing the same instant, not null
*/
toInstant : function(  ) {},

<span id='java-time-chrono-ChronoZonedDateTime-method-toEpochSecond'>/**Converts this date-time to the number of seconds from the epoch
</span> of 1970-01-01T00:00:00Z.
 &lt;p&gt;
 This uses the {@linkplain #toLocalDateTime() local date-time} and
 {@linkplain #getOffset() offset} to calculate the epoch-second value,
 which is the number of elapsed seconds from 1970-01-01T00:00:00Z.
 Instants on the time-line after the epoch are positive, earlier are negative.
@return {Number} the number of seconds from the epoch of 1970-01-01T00:00:00Z
*/
toEpochSecond : function(  ) {},

<span id='java-time-chrono-ChronoZonedDateTime-method-compareTo'>/**Compares this date-time to another date-time, including the chronology.
</span> &lt;p&gt;
 The comparison is based first on the instant, then on the local date-time,
 then on the zone ID, then on the chronology.
 It is &quot;consistent with equals&quot;, as defined by {@link Comparable}.
 &lt;p&gt;
 If all the date-time objects being compared are in the same chronology, then the
 additional chronology stage is not required.
 &lt;p&gt;
 This default implementation performs the comparison defined above.
@param {Object {java.time.chrono.ChronoZonedDateTime}} other  the other date-time to compare to, not null
@return {Number} the comparator value, negative if less, positive if greater
*/
compareTo : function(  ) {},

<span id='java-time-chrono-ChronoZonedDateTime-method-isBefore'>/**Checks if the instant of this date-time is before that of the specified date-time.
</span> &lt;p&gt;
 This method differs from the comparison in {@link #compareTo} in that it
 only compares the instant of the date-time. This is equivalent to using
 {@code dateTime1.toInstant().isBefore(dateTime2.toInstant());}.
 &lt;p&gt;
 This default implementation performs the comparison based on the epoch-second
 and nano-of-second.
@param {Object {java.time.chrono.ChronoZonedDateTime}} other  the other date-time to compare to, not null
@return {Boolean} true if this point is before the specified date-time
*/
isBefore : function(  ) {},

<span id='java-time-chrono-ChronoZonedDateTime-method-isAfter'>/**Checks if the instant of this date-time is after that of the specified date-time.
</span> &lt;p&gt;
 This method differs from the comparison in {@link #compareTo} in that it
 only compares the instant of the date-time. This is equivalent to using
 {@code dateTime1.toInstant().isAfter(dateTime2.toInstant());}.
 &lt;p&gt;
 This default implementation performs the comparison based on the epoch-second
 and nano-of-second.
@param {Object {java.time.chrono.ChronoZonedDateTime}} other  the other date-time to compare to, not null
@return {Boolean} true if this is after the specified date-time
*/
isAfter : function(  ) {},

<span id='java-time-chrono-ChronoZonedDateTime-method-isEqual'>/**Checks if the instant of this date-time is equal to that of the specified date-time.
</span> &lt;p&gt;
 This method differs from the comparison in {@link #compareTo} and {@link #equals}
 in that it only compares the instant of the date-time. This is equivalent to using
 {@code dateTime1.toInstant().equals(dateTime2.toInstant());}.
 &lt;p&gt;
 This default implementation performs the comparison based on the epoch-second
 and nano-of-second.
@param {Object {java.time.chrono.ChronoZonedDateTime}} other  the other date-time to compare to, not null
@return {Boolean} true if the instant equals the instant of the specified date-time
*/
isEqual : function(  ) {},

<span id='java-time-chrono-ChronoZonedDateTime-method-equals'>/**Checks if this date-time is equal to another date-time.
</span> &lt;p&gt;
 The comparison is based on the offset date-time and the zone.
 To compare for the same instant on the time-line, use {@link #compareTo}.
 Only objects of type {@code ChronoZonedDateTime} are compared, other types return false.
@param {Object {Object}} obj  the object to check, null returns false
@return {Boolean} true if this is equal to the other date-time
*/
equals : function(  ) {},

<span id='java-time-chrono-ChronoZonedDateTime-method-hashCode'>/**A hash code for this date-time.
</span>@return {Number} a suitable hash code
*/
hashCode : function(  ) {},

<span id='java-time-chrono-ChronoZonedDateTime-method-toString'>/**Outputs this date-time as a {@code String}.
</span> &lt;p&gt;
 The output will include the full zoned date-time.
@return {String} a string representation of this date-time, not null
*/
toString : function(  ) {},


};</pre>
</body>
</html>
