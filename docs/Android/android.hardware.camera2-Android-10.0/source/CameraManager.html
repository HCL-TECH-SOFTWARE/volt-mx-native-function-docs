<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='android-hardware-camera2-CameraManager'>/**@class android.hardware.camera2.CameraManager
</span>@extends java.lang.Object

 &lt;p&gt;A system service manager for detecting, characterizing, and connecting to
 {@link android.hardware.camera2.CameraDevice android.hardware.camera2.CameraDevices}.&lt;/p&gt;

 &lt;p&gt;For more details about communicating with camera devices, read the Camera
 developer guide or the {@link android.hardware.camera2 camera2}
 package documentation.&lt;/p&gt;
*/
var CameraManager = {

<span id='android-hardware-camera2-CameraManager-method-getCameraIdList'>/**Return the list of currently connected camera devices by identifier, including
</span> cameras that may be in use by other camera API clients.

 &lt;p&gt;Non-removable cameras use integers starting at 0 for their
 identifiers, while removable cameras have a unique identifier for each
 individual device, even if they are the same model.&lt;/p&gt;

 &lt;p&gt;This list doesn't contain physical cameras that can only be used as part of a logical
 multi-camera device.&lt;/p&gt;
@return {String} The list of currently connected camera devices.
*/
getCameraIdList : function(  ) {},

<span id='android-hardware-camera2-CameraManager-method-registerAvailabilityCallback'>/**Register a callback to be notified about camera device availability.
</span>
 &lt;p&gt;Registering the same callback again will replace the handler with the
 new one provided.&lt;/p&gt;

 &lt;p&gt;The first time a callback is registered, it is immediately called
 with the availability status of all currently known camera devices.&lt;/p&gt;

 &lt;p&gt;{@link android.hardware.camera2.CameraManager.AvailabilityCallback#onCameraUnavailable(String)} will be called whenever a camera
 device is opened by any camera API client. As of API level 23, other camera API clients may
 still be able to open such a camera device, evicting the existing client if they have higher
 priority than the existing client of a camera device. See open() for more details.&lt;/p&gt;

 &lt;p&gt;Since this callback will be registered with the camera service, remember to unregister it
 once it is no longer needed; otherwise the callback will continue to receive events
 indefinitely and it may prevent other resources from being released. Specifically, the
 callbacks will be invoked independently of the general activity lifecycle and independently
 of the state of individual CameraManager instances.&lt;/p&gt;
@param {Object {CameraManager.AvailabilityCallback}} callback the new callback to send camera availability notices to
@param {Object {Handler}} handler The handler on which the callback should be invoked, or {@code null} to use
             the current thread's {@link android.os.Looper looper}.
@throws IllegalArgumentException if the handler is {@code null} but the current thread has
             no looper.
*/
registerAvailabilityCallback : function(  ) {},

<span id='android-hardware-camera2-CameraManager-method-registerAvailabilityCallback'>/**Register a callback to be notified about camera device availability.
</span>
 &lt;p&gt;The behavior of this method matches that of
 {@link #registerAvailabilityCallback(AvailabilityCallback, Handler)},
 except that it uses {@link java.util.concurrent.Executor} as an argument
 instead of {@link android.os.Handler}.&lt;/p&gt;
@param {Object {Executor}} executor The executor which will be used to invoke the callback.
@param {Object {CameraManager.AvailabilityCallback}} callback the new callback to send camera availability notices to
@throws IllegalArgumentException if the executor is {@code null}.
*/
registerAvailabilityCallback : function(  ) {},

<span id='android-hardware-camera2-CameraManager-method-unregisterAvailabilityCallback'>/**Remove a previously-added callback; the callback will no longer receive connection and
</span> disconnection callbacks.

 &lt;p&gt;Removing a callback that isn't registered has no effect.&lt;/p&gt;
@param {Object {CameraManager.AvailabilityCallback}} callback The callback to remove from the notification list
*/
unregisterAvailabilityCallback : function(  ) {},

<span id='android-hardware-camera2-CameraManager-method-registerTorchCallback'>/**Register a callback to be notified about torch mode status.
</span>
 &lt;p&gt;Registering the same callback again will replace the handler with the
 new one provided.&lt;/p&gt;

 &lt;p&gt;The first time a callback is registered, it is immediately called
 with the torch mode status of all currently known camera devices with a flash unit.&lt;/p&gt;

 &lt;p&gt;Since this callback will be registered with the camera service, remember to unregister it
 once it is no longer needed; otherwise the callback will continue to receive events
 indefinitely and it may prevent other resources from being released. Specifically, the
 callbacks will be invoked independently of the general activity lifecycle and independently
 of the state of individual CameraManager instances.&lt;/p&gt;
@param {Object {CameraManager.TorchCallback}} callback The new callback to send torch mode status to
@param {Object {Handler}} handler The handler on which the callback should be invoked, or {@code null} to use
             the current thread's {@link android.os.Looper looper}.
@throws IllegalArgumentException if the handler is {@code null} but the current thread has
             no looper.
*/
registerTorchCallback : function(  ) {},

<span id='android-hardware-camera2-CameraManager-method-registerTorchCallback'>/**Register a callback to be notified about torch mode status.
</span>
 &lt;p&gt;The behavior of this method matches that of
 {@link #registerTorchCallback(TorchCallback, Handler)},
 except that it uses {@link java.util.concurrent.Executor} as an argument
 instead of {@link android.os.Handler}.&lt;/p&gt;
@param {Object {Executor}} executor The executor which will be used to invoke the callback
@param {Object {CameraManager.TorchCallback}} callback The new callback to send torch mode status to
@throws IllegalArgumentException if the executor is {@code null}.
*/
registerTorchCallback : function(  ) {},

<span id='android-hardware-camera2-CameraManager-method-unregisterTorchCallback'>/**Remove a previously-added callback; the callback will no longer receive torch mode status
</span> callbacks.

 &lt;p&gt;Removing a callback that isn't registered has no effect.&lt;/p&gt;
@param {Object {CameraManager.TorchCallback}} callback The callback to remove from the notification list
*/
unregisterTorchCallback : function(  ) {},

<span id='android-hardware-camera2-CameraManager-method-getCameraCharacteristics'>/**&lt;p&gt;Query the capabilities of a camera device. These capabilities are
</span> immutable for a given camera.&lt;/p&gt;

 &lt;p&gt;From API level 29, this function can also be used to query the capabilities of physical
 cameras that can only be used as part of logical multi-camera. These cameras cannot be
 opened directly via {@link #openCamera}&lt;/p&gt;
@param {String} cameraId The id of the camera device to query. This could be either a standalone
 camera ID which can be directly opened by {@link #openCamera}, or a physical camera ID that
 can only used as part of a logical multi-camera.
@return {Object {android.hardware.camera2.CameraCharacteristics}} The properties of the given camera
@throws IllegalArgumentException if the cameraId does not match any
         known camera device.
@throws CameraAccessException if the camera device has been disconnected.
@see #getCameraIdList
@see android.app.admin.DevicePolicyManager#setCameraDisabled
*/
getCameraCharacteristics : function(  ) {},

<span id='android-hardware-camera2-CameraManager-method-openCamera'>/**Open a connection to a camera with the given ID.
</span>
 &lt;p&gt;Use {@link #getCameraIdList} to get the list of available camera
 devices. Note that even if an id is listed, open may fail if the device
 is disconnected between the calls to {@link #getCameraIdList} and
 {@link #openCamera}, or if a higher-priority camera API client begins using the
 camera device.&lt;/p&gt;

 &lt;p&gt;As of API level 23, devices for which the
 {@link android.hardware.camera2.CameraManager.AvailabilityCallback#onCameraUnavailable(String)} callback has been called due to the
 device being in use by a lower-priority, background camera API client can still potentially
 be opened by calling this method when the calling camera API client has a higher priority
 than the current camera API client using this device.  In general, if the top, foreground
 activity is running within your application process, your process will be given the highest
 priority when accessing the camera, and this method will succeed even if the camera device is
 in use by another camera API client. Any lower-priority application that loses control of the
 camera in this way will receive an
 {@link android.hardware.camera2.CameraDevice.StateCallback#onDisconnected} callback.&lt;/p&gt;

 &lt;p&gt;Once the camera is successfully opened, {@link android.hardware.camera2.CameraDevice.StateCallback#onOpened} will
 be invoked with the newly opened {@link android.hardware.camera2.CameraDevice}. The camera device can then be set up
 for operation by calling {@link android.hardware.camera2.CameraDevice#createCaptureSession} and
 {@link android.hardware.camera2.CameraDevice#createCaptureRequest}&lt;/p&gt;

 &lt;!--
 &lt;p&gt;Since the camera device will be opened asynchronously, any asynchronous operations done
 on the returned CameraDevice instance will be queued up until the device startup has
 completed and the callback's {@link android.hardware.camera2.CameraDevice.StateCallback#onOpened onOpened} method is
 called. The pending operations are then processed in order.&lt;/p&gt;
 --&gt;
 &lt;p&gt;If the camera becomes disconnected during initialization
 after this function call returns,
 {@link android.hardware.camera2.CameraDevice.StateCallback#onDisconnected} with a
 {@link android.hardware.camera2.CameraDevice} in the disconnected state (and
 {@link android.hardware.camera2.CameraDevice.StateCallback#onOpened} will be skipped).&lt;/p&gt;

 &lt;p&gt;If opening the camera device fails, then the device callback's
 {@link android.hardware.camera2.CameraDevice.StateCallback#onError onError} method will be called, and subsequent
 calls on the camera device will throw a {@link android.hardware.camera2.CameraAccessException}.&lt;/p&gt;
@param {String} cameraId
             The unique identifier of the camera device to open
@param {Object {CameraDevice.StateCallback}} callback
             The callback which is invoked once the camera is opened
@param {Object {Handler}} handler
             The handler on which the callback should be invoked, or
             {@code null} to use the current thread's {@link android.os.Looper looper}.
@throws CameraAccessException if the camera is disabled by device policy,
 has been disconnected, or is being used by a higher-priority camera API client.
@throws IllegalArgumentException if cameraId or the callback was null,
 or the cameraId does not match any currently or previously available
 camera device returned by {@link #getCameraIdList}.
@throws SecurityException if the application does not have permission to
 access the camera
@see #getCameraIdList
@see android.app.admin.DevicePolicyManager#setCameraDisabled
*/
openCamera : function(  ) {},

<span id='android-hardware-camera2-CameraManager-method-openCamera'>/**Open a connection to a camera with the given ID.
</span>
 &lt;p&gt;The behavior of this method matches that of
 {@link #openCamera(String, android.hardware.camera2.CameraCaptureSession.StateCallback, Handler)}, except that it uses
 {@link java.util.concurrent.Executor} as an argument instead of
 {@link android.os.Handler}.&lt;/p&gt;
@param {String} cameraId
             The unique identifier of the camera device to open
@param {Object {Executor}} executor
             The executor which will be used when invoking the callback.
@param {Object {CameraDevice.StateCallback}} callback
             The callback which is invoked once the camera is opened
@throws CameraAccessException if the camera is disabled by device policy,
 has been disconnected, or is being used by a higher-priority camera API client.
@throws IllegalArgumentException if cameraId, the callback or the executor was null,
 or the cameraId does not match any currently or previously available
 camera device.
@throws SecurityException if the application does not have permission to
 access the camera
@see #getCameraIdList
@see android.app.admin.DevicePolicyManager#setCameraDisabled
*/
openCamera : function(  ) {},

<span id='android-hardware-camera2-CameraManager-method-openCameraForUid'>/**Open a connection to a camera with the given ID, on behalf of another application
</span> specified by clientUid.

 &lt;p&gt;The behavior of this method matches that of {@link #openCamera}, except that it allows
 the caller to specify the UID to use for permission/etc verification. This can only be
 done by services trusted by the camera subsystem to act on behalf of applications and
 to forward the real UID.&lt;/p&gt;
@param {String} clientUid
             The UID of the application on whose behalf the camera is being opened.
             Must be USE_CALLING_UID unless the caller is a trusted service.
@hide 
*/
openCameraForUid : function(  ) {},

<span id='android-hardware-camera2-CameraManager-method-setTorchMode'>/**Set the flash unit's torch mode of the camera of the given ID without opening the camera
</span> device.

 &lt;p&gt;Use {@link #getCameraIdList} to get the list of available camera devices and use
 {@link #getCameraCharacteristics} to check whether the camera device has a flash unit.
 Note that even if a camera device has a flash unit, turning on the torch mode may fail
 if the camera device or other camera resources needed to turn on the torch mode are in use.
 &lt;/p&gt;

 &lt;p&gt; If {@link #setTorchMode} is called to turn on or off the torch mode successfully,
 {@link android.hardware.camera2.CameraManager.TorchCallback#onTorchModeChanged} will be invoked.
 However, even if turning on the torch mode is successful, the application does not have the
 exclusive ownership of the flash unit or the camera device. The torch mode will be turned
 off and becomes unavailable when the camera device that the flash unit belongs to becomes
 unavailable or when other camera resources to keep the torch on become unavailable (
 {@link android.hardware.camera2.CameraManager.TorchCallback#onTorchModeUnavailable} will be invoked). Also,
 other applications are free to call {@link #setTorchMode} to turn off the torch mode (
 {@link android.hardware.camera2.CameraManager.TorchCallback#onTorchModeChanged} will be invoked). If the latest
 application that turned on the torch mode exits, the torch mode will be turned off.
@param {String} cameraId
             The unique identifier of the camera device that the flash unit belongs to.
@param {Boolean} enabled
             The desired state of the torch mode for the target camera device. Set to
             {@code true} to turn on the torch mode. Set to {@code false} to turn off the
             torch mode.
@throws CameraAccessException if it failed to access the flash unit.
             {@link CameraAccessException#CAMERA_IN_USE} will be thrown if the camera device
             is in use. {@link CameraAccessException#MAX_CAMERAS_IN_USE} will be thrown if
             other camera resources needed to turn on the torch mode are in use.
             {@link CameraAccessException#CAMERA_DISCONNECTED} will be thrown if camera
             service is not available.
@throws IllegalArgumentException if cameraId was null, cameraId doesn't match any currently
             or previously available camera device, or the camera device doesn't have a
             flash unit.
*/
setTorchMode : function(  ) {},

<span id='android-hardware-camera2-CameraManager-method-throwAsPublicException'>/**Convert ServiceSpecificExceptions and Binder RemoteExceptions from camera binder interfaces
</span> into the correct public exceptions.
@hide 
*/
throwAsPublicException : function(  ) {},

<span id='android-hardware-camera2-CameraManager-method-isHiddenPhysicalCamera'>/**Queries the camera service if a cameraId is a hidden physical camera that belongs to a
</span> logical camera device.

 A hidden physical camera is a camera that cannot be opened by the application. But it
 can be used as part of a logical camera.
@param {String} cameraId a non-{@code null} camera identifier
@return {Boolean} {@code true} if cameraId is a hidden physical camera device
@hide 
*/
isHiddenPhysicalCamera : function(  ) {},


};</pre>
</body>
</html>
