<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='android-hardware-SensorManager'>/**@class android.hardware.SensorManager
</span>@extends java.lang.Object

 &lt;p&gt;
 SensorManager lets you access the device's {@link android.hardware.Sensor
 sensors}.
 &lt;/p&gt;
 &lt;p&gt;
 Always make sure to disable sensors you don't need, especially when your
 activity is paused. Failing to do so can drain the battery in just a few
 hours. Note that the system will &lt;i&gt;not&lt;/i&gt; disable sensors automatically when
 the screen turns off.
 &lt;/p&gt;
 &lt;p class=&quot;note&quot;&gt;
 Note: Don't use this mechanism with a Trigger Sensor, have a look
 at {@link android.hardware.TriggerEventListener}. {@link android.hardware.Sensor#TYPE_SIGNIFICANT_MOTION}
 is an example of a trigger sensor.
 &lt;/p&gt;
 &lt;pre class=&quot;prettyprint&quot;&gt;
 public class SensorActivity extends Activity implements SensorEventListener {
     private final SensorManager mSensorManager;
     private final Sensor mAccelerometer;

     public SensorActivity() {
         mSensorManager = (SensorManager)getSystemService(SENSOR_SERVICE);
         mAccelerometer = mSensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER);
     }

     protected void onResume() {
         super.onResume();
         mSensorManager.registerListener(this, mAccelerometer, SensorManager.SENSOR_DELAY_NORMAL);
     }

     protected void onPause() {
         super.onPause();
         mSensorManager.unregisterListener(this);
     }

     public void onAccuracyChanged(Sensor sensor, int accuracy) {
     }

     public void onSensorChanged(SensorEvent event) {
     }
 }
 &lt;/pre&gt;

 @see SensorEventListener
 @see SensorEvent
 @see Sensor

*/
var SensorManager = {

<span id='android-hardware-SensorManager-property-SENSOR_ORIENTATION'>/** A constant describing an orientation sensor. See
</span> {@link android.hardware.SensorListener SensorListener} for more details.

 @deprecated use {@link android.hardware.Sensor Sensor} instead.
*/
SENSOR_ORIENTATION : &quot;1&quot;,
<span id='android-hardware-SensorManager-property-SENSOR_ACCELEROMETER'>/** A constant describing an accelerometer. See
</span> {@link android.hardware.SensorListener SensorListener} for more details.

 @deprecated use {@link android.hardware.Sensor Sensor} instead.
*/
SENSOR_ACCELEROMETER : &quot;2&quot;,
<span id='android-hardware-SensorManager-property-SENSOR_TEMPERATURE'>/** A constant describing a temperature sensor See
</span> {@link android.hardware.SensorListener SensorListener} for more details.

 @deprecated use {@link android.hardware.Sensor Sensor} instead.
*/
SENSOR_TEMPERATURE : &quot;4&quot;,
<span id='android-hardware-SensorManager-property-SENSOR_MAGNETIC_FIELD'>/** A constant describing a magnetic sensor See
</span> {@link android.hardware.SensorListener SensorListener} for more details.

 @deprecated use {@link android.hardware.Sensor Sensor} instead.
*/
SENSOR_MAGNETIC_FIELD : &quot;8&quot;,
<span id='android-hardware-SensorManager-property-SENSOR_LIGHT'>/** A constant describing an ambient light sensor See
</span> {@link android.hardware.SensorListener SensorListener} for more details.

 @deprecated use {@link android.hardware.Sensor Sensor} instead.
*/
SENSOR_LIGHT : &quot;16&quot;,
<span id='android-hardware-SensorManager-property-SENSOR_PROXIMITY'>/** A constant describing a proximity sensor See
</span> {@link android.hardware.SensorListener SensorListener} for more details.

 @deprecated use {@link android.hardware.Sensor Sensor} instead.
*/
SENSOR_PROXIMITY : &quot;32&quot;,
<span id='android-hardware-SensorManager-property-SENSOR_TRICORDER'>/** A constant describing a Tricorder See
</span> {@link android.hardware.SensorListener SensorListener} for more details.

 @deprecated use {@link android.hardware.Sensor Sensor} instead.
*/
SENSOR_TRICORDER : &quot;64&quot;,
<span id='android-hardware-SensorManager-property-SENSOR_ORIENTATION_RAW'>/** A constant describing an orientation sensor. See
</span> {@link android.hardware.SensorListener SensorListener} for more details.

 @deprecated use {@link android.hardware.Sensor Sensor} instead.
*/
SENSOR_ORIENTATION_RAW : &quot;128&quot;,
<span id='android-hardware-SensorManager-property-SENSOR_ALL'>/** A constant that includes all sensors
</span>
 @deprecated use {@link android.hardware.Sensor Sensor} instead.
*/
SENSOR_ALL : &quot;127&quot;,
<span id='android-hardware-SensorManager-property-SENSOR_MIN'>/** Smallest sensor ID
</span>
 @deprecated use {@link android.hardware.Sensor Sensor} instead.
*/
SENSOR_MIN : &quot;1&quot;,
<span id='android-hardware-SensorManager-property-SENSOR_MAX'>/** Largest sensor ID
</span>
 @deprecated use {@link android.hardware.Sensor Sensor} instead.
*/
SENSOR_MAX : &quot;64&quot;,
<span id='android-hardware-SensorManager-property-DATA_X'>/** Index of the X value in the array returned by
</span> {@link android.hardware.SensorListener#onSensorChanged}

 @deprecated use {@link android.hardware.Sensor Sensor} instead.
*/
DATA_X : &quot;0&quot;,
<span id='android-hardware-SensorManager-property-DATA_Y'>/** Index of the Y value in the array returned by
</span> {@link android.hardware.SensorListener#onSensorChanged}

 @deprecated use {@link android.hardware.Sensor Sensor} instead.
*/
DATA_Y : &quot;1&quot;,
<span id='android-hardware-SensorManager-property-DATA_Z'>/** Index of the Z value in the array returned by
</span> {@link android.hardware.SensorListener#onSensorChanged}

 @deprecated use {@link android.hardware.Sensor Sensor} instead.
*/
DATA_Z : &quot;2&quot;,
<span id='android-hardware-SensorManager-property-RAW_DATA_INDEX'>/** Offset to the untransformed values in the array returned by
</span> {@link android.hardware.SensorListener#onSensorChanged}

 @deprecated use {@link android.hardware.Sensor Sensor} instead.
*/
RAW_DATA_INDEX : &quot;3&quot;,
<span id='android-hardware-SensorManager-property-RAW_DATA_X'>/** Index of the untransformed X value in the array returned by
</span> {@link android.hardware.SensorListener#onSensorChanged}

 @deprecated use {@link android.hardware.Sensor Sensor} instead.
*/
RAW_DATA_X : &quot;3&quot;,
<span id='android-hardware-SensorManager-property-RAW_DATA_Y'>/** Index of the untransformed Y value in the array returned by
</span> {@link android.hardware.SensorListener#onSensorChanged}

 @deprecated use {@link android.hardware.Sensor Sensor} instead.
*/
RAW_DATA_Y : &quot;4&quot;,
<span id='android-hardware-SensorManager-property-RAW_DATA_Z'>/** Index of the untransformed Z value in the array returned by
</span> {@link android.hardware.SensorListener#onSensorChanged}

 @deprecated use {@link android.hardware.Sensor Sensor} instead.
*/
RAW_DATA_Z : &quot;5&quot;,
<span id='android-hardware-SensorManager-property-STANDARD_GRAVITY'>/**Standard gravity (g) on Earth. This value is equivalent to 1G */
</span>STANDARD_GRAVITY : &quot;9.80665&quot;,
<span id='android-hardware-SensorManager-property-GRAVITY_SUN'>/**Sun's gravity in SI units (m/s^2) */
</span>GRAVITY_SUN : &quot;275.0&quot;,
<span id='android-hardware-SensorManager-property-GRAVITY_MERCURY'>/**Mercury's gravity in SI units (m/s^2) */
</span>GRAVITY_MERCURY : &quot;3.7&quot;,
<span id='android-hardware-SensorManager-property-GRAVITY_VENUS'>/**Venus' gravity in SI units (m/s^2) */
</span>GRAVITY_VENUS : &quot;8.87&quot;,
<span id='android-hardware-SensorManager-property-GRAVITY_EARTH'>/**Earth's gravity in SI units (m/s^2) */
</span>GRAVITY_EARTH : &quot;9.80665&quot;,
<span id='android-hardware-SensorManager-property-GRAVITY_MOON'>/**The Moon's gravity in SI units (m/s^2) */
</span>GRAVITY_MOON : &quot;1.6&quot;,
<span id='android-hardware-SensorManager-property-GRAVITY_MARS'>/**Mars' gravity in SI units (m/s^2) */
</span>GRAVITY_MARS : &quot;3.71&quot;,
<span id='android-hardware-SensorManager-property-GRAVITY_JUPITER'>/**Jupiter's gravity in SI units (m/s^2) */
</span>GRAVITY_JUPITER : &quot;23.12&quot;,
<span id='android-hardware-SensorManager-property-GRAVITY_SATURN'>/**Saturn's gravity in SI units (m/s^2) */
</span>GRAVITY_SATURN : &quot;8.96&quot;,
<span id='android-hardware-SensorManager-property-GRAVITY_URANUS'>/**Uranus' gravity in SI units (m/s^2) */
</span>GRAVITY_URANUS : &quot;8.69&quot;,
<span id='android-hardware-SensorManager-property-GRAVITY_NEPTUNE'>/**Neptune's gravity in SI units (m/s^2) */
</span>GRAVITY_NEPTUNE : &quot;11.0&quot;,
<span id='android-hardware-SensorManager-property-GRAVITY_PLUTO'>/**Pluto's gravity in SI units (m/s^2) */
</span>GRAVITY_PLUTO : &quot;0.6&quot;,
<span id='android-hardware-SensorManager-property-GRAVITY_DEATH_STAR_I'>/**Gravity (estimate) on the first Death Star in Empire units (m/s^2) */
</span>GRAVITY_DEATH_STAR_I : &quot;3.5303614E-7&quot;,
<span id='android-hardware-SensorManager-property-GRAVITY_THE_ISLAND'>/**Gravity on the island */
</span>GRAVITY_THE_ISLAND : &quot;4.815162&quot;,
<span id='android-hardware-SensorManager-property-MAGNETIC_FIELD_EARTH_MAX'>/**Maximum magnetic field on Earth's surface */
</span>MAGNETIC_FIELD_EARTH_MAX : &quot;60.0&quot;,
<span id='android-hardware-SensorManager-property-MAGNETIC_FIELD_EARTH_MIN'>/**Minimum magnetic field on Earth's surface */
</span>MAGNETIC_FIELD_EARTH_MIN : &quot;30.0&quot;,
<span id='android-hardware-SensorManager-property-PRESSURE_STANDARD_ATMOSPHERE'>/**Standard atmosphere, or average sea-level pressure in hPa (millibar) */
</span>PRESSURE_STANDARD_ATMOSPHERE : &quot;1013.25&quot;,
<span id='android-hardware-SensorManager-property-LIGHT_SUNLIGHT_MAX'>/**Maximum luminance of sunlight in lux */
</span>LIGHT_SUNLIGHT_MAX : &quot;120000.0&quot;,
<span id='android-hardware-SensorManager-property-LIGHT_SUNLIGHT'>/**luminance of sunlight in lux */
</span>LIGHT_SUNLIGHT : &quot;110000.0&quot;,
<span id='android-hardware-SensorManager-property-LIGHT_SHADE'>/**luminance in shade in lux */
</span>LIGHT_SHADE : &quot;20000.0&quot;,
<span id='android-hardware-SensorManager-property-LIGHT_OVERCAST'>/**luminance under an overcast sky in lux */
</span>LIGHT_OVERCAST : &quot;10000.0&quot;,
<span id='android-hardware-SensorManager-property-LIGHT_SUNRISE'>/**luminance at sunrise in lux */
</span>LIGHT_SUNRISE : &quot;400.0&quot;,
<span id='android-hardware-SensorManager-property-LIGHT_CLOUDY'>/**luminance under a cloudy sky in lux */
</span>LIGHT_CLOUDY : &quot;100.0&quot;,
<span id='android-hardware-SensorManager-property-LIGHT_FULLMOON'>/**luminance at night with full moon in lux */
</span>LIGHT_FULLMOON : &quot;0.25&quot;,
<span id='android-hardware-SensorManager-property-LIGHT_NO_MOON'>/**luminance at night with no moon in lux*/
</span>LIGHT_NO_MOON : &quot;0.001&quot;,
<span id='android-hardware-SensorManager-property-SENSOR_DELAY_FASTEST'>/**get sensor data as fast as possible */
</span>SENSOR_DELAY_FASTEST : &quot;0&quot;,
<span id='android-hardware-SensorManager-property-SENSOR_DELAY_GAME'>/**rate suitable for games */
</span>SENSOR_DELAY_GAME : &quot;1&quot;,
<span id='android-hardware-SensorManager-property-SENSOR_DELAY_UI'>/**rate suitable for the user interface  */
</span>SENSOR_DELAY_UI : &quot;2&quot;,
<span id='android-hardware-SensorManager-property-SENSOR_DELAY_NORMAL'>/**rate (default) suitable for screen orientation changes */
</span>SENSOR_DELAY_NORMAL : &quot;3&quot;,
<span id='android-hardware-SensorManager-property-SENSOR_STATUS_NO_CONTACT'>/** The values returned by this sensor cannot be trusted because the sensor
</span> had no contact with what it was measuring (for example, the heart rate
 monitor is not in contact with the user).
*/
SENSOR_STATUS_NO_CONTACT : &quot;-1&quot;,
<span id='android-hardware-SensorManager-property-SENSOR_STATUS_UNRELIABLE'>/** The values returned by this sensor cannot be trusted, calibration is
</span> needed or the environment doesn't allow readings
*/
SENSOR_STATUS_UNRELIABLE : &quot;0&quot;,
<span id='android-hardware-SensorManager-property-SENSOR_STATUS_ACCURACY_LOW'>/** This sensor is reporting data with low accuracy, calibration with the
</span> environment is needed
*/
SENSOR_STATUS_ACCURACY_LOW : &quot;1&quot;,
<span id='android-hardware-SensorManager-property-SENSOR_STATUS_ACCURACY_MEDIUM'>/** This sensor is reporting data with an average level of accuracy,
</span> calibration with the environment may improve the readings
*/
SENSOR_STATUS_ACCURACY_MEDIUM : &quot;2&quot;,
<span id='android-hardware-SensorManager-property-SENSOR_STATUS_ACCURACY_HIGH'>/**This sensor is reporting data with maximum accuracy */
</span>SENSOR_STATUS_ACCURACY_HIGH : &quot;3&quot;,
<span id='android-hardware-SensorManager-property-AXIS_X'>/**see {@link #remapCoordinateSystem} */
</span>AXIS_X : &quot;1&quot;,
<span id='android-hardware-SensorManager-property-AXIS_Y'>/**see {@link #remapCoordinateSystem} */
</span>AXIS_Y : &quot;2&quot;,
<span id='android-hardware-SensorManager-property-AXIS_Z'>/**see {@link #remapCoordinateSystem} */
</span>AXIS_Z : &quot;3&quot;,
<span id='android-hardware-SensorManager-property-AXIS_MINUS_X'>/**see {@link #remapCoordinateSystem} */
</span>AXIS_MINUS_X : &quot;129&quot;,
<span id='android-hardware-SensorManager-property-AXIS_MINUS_Y'>/**see {@link #remapCoordinateSystem} */
</span>AXIS_MINUS_Y : &quot;130&quot;,
<span id='android-hardware-SensorManager-property-AXIS_MINUS_Z'>/**see {@link #remapCoordinateSystem} */
</span>AXIS_MINUS_Z : &quot;131&quot;,
<span id='android-hardware-SensorManager-method-getSensors'>/**
</span>@return {Number} available sensors.
@deprecated This method is deprecated, use
             {@link SensorManager#getSensorList(int)} instead
*/
getSensors : function(  ) {},

<span id='android-hardware-SensorManager-method-getSensorList'>/**Use this method to get the list of available sensors of a certain type.
</span> Make multiple calls to get sensors of different types or use
 {@link android.hardware.Sensor#TYPE_ALL Sensor.TYPE_ALL} to get all the
 sensors.

 &lt;p class=&quot;note&quot;&gt;
 NOTE: Both wake-up and non wake-up sensors matching the given type are
 returned. Check {@link android.hardware.Sensor#isWakeUpandroid.hardware.Sensor()} to know the wake-up properties
 of the returned {@link android.hardware.Sensor}.
 &lt;/p&gt;
@param {Number} type
        of sensors requested
@return {Object {java.util.List}} a list of sensors matching the asked type.
@see #getDefaultSensor(int)
@see Sensor
*/
getSensorList : function(  ) {},

<span id='android-hardware-SensorManager-method-getDynamicSensorList'>/**Use this method to get a list of available dynamic sensors of a certain type.
</span> Make multiple calls to get sensors of different types or use
 {@link android.hardware.Sensor#TYPE_ALL Sensor.TYPE_ALL} to get all dynamic sensors.

 &lt;p class=&quot;note&quot;&gt;
 NOTE: Both wake-up and non wake-up sensors matching the given type are
 returned. Check {@link android.hardware.Sensor#isWakeUpandroid.hardware.Sensor()} to know the wake-up properties
 of the returned {@link android.hardware.Sensor}.
 &lt;/p&gt;
@param {Number} type of sensors requested
@return {Object {java.util.List}} a list of dynamic sensors matching the requested type.
@see Sensor
*/
getDynamicSensorList : function(  ) {},

<span id='android-hardware-SensorManager-method-getDefaultSensor'>/**Use this method to get the default sensor for a given type. Note that the
</span> returned sensor could be a composite sensor, and its data could be
 averaged or filtered. If you need to access the raw sensors use
 {@link android.hardware.SensorManager#getSensorList(int) getSensorList}.
@param {Number} type
         of sensors requested
@return {Object {android.hardware.Sensor}} the default sensor matching the requested type if one exists and the application
         has the necessary permissions, or null otherwise.
@see #getSensorList(int)
@see Sensor
*/
getDefaultSensor : function(  ) {},

<span id='android-hardware-SensorManager-method-getDefaultSensor'>/**Return a Sensor with the given type and wakeUp properties. If multiple sensors of this
</span> type exist, any one of them may be returned.
 &lt;p&gt;
 For example,
 &lt;ul&gt;
     &lt;li&gt;getDefaultSensor({@link android.hardware.Sensor#TYPE_ACCELEROMETER}, true) returns a wake-up
     accelerometer sensor if it exists. &lt;/li&gt;
     &lt;li&gt;getDefaultSensor({@link android.hardware.Sensor#TYPE_PROXIMITY}, false) returns a non wake-up
     proximity sensor if it exists. &lt;/li&gt;
     &lt;li&gt;getDefaultSensor({@link android.hardware.Sensor#TYPE_PROXIMITY}, true) returns a wake-up proximity
     sensor which is the same as the Sensor returned by {@link #getDefaultSensor}(int). &lt;/li&gt;
 &lt;/ul&gt;
 &lt;/p&gt;
 &lt;p class=&quot;note&quot;&gt;
 Note: Sensors like {@link android.hardware.Sensor#TYPE_PROXIMITY} and {@link android.hardware.Sensor#TYPE_SIGNIFICANT_MOTION}
 are declared as wake-up sensors by default.
 &lt;/p&gt;
@param {Number} type
        type of sensor requested
@param {Boolean} wakeUp
        flag to indicate whether the Sensor is a wake-up or non wake-up sensor.
@return {Object {android.hardware.Sensor}} the default sensor matching the requested type and wakeUp properties if one exists
         and the application has the necessary permissions, or null otherwise.
@see Sensor#isWakeUpSensor()
*/
getDefaultSensor : function(  ) {},

<span id='android-hardware-SensorManager-method-registerListener'>/**Registers a listener for given sensors.
</span>@param {Object {SensorListener}} listener
        sensor listener object
@param {Number} sensors
        a bit masks of the sensors to register to
@param sensors
        a bit masks of the sensors to register to
@return {Boolean} &lt;code&gt;true&lt;/code&gt; if the sensor is supported and successfully
         enabled
*/
registerListener : function(  ) {},

<span id='android-hardware-SensorManager-method-registerListener'>/**Registers a SensorListener for given sensors.
</span>@param {Object {SensorListener}} listener
        sensor listener object
@param {Number} sensors
        a bit masks of the sensors to register to
@param {Number} rate
        rate of events. This is only a hint to the system. events may be
        received faster or slower than the specified rate. Usually events
        are received faster. The value must be one of
        {@link #SENSOR_DELAY_NORMAL}, {@link #SENSOR_DELAY_UI},
        {@link #SENSOR_DELAY_GAME}, or {@link #SENSOR_DELAY_FASTEST}.
@param rate
        rate of events. This is only a hint to the system. events may be
        received faster or slower than the specified rate. Usually events
        are received faster. The value must be one of
        {@link #SENSOR_DELAY_NORMAL}, {@link #SENSOR_DELAY_UI},
        {@link #SENSOR_DELAY_GAME}, or {@link #SENSOR_DELAY_FASTEST}.
@return {Boolean} &lt;code&gt;true&lt;/code&gt; if the sensor is supported and successfully
         enabled
*/
registerListener : function(  ) {},

<span id='android-hardware-SensorManager-method-unregisterListener'>/**Unregisters a listener for all sensors.
</span>@param {Object {SensorListener}} listener
        a SensorListener object
@param listener
        a SensorListener object
*/
unregisterListener : function(  ) {},

<span id='android-hardware-SensorManager-method-unregisterListener'>/**Unregisters a listener for the sensors with which it is registered.
</span>@param {Object {SensorListener}} listener
        a SensorListener object
@param {Number} sensors
        a bit masks of the sensors to unregister from
@param sensors
        a bit masks of the sensors to unregister from
*/
unregisterListener : function(  ) {},

<span id='android-hardware-SensorManager-method-unregisterListener'>/**Unregisters a listener for the sensors with which it is registered.
</span>
 &lt;p class=&quot;note&quot;&gt;&lt;/p&gt;
 Note: Don't use this method with a one shot trigger sensor such as
 {@link android.hardware.Sensor#TYPE_SIGNIFICANT_MOTION}.
 Use {@link #cancelTriggerandroid.hardware.Sensor(TriggerEventListener, android.hardware.Sensor)} instead.
 &lt;/p&gt;
@param {Object {SensorEventListener}} listener
        a SensorEventListener object
@param {Object {Sensor}} sensor
        the sensor to unregister from
@see #unregisterListener(SensorEventListener)
@see #registerListener(SensorEventListener, Sensor, int)
*/
unregisterListener : function(  ) {},

<span id='android-hardware-SensorManager-method-unregisterListener'>/**Unregisters a listener for all sensors.
</span>@param {Object {SensorEventListener}} listener
        a SensorListener object
@see #unregisterListener(SensorEventListener, Sensor)
@see #registerListener(SensorEventListener, Sensor, int)
*/
unregisterListener : function(  ) {},

<span id='android-hardware-SensorManager-method-registerListener'>/**Registers a {@link android.hardware.SensorEventListener SensorEventListener} for the given
</span> sensor at the given sampling frequency.
 &lt;p&gt;
 The events will be delivered to the provided {@code SensorEventListener} as soon as they are
 available. To reduce the power consumption, applications can use
 {@link #registerListener(android.hardware.SensorEventListener, android.hardware.Sensor, int, int)} instead and specify a
 positive non-zero maximum reporting latency.
 &lt;/p&gt;
 &lt;p&gt;
 In the case of non-wake-up sensors, the events are only delivered while the Application
 Processor (AP) is not in suspend mode. See {@link android.hardware.Sensor#isWakeUpandroid.hardware.Sensor()} for more details.
 To ensure delivery of events from non-wake-up sensors even when the screen is OFF, the
 application registering to the sensor must hold a partial wake-lock to keep the AP awake,
 otherwise some events might be lost while the AP is asleep. Note that although events might
 be lost while the AP is asleep, the sensor will still consume power if it is not explicitly
 deactivated by the application. Applications must unregister their {@code
 SensorEventListener}s in their activity's {@code onPause()} method to avoid consuming power
 while the device is inactive.  See {@link #registerListener(android.hardware.SensorEventListener, android.hardware.Sensor, int,
 int)} for more details on hardware FIFO (queueing) capabilities and when some sensor events
 might be lost.
 &lt;/p&gt;
 &lt;p&gt;
 In the case of wake-up sensors, each event generated by the sensor will cause the AP to
 wake-up, ensuring that each event can be delivered. Because of this, registering to a wake-up
 sensor has very significant power implications. Call {@link android.hardware.Sensor#isWakeUpandroid.hardware.Sensor()} to check
 whether a sensor is a wake-up sensor. See
 {@link #registerListener(android.hardware.SensorEventListener, android.hardware.Sensor, int, int)} for information on how to
 reduce the power impact of registering to wake-up sensors.
 &lt;/p&gt;
 &lt;p class=&quot;note&quot;&gt;
 Note: Don't use this method with one-shot trigger sensors such as
 {@link android.hardware.Sensor#TYPE_SIGNIFICANT_MOTION}. Use
 {@link #requestTriggerandroid.hardware.Sensor(TriggerEventListener, android.hardware.Sensor)} instead. Use
 {@link android.hardware.Sensor#getReportingMode()} to obtain the reporting mode of a given sensor.
 &lt;/p&gt;
@param {Object {SensorEventListener}} listener A {@link android.hardware.SensorEventListener SensorEventListener} object.
@param {Object {Sensor}} sensor The {@link android.hardware.Sensor Sensor} to register to.
@param {Number} samplingPeriodUs The rate {@link android.hardware.SensorEvent sensor events} are
            delivered at. This is only a hint to the system. Events may be received faster or
            slower than the specified rate. Usually events are received faster. The value must
            be one of {@link #SENSOR_DELAY_NORMAL}, {@link #SENSOR_DELAY_UI},
            {@link #SENSOR_DELAY_GAME}, or {@link #SENSOR_DELAY_FASTEST} or, the desired delay
            between events in microseconds. Specifying the delay in microseconds only works
            from Android 2.3 (API level 9) onwards. For earlier releases, you must use one of
            the {@code SENSOR_DELAY_*} constants.
@return {Boolean} &lt;code&gt;true&lt;/code&gt; if the sensor is supported and successfully enabled.
@see #registerListener(SensorEventListener, Sensor, int, Handler)
@see #unregisterListener(SensorEventListener)
@see #unregisterListener(SensorEventListener, Sensor)
*/
registerListener : function(  ) {},

<span id='android-hardware-SensorManager-method-registerListener'>/**Registers a {@link android.hardware.SensorEventListener SensorEventListener} for the given
</span> sensor at the given sampling frequency and the given maximum reporting latency.
 &lt;p&gt;
 This function is similar to {@link #registerListener(android.hardware.SensorEventListener, android.hardware.Sensor, int)} but
 it allows events to stay temporarily in the hardware FIFO (queue) before being delivered. The
 events can be stored in the hardware FIFO up to {@code maxReportLatencyUs} microseconds. Once
 one of the events in the FIFO needs to be reported, all of the events in the FIFO are
 reported sequentially. This means that some events will be reported before the maximum
 reporting latency has elapsed.
 &lt;/p&gt;&lt;p&gt;
 When {@code maxReportLatencyUs} is 0, the call is equivalent to a call to
 {@link #registerListener(android.hardware.SensorEventListener, android.hardware.Sensor, int)}, as it requires the events to be
 delivered as soon as possible.
 &lt;/p&gt;&lt;p&gt;
 When {@code sensor.maxFifoEventCount()} is 0, the sensor does not use a FIFO, so the call
 will also be equivalent to {@link #registerListener(android.hardware.SensorEventListener, android.hardware.Sensor, int)}.
 &lt;/p&gt;&lt;p&gt;
 Setting {@code maxReportLatencyUs} to a positive value allows to reduce the number of
 interrupts the AP (Application Processor) receives, hence reducing power consumption, as the
 AP can switch to a lower power state while the sensor is capturing the data. This is
 especially important when registering to wake-up sensors, for which each interrupt causes the
 AP to wake up if it was in suspend mode. See {@link android.hardware.Sensor#isWakeUpandroid.hardware.Sensor()} for more
 information on wake-up sensors.
 &lt;/p&gt;
 &lt;p class=&quot;note&quot;&gt;
 &lt;/p&gt;
 Note: Don't use this method with one-shot trigger sensors such as
 {@link android.hardware.Sensor#TYPE_SIGNIFICANT_MOTION}. Use
 {@link #requestTriggerandroid.hardware.Sensor(TriggerEventListener, android.hardware.Sensor)} instead. &lt;/p&gt;
@param {Object {SensorEventListener}} listener A {@link android.hardware.SensorEventListener SensorEventListener} object
            that will receive the sensor events. If the application is interested in receiving
            flush complete notifications, it should register with
            {@link android.hardware.SensorEventListener SensorEventListener2} instead.
@param {Object {Sensor}} sensor The {@link android.hardware.Sensor Sensor} to register to.
@param {Number} samplingPeriodUs The desired delay between two consecutive events in microseconds.
            This is only a hint to the system. Events may be received faster or slower than
            the specified rate. Usually events are received faster. Can be one of
            {@link #SENSOR_DELAY_NORMAL}, {@link #SENSOR_DELAY_UI},
            {@link #SENSOR_DELAY_GAME}, {@link #SENSOR_DELAY_FASTEST} or the delay in
            microseconds.
@param {Number} maxReportLatencyUs Maximum time in microseconds that events can be delayed before
            being reported to the application. A large value allows reducing the power
            consumption associated with the sensor. If maxReportLatencyUs is set to zero,
            events are delivered as soon as they are available, which is equivalent to calling
            {@link #registerListener(SensorEventListener, Sensor, int)}.
@return {Boolean} &lt;code&gt;true&lt;/code&gt; if the sensor is supported and successfully enabled.
@see #registerListener(SensorEventListener, Sensor, int)
@see #unregisterListener(SensorEventListener)
@see #flush(SensorEventListener)
*/
registerListener : function(  ) {},

<span id='android-hardware-SensorManager-method-registerListener'>/**Registers a {@link android.hardware.SensorEventListener SensorEventListener} for the given
</span> sensor. Events are delivered in continuous mode as soon as they are available. To reduce the
 power consumption, applications can use
 {@link #registerListener(android.hardware.SensorEventListener, android.hardware.Sensor, int, int)} instead and specify a
 positive non-zero maximum reporting latency.
 &lt;p class=&quot;note&quot;&gt;
 &lt;/p&gt;
 Note: Don't use this method with a one shot trigger sensor such as
 {@link android.hardware.Sensor#TYPE_SIGNIFICANT_MOTION}. Use
 {@link #requestTriggerandroid.hardware.Sensor(TriggerEventListener, android.hardware.Sensor)} instead. &lt;/p&gt;
@param {Object {SensorEventListener}} listener A {@link android.hardware.SensorEventListener SensorEventListener} object.
@param {Object {Sensor}} sensor The {@link android.hardware.Sensor Sensor} to register to.
@param {Number} samplingPeriodUs The rate {@link android.hardware.SensorEvent sensor events} are
            delivered at. This is only a hint to the system. Events may be received faster or
            slower than the specified rate. Usually events are received faster. The value must
            be one of {@link #SENSOR_DELAY_NORMAL}, {@link #SENSOR_DELAY_UI},
            {@link #SENSOR_DELAY_GAME}, or {@link #SENSOR_DELAY_FASTEST} or, the desired
            delay between events in microseconds. Specifying the delay in microseconds only
            works from Android 2.3 (API level 9) onwards. For earlier releases, you must use
            one of the {@code SENSOR_DELAY_*} constants.
@param {Object {Handler}} handler The {@link android.os.Handler Handler} the {@link android.hardware.SensorEvent
            sensor events} will be delivered to.
@return {Boolean} &lt;code&gt;true&lt;/code&gt; if the sensor is supported and successfully enabled.
@see #registerListener(SensorEventListener, Sensor, int)
@see #unregisterListener(SensorEventListener)
@see #unregisterListener(SensorEventListener, Sensor)
*/
registerListener : function(  ) {},

<span id='android-hardware-SensorManager-method-registerListener'>/**Registers a {@link android.hardware.SensorEventListener SensorEventListener} for the given
</span> sensor at the given sampling frequency and the given maximum reporting latency.
@param {Object {SensorEventListener}} listener A {@link android.hardware.SensorEventListener SensorEventListener} object
            that will receive the sensor events. If the application is interested in receiving
            flush complete notifications, it should register with
            {@link android.hardware.SensorEventListener SensorEventListener2} instead.
@param {Object {Sensor}} sensor The {@link android.hardware.Sensor Sensor} to register to.
@param {Number} samplingPeriodUs The desired delay between two consecutive events in microseconds.
            This is only a hint to the system. Events may be received faster or slower than
            the specified rate. Usually events are received faster. Can be one of
            {@link #SENSOR_DELAY_NORMAL}, {@link #SENSOR_DELAY_UI},
            {@link #SENSOR_DELAY_GAME}, {@link #SENSOR_DELAY_FASTEST} or the delay in
            microseconds.
@param {Number} maxReportLatencyUs Maximum time in microseconds that events can be delayed before
            being reported to the application. A large value allows reducing the power
            consumption associated with the sensor. If maxReportLatencyUs is set to zero,
            events are delivered as soon as they are available, which is equivalent to calling
            {@link #registerListener(SensorEventListener, Sensor, int)}.
@param {Object {Handler}} handler The {@link android.os.Handler Handler} the {@link android.hardware.SensorEvent
            sensor events} will be delivered to.
@return {Boolean} &lt;code&gt;true&lt;/code&gt; if the sensor is supported and successfully enabled.
@see #registerListener(SensorEventListener, Sensor, int, int)
*/
registerListener : function(  ) {},

<span id='android-hardware-SensorManager-method-flush'>/**Flushes the FIFO of all the sensors registered for this listener. If there are events
</span> in the FIFO of the sensor, they are returned as if the maxReportLantecy of the FIFO has
 expired. Events are returned in the usual way through the SensorEventListener.
 This call doesn't affect the maxReportLantecy for this sensor. This call is asynchronous and
 returns immediately.
 {@link android.hardware.SensorEventListener2#onFlushCompleted onFlushCompleted} is called
 after all the events in the batch at the time of calling this method have been delivered
 successfully. If the hardware doesn't support flush, it still returns true and a trivial
 flush complete event is sent after the current event for all the clients registered for this
 sensor.
@param {Object {SensorEventListener}} listener A {@link android.hardware.SensorEventListener SensorEventListener} object
        which was previously used in a registerListener call.
@return {Boolean} &lt;code&gt;true&lt;/code&gt; if the flush is initiated successfully on all the sensors
         registered for this listener, false if no sensor is previously registered for this
         listener or flush on one of the sensors fails.
@see #registerListener(SensorEventListener, Sensor, int, int)
@throws IllegalArgumentException when listener is null.
*/
flush : function(  ) {},

<span id='android-hardware-SensorManager-method-createDirectChannel'>/**Create a sensor direct channel backed by shared memory wrapped in MemoryFile object.
</span>
 The resulting channel can be used for delivering sensor events to native code, other
 processes, GPU/DSP or other co-processors without CPU intervention. This is the recommanded
 for high performance sensor applications that use high sensor rates (e.g. greater than 200Hz)
 and cares about sensor event latency.

 Use the returned {@link android.hardware.SensorDirectChannel} object to configure direct
 report of sensor events. After use, call {@link android.hardware.SensorDirectChannel#close()}
 to free up resource in sensor system associated with the direct channel.
@param {Object {MemoryFile}} mem A {@link android.os.MemoryFile} shared memory object.
@return {Object {android.hardware.SensorDirectChannel}} A {@link android.hardware.SensorDirectChannel} object.
@throws NullPointerException when mem is null.
@throws UncheckedIOException if not able to create channel.
@see SensorDirectChannel#close()
*/
createDirectChannel : function(  ) {},

<span id='android-hardware-SensorManager-method-createDirectChannel'>/**Create a sensor direct channel backed by shared memory wrapped in HardwareBuffer object.
</span>
 The resulting channel can be used for delivering sensor events to native code, other
 processes, GPU/DSP or other co-processors without CPU intervention. This is the recommanded
 for high performance sensor applications that use high sensor rates (e.g. greater than 200Hz)
 and cares about sensor event latency.

 Use the returned {@link android.hardware.SensorDirectChannel} object to configure direct
 report of sensor events. After use, call {@link android.hardware.SensorDirectChannel#close()}
 to free up resource in sensor system associated with the direct channel.
@param {Object {HardwareBuffer}} mem A {@link android.hardware.HardwareBuffer} shared memory object.
@return {Object {android.hardware.SensorDirectChannel}} A {@link android.hardware.SensorDirectChannel} object.
@throws NullPointerException when mem is null.
@throws UncheckedIOException if not able to create channel.
@see SensorDirectChannel#close()
*/
createDirectChannel : function(  ) {},

<span id='android-hardware-SensorManager-method-configureDirectChannel'>/**
</span>@removed 
*/
configureDirectChannel : function(  ) {},

<span id='android-hardware-SensorManager-method-registerDynamicSensorCallback'>/**Add a {@link android.hardware.SensorManager.DynamicSensorCallback
</span> DynamicSensorCallback} to receive dynamic sensor connection callbacks. Repeat
 registration with the already registered callback object will have no additional effect.
@param {Object {SensorManager.DynamicSensorCallback}} callback An object that implements the
        {@link android.hardware.SensorManager.DynamicSensorCallback
        DynamicSensorCallback}
        interface for receiving callbacks.
@see #registerDynamicSensorCallback(DynamicSensorCallback, Handler)
@throws IllegalArgumentException when callback is null.
*/
registerDynamicSensorCallback : function(  ) {},

<span id='android-hardware-SensorManager-method-registerDynamicSensorCallback'>/**Add a {@link android.hardware.SensorManager.DynamicSensorCallback
</span> DynamicSensorCallback} to receive dynamic sensor connection callbacks. Repeat
 registration with the already registered callback object will have no additional effect.
@param {Object {SensorManager.DynamicSensorCallback}} callback An object that implements the
        {@link android.hardware.SensorManager.DynamicSensorCallback
        DynamicSensorCallback} interface for receiving callbacks.
@param {Object {Handler}} handler The {@link android.os.Handler Handler} the {@link
        android.hardware.SensorManager.DynamicSensorCallback
        sensor connection events} will be delivered to.
@throws IllegalArgumentException when callback is null.
*/
registerDynamicSensorCallback : function(  ) {},

<span id='android-hardware-SensorManager-method-unregisterDynamicSensorCallback'>/**Remove a {@link android.hardware.SensorManager.DynamicSensorCallback
</span> DynamicSensorCallback} to stop sending dynamic sensor connection events to that
 callback.
@param {Object {SensorManager.DynamicSensorCallback}} callback An object that implements the
        {@link android.hardware.SensorManager.DynamicSensorCallback
        DynamicSensorCallback}
        interface for receiving callbacks.
*/
unregisterDynamicSensorCallback : function(  ) {},

<span id='android-hardware-SensorManager-method-isDynamicSensorDiscoverySupported'>/**Tell if dynamic sensor discovery feature is supported by system.
</span>@return {Boolean} &lt;code&gt;true&lt;/code&gt; if dynamic sensor discovery is supported, &lt;code&gt;false&lt;/code&gt;
 otherwise.
*/
isDynamicSensorDiscoverySupported : function(  ) {},

<span id='android-hardware-SensorManager-method-getRotationMatrix'>/**&lt;p&gt;
</span> Computes the inclination matrix &lt;b&gt;I&lt;/b&gt; as well as the rotation matrix
 &lt;b&gt;R&lt;/b&gt; transforming a vector from the device coordinate system to the
 world's coordinate system which is defined as a direct orthonormal basis,
 where:
 &lt;/p&gt;

 &lt;ul&gt;
 &lt;li&gt;X is defined as the vector product &lt;b&gt;Y.Z&lt;/b&gt; (It is tangential to
 the ground at the device's current location and roughly points East).&lt;/li&gt;
 &lt;li&gt;Y is tangential to the ground at the device's current location and
 points towards the magnetic North Pole.&lt;/li&gt;
 &lt;li&gt;Z points towards the sky and is perpendicular to the ground.&lt;/li&gt;
 &lt;/ul&gt;

 &lt;p&gt;
 &lt;center&gt;&lt;img src=&quot;../../../images/axis_globe.png&quot;
 alt=&quot;World coordinate-system diagram.&quot; border=&quot;0&quot; /&gt;&lt;/center&gt;
 &lt;/p&gt;

 &lt;p&gt;
 &lt;hr&gt;
 &lt;p&gt;
 By definition:
 &lt;p&gt;
 [0 0 g] = &lt;b&gt;R&lt;/b&gt; * &lt;b&gt;gravity&lt;/b&gt; (g = magnitude of gravity)
 &lt;p&gt;
 [0 m 0] = &lt;b&gt;I&lt;/b&gt; * &lt;b&gt;R&lt;/b&gt; * &lt;b&gt;geomagnetic&lt;/b&gt; (m = magnitude of
 geomagnetic field)
 &lt;p&gt;
 &lt;b&gt;R&lt;/b&gt; is the identity matrix when the device is aligned with the
 world's coordinate system, that is, when the device's X axis points
 toward East, the Y axis points to the North Pole and the device is facing
 the sky.

 &lt;p&gt;
 &lt;b&gt;I&lt;/b&gt; is a rotation matrix transforming the geomagnetic vector into
 the same coordinate space as gravity (the world's coordinate space).
 &lt;b&gt;I&lt;/b&gt; is a simple rotation around the X axis. The inclination angle in
 radians can be computed with {@link #getInclination}.
 &lt;hr&gt;

 &lt;p&gt;
 Each matrix is returned either as a 3x3 or 4x4 row-major matrix depending
 on the length of the passed array:
 &lt;p&gt;
 &lt;u&gt;If the array length is 16:&lt;/u&gt;

 &lt;pre&gt;
   /  M[ 0]   M[ 1]   M[ 2]   M[ 3]  \
   |  M[ 4]   M[ 5]   M[ 6]   M[ 7]  |
   |  M[ 8]   M[ 9]   M[10]   M[11]  |
   \  M[12]   M[13]   M[14]   M[15]  /
&lt;/pre&gt;

 This matrix is ready to be used by OpenGL ES's
 {@link javax.microedition.khronos.opengles.GL10#glLoadMatrixf(float[], int)
 glLoadMatrixf(float[], int)}.
 &lt;p&gt;
 Note that because OpenGL matrices are column-major matrices you must
 transpose the matrix before using it. However, since the matrix is a
 rotation matrix, its transpose is also its inverse, conveniently, it is
 often the inverse of the rotation that is needed for rendering; it can
 therefore be used with OpenGL ES directly.
 &lt;p&gt;
 Also note that the returned matrices always have this form:

 &lt;pre&gt;
   /  M[ 0]   M[ 1]   M[ 2]   0  \
   |  M[ 4]   M[ 5]   M[ 6]   0  |
   |  M[ 8]   M[ 9]   M[10]   0  |
   \      0       0       0   1  /
&lt;/pre&gt;

 &lt;p&gt;
 &lt;u&gt;If the array length is 9:&lt;/u&gt;

 &lt;pre&gt;
   /  M[ 0]   M[ 1]   M[ 2]  \
   |  M[ 3]   M[ 4]   M[ 5]  |
   \  M[ 6]   M[ 7]   M[ 8]  /
&lt;/pre&gt;

 &lt;hr&gt;
 &lt;p&gt;
 The inverse of each matrix can be computed easily by taking its
 transpose.

 &lt;p&gt;
 The matrices returned by this function are meaningful only when the
 device is not free-falling and it is not close to the magnetic north. If
 the device is accelerating, or placed into a strong magnetic field, the
 returned matrices may be inaccurate.
@param {Object {float[]}} R
        is an array of 9 floats holding the rotation matrix &lt;b&gt;R&lt;/b&gt; when
        this function returns. R can be null.
        &lt;p&gt;
@param {Object {float[]}} I
        is an array of 9 floats holding the rotation matrix &lt;b&gt;I&lt;/b&gt; when
        this function returns. I can be null.
        &lt;p&gt;
@param {Object {float[]}} gravity
        is an array of 3 floats containing the gravity vector expressed in
        the device's coordinate. You can simply use the
        {@link android.hardware.SensorEvent#values values} returned by a
        {@link android.hardware.SensorEvent SensorEvent} of a
        {@link android.hardware.Sensor Sensor} of type
        {@link android.hardware.Sensor#TYPE_ACCELEROMETER
        TYPE_ACCELEROMETER}.
        &lt;p&gt;
@param {Object {float[]}} geomagnetic
        is an array of 3 floats containing the geomagnetic vector
        expressed in the device's coordinate. You can simply use the
        {@link android.hardware.SensorEvent#values values} returned by a
        {@link android.hardware.SensorEvent SensorEvent} of a
        {@link android.hardware.Sensor Sensor} of type
        {@link android.hardware.Sensor#TYPE_MAGNETIC_FIELD
        TYPE_MAGNETIC_FIELD}.
@return {Boolean} &lt;code&gt;true&lt;/code&gt; on success, &lt;code&gt;false&lt;/code&gt; on failure (for
         instance, if the device is in free fall). Free fall is defined as
         condition when the magnitude of the gravity is less than 1/10 of
         the nominal value. On failure the output matrices are not modified.
@see #getInclination(float[])
@see #getOrientation(float[], float[])
@see #remapCoordinateSystem(float[], int, int, float[])
*/
getRotationMatrix : function(  ) {},

<span id='android-hardware-SensorManager-method-getInclination'>/**Computes the geomagnetic inclination angle in radians from the
</span> inclination matrix &lt;b&gt;I&lt;/b&gt; returned by {@link #getRotationMatrix}.
@param {Object {float[]}} I
        inclination matrix see {@link #getRotationMatrix}.
@return {Number} The geomagnetic inclination angle in radians.
@see #getRotationMatrix(float[], float[], float[], float[])
@see #getOrientation(float[], float[])
@see GeomagneticField
*/
getInclination : function(  ) {},

<span id='android-hardware-SensorManager-method-remapCoordinateSystem'>/**&lt;p&gt;
</span> Rotates the supplied rotation matrix so it is expressed in a different
 coordinate system. This is typically used when an application needs to
 compute the three orientation angles of the device (see
 {@link #getOrientation}) in a different coordinate system.
 &lt;/p&gt;

 &lt;p&gt;
 When the rotation matrix is used for drawing (for instance with OpenGL
 ES), it usually &lt;b&gt;doesn't need&lt;/b&gt; to be transformed by this function,
 unless the screen is physically rotated, in which case you can use
 {@link android.view.Display#getRotation() Display.getRotation()} to
 retrieve the current rotation of the screen. Note that because the user
 is generally free to rotate their screen, you often should consider the
 rotation in deciding the parameters to use here.
 &lt;/p&gt;

 &lt;p&gt;
 &lt;u&gt;Examples:&lt;/u&gt;
 &lt;p&gt;

 &lt;ul&gt;
 &lt;li&gt;Using the camera (Y axis along the camera's axis) for an augmented
 reality application where the rotation angles are needed:&lt;/li&gt;

 &lt;p&gt;
 &lt;ul&gt;
 &lt;code&gt;remapCoordinateSystem(inR, AXIS_X, AXIS_Z, outR);&lt;/code&gt;
 &lt;/ul&gt;
 &lt;/p&gt;

 &lt;li&gt;Using the device as a mechanical compass when rotation is
 {@link android.view.Surface#ROTATION_90 Surface.ROTATION_90}:&lt;/li&gt;

 &lt;p&gt;
 &lt;ul&gt;
 &lt;code&gt;remapCoordinateSystem(inR, AXIS_Y, AXIS_MINUS_X, outR);&lt;/code&gt;
 &lt;/ul&gt;
 &lt;/p&gt;

 Beware of the above example. This call is needed only to account for a
 rotation from its natural orientation when calculating the rotation
 angles (see {@link #getOrientation}). If the rotation matrix is also used
 for rendering, it may not need to be transformed, for instance if your
 {@link android.app.Activity Activity} is running in landscape mode.
 &lt;/ul&gt;

 &lt;p&gt;
 Since the resulting coordinate system is orthonormal, only two axes need
 to be specified.
@param {Object {float[]}} inR
        the rotation matrix to be transformed. Usually it is the matrix
        returned by {@link #getRotationMatrix}.
@param {Number} X
        defines the axis of the new cooridinate system that coincide with the X axis of the
        original coordinate system.
@param {Number} Y
        defines the axis of the new cooridinate system that coincide with the Y axis of the
        original coordinate system.
@param {Object {float[]}} outR
        the transformed rotation matrix. inR and outR should not be the same
        array.
@return {Boolean} &lt;code&gt;true&lt;/code&gt; on success. &lt;code&gt;false&lt;/code&gt; if the input
         parameters are incorrect, for instance if X and Y define the same
         axis. Or if inR and outR don't have the same length.
@see #getRotationMatrix(float[], float[], float[], float[])
*/
remapCoordinateSystem : function(  ) {},

<span id='android-hardware-SensorManager-method-getOrientation'>/**Computes the device's orientation based on the rotation matrix.
</span> &lt;p&gt;
 When it returns, the array values are as follows:
 &lt;ul&gt;
 &lt;li&gt;values[0]: &lt;i&gt;Azimuth&lt;/i&gt;, angle of rotation about the -z axis.
                This value represents the angle between the device's y
                axis and the magnetic north pole. When facing north, this
                angle is 0, when facing south, this angle is &amp;pi;.
                Likewise, when facing east, this angle is &amp;pi;/2, and
                when facing west, this angle is -&amp;pi;/2. The range of
                values is -&amp;pi; to &amp;pi;.&lt;/li&gt;
 &lt;li&gt;values[1]: &lt;i&gt;Pitch&lt;/i&gt;, angle of rotation about the x axis.
                This value represents the angle between a plane parallel
                to the device's screen and a plane parallel to the ground.
                Assuming that the bottom edge of the device faces the
                user and that the screen is face-up, tilting the top edge
                of the device toward the ground creates a positive pitch
                angle. The range of values is -&amp;pi; to &amp;pi;.&lt;/li&gt;
 &lt;li&gt;values[2]: &lt;i&gt;Roll&lt;/i&gt;, angle of rotation about the y axis. This
                value represents the angle between a plane perpendicular
                to the device's screen and a plane perpendicular to the
                ground. Assuming that the bottom edge of the device faces
                the user and that the screen is face-up, tilting the left
                edge of the device toward the ground creates a positive
                roll angle. The range of values is -&amp;pi;/2 to &amp;pi;/2.&lt;/li&gt;
 &lt;/ul&gt;
 &lt;p&gt;
 Applying these three rotations in the azimuth, pitch, roll order
 transforms an identity matrix to the rotation matrix passed into this
 method. Also, note that all three orientation angles are expressed in
 &lt;b&gt;radians&lt;/b&gt;.
@param {Object {float[]}} R
        rotation matrix see {@link #getRotationMatrix}.
@param {Object {float[]}} values
        an array of 3 floats to hold the result.
@return {Number} The array values passed as argument.
@see #getRotationMatrix(float[], float[], float[], float[])
@see GeomagneticField
*/
getOrientation : function(  ) {},

<span id='android-hardware-SensorManager-method-getAltitude'>/**Computes the Altitude in meters from the atmospheric pressure and the
</span> pressure at sea level.
 &lt;p&gt;
 Typically the atmospheric pressure is read from a
 {@link android.hardware.Sensor#TYPE_PRESSURE} sensor. The pressure at sea level must be
 known, usually it can be retrieved from airport databases in the
 vicinity. If unknown, you can use {@link #PRESSURE_STANDARD_ATMOSPHERE}
 as an approximation, but absolute altitudes won't be accurate.
 &lt;/p&gt;
 &lt;p&gt;
 To calculate altitude differences, you must calculate the difference
 between the altitudes at both points. If you don't know the altitude
 as sea level, you can use {@link #PRESSURE_STANDARD_ATMOSPHERE} instead,
 which will give good results considering the range of pressure typically
 involved.
 &lt;/p&gt;
 &lt;p&gt;
 &lt;code&gt;&lt;ul&gt;
  float altitude_difference =
      getAltitude(SensorManager.PRESSURE_STANDARD_ATMOSPHERE, pressure_at_point2)
      - getAltitude(SensorManager.PRESSURE_STANDARD_ATMOSPHERE, pressure_at_point1);
 &lt;/ul&gt;&lt;/code&gt;
 &lt;/p&gt;
@param {Number} p0 pressure at sea level
@param {Number} p atmospheric pressure
@return {Number} Altitude in meters
*/
getAltitude : function(  ) {},

<span id='android-hardware-SensorManager-method-getAngleChange'>/**Helper function to compute the angle change between two rotation matrices.
</span>  Given a current rotation matrix (R) and a previous rotation matrix
  (prevR) computes the intrinsic rotation around the z, x, and y axes which
  transforms prevR to R.
  outputs a 3 element vector containing the z, x, and y angle
  change at indexes 0, 1, and 2 respectively.
 &lt;p&gt; Each input matrix is either as a 3x3 or 4x4 row-major matrix
 depending on the length of the passed array:
 &lt;p&gt;If the array length is 9, then the array elements represent this matrix
 &lt;pre&gt;
   /  R[ 0]   R[ 1]   R[ 2]   \
   |  R[ 3]   R[ 4]   R[ 5]   |
   \  R[ 6]   R[ 7]   R[ 8]   /
&lt;/pre&gt;
 &lt;p&gt;If the array length is 16, then the array elements represent this matrix
 &lt;pre&gt;
   /  R[ 0]   R[ 1]   R[ 2]   R[ 3]  \
   |  R[ 4]   R[ 5]   R[ 6]   R[ 7]  |
   |  R[ 8]   R[ 9]   R[10]   R[11]  |
   \  R[12]   R[13]   R[14]   R[15]  /
&lt;/pre&gt;

 See {@link #getOrientation} for more detailed definition of the output.
@param {Object {float[]}} R current rotation matrix
@param {Object {float[]}} prevR previous rotation matrix
@param {Object {float[]}} angleChange an an array of floats (z, x, and y) in which the angle change
        (in radians) is stored
*/
getAngleChange : function(  ) {},

<span id='android-hardware-SensorManager-method-getRotationMatrixFromVector'>/**Helper function to convert a rotation vector to a rotation matrix.
</span>  Given a rotation vector (presumably from a ROTATION_VECTOR sensor), returns a
  9  or 16 element rotation matrix in the array R.  R must have length 9 or 16.
  If R.length == 9, the following matrix is returned:
 &lt;pre&gt;
   /  R[ 0]   R[ 1]   R[ 2]   \
   |  R[ 3]   R[ 4]   R[ 5]   |
   \  R[ 6]   R[ 7]   R[ 8]   /
&lt;/pre&gt;
 If R.length == 16, the following matrix is returned:
 &lt;pre&gt;
   /  R[ 0]   R[ 1]   R[ 2]   0  \
   |  R[ 4]   R[ 5]   R[ 6]   0  |
   |  R[ 8]   R[ 9]   R[10]   0  |
   \  0       0       0       1  /
&lt;/pre&gt;
@param {Object {float[]}} rotationVector the rotation vector to convert
@param {Object {float[]}} R an array of floats in which to store the rotation matrix
*/
getRotationMatrixFromVector : function(  ) {},

<span id='android-hardware-SensorManager-method-getQuaternionFromVector'>/**Helper function to convert a rotation vector to a normalized quaternion.
</span>  Given a rotation vector (presumably from a ROTATION_VECTOR sensor), returns a normalized
  quaternion in the array Q.  The quaternion is stored as [w, x, y, z]
@param {Object {float[]}} rv the rotation vector to convert
@param {Object {float[]}} Q an array of floats in which to store the computed quaternion
*/
getQuaternionFromVector : function(  ) {},

<span id='android-hardware-SensorManager-method-requestTriggerSensor'>/**Requests receiving trigger events for a trigger sensor.
</span>
 &lt;p&gt;
 When the sensor detects a trigger event condition, such as significant motion in
 the case of the {@link android.hardware.Sensor#TYPE_SIGNIFICANT_MOTION}, the provided trigger listener
 will be invoked once and then its request to receive trigger events will be canceled.
 To continue receiving trigger events, the application must request to receive trigger
 events again.
 &lt;/p&gt;
@param {Object {TriggerEventListener}} listener The listener on which the
        {@link TriggerEventListener#onTrigger(TriggerEvent)} will be delivered.
@param {Object {Sensor}} sensor The sensor to be enabled.
@return {Boolean} true if the sensor was successfully enabled.
@throws IllegalArgumentException when sensor is null or not a trigger sensor.
*/
requestTriggerSensor : function(  ) {},

<span id='android-hardware-SensorManager-method-cancelTriggerSensor'>/**Cancels receiving trigger events for a trigger sensor.
</span>
 &lt;p&gt;
 Note that a Trigger sensor will be auto disabled if
 {@link android.hardware.TriggerEventListener#onTrigger(android.hardware.TriggerEvent)} has triggered.
 This method is provided in case the user wants to explicitly cancel the request
 to receive trigger events.
 &lt;/p&gt;
@param {Object {TriggerEventListener}} listener The listener on which the
        {@link TriggerEventListener#onTrigger(TriggerEvent)}
        is delivered.It should be the same as the one used
        in {@link #requestTriggerSensor(TriggerEventListener, Sensor)}
@param {Object {Sensor}} sensor The sensor for which the trigger request should be canceled.
        If null, it cancels receiving trigger for all sensors associated
        with the listener.
@return {Boolean} true if successfully canceled.
@throws IllegalArgumentException when sensor is a trigger sensor.
*/
cancelTriggerSensor : function(  ) {},

<span id='android-hardware-SensorManager-method-initDataInjection'>/**For testing purposes only. Not for third party applications.
</span>
 Initialize data injection mode and create a client for data injection. SensorService should
 already be operating in DATA_INJECTION mode for this call succeed. To set SensorService into
 DATA_INJECTION mode &quot;adb shell dumpsys sensorservice data_injection&quot; needs to be called
 through adb. Typically this is done using a host side test.  This mode is expected to be used
 only for testing purposes. If the HAL is set to data injection mode, it will ignore the input
 from physical sensors and read sensor data that is injected from the test application. This
 mode is used for testing vendor implementations for various algorithms like Rotation Vector,
 Significant Motion, Step Counter etc. Not all HALs support DATA_INJECTION. This method will
 fail in those cases. Once this method succeeds, the test can call
 {@link injectSensorData(Sensor, float[], int, long)} to inject sensor data into the HAL.
@param {Boolean} enable True to initialize a client in DATA_INJECTION mode.
               False to clean up the native resources.
@return {Boolean} true if the HAL supports data injection and false
         otherwise.
@hide 
*/
initDataInjection : function(  ) {},

<span id='android-hardware-SensorManager-method-injectSensorData'>/**For testing purposes only. Not for third party applications.
</span>
 This method is used to inject raw sensor data into the HAL.  Call {@link initDataInjection}(boolean) before this method to set the HAL in data injection mode. This
 method should be called only if a previous call to initDataInjection has been successful and
 the HAL and SensorService are already opreating in data injection mode.
@param {Object {Sensor}} sensor The sensor to inject.
@param {Object {float[]}} values Sensor values to inject. The length of this
               array must be exactly equal to the number of
               values reported by the sensor type.
@param {Number} accuracy Accuracy of the sensor.
@param {Number} timestamp Sensor timestamp associated with the event.
@return {Boolean} boolean True if the data injection succeeds, false
         otherwise.
@throws IllegalArgumentException when the sensor is null,
         data injection is not supported by the sensor, values
         are null, incorrect number of values for the sensor,
         sensor accuracy is incorrect or timestamps are
         invalid.
@hide 
*/
injectSensorData : function(  ) {},

<span id='android-hardware-SensorManager-method-setOperationParameter'>/**
</span>@hide 
*/
setOperationParameter : function(  ) {},


};</pre>
</body>
</html>
