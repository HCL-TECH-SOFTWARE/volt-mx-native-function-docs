<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='android-media-MediaPlayer'>/**@class android.media.MediaPlayer
</span> implements android.media.SubtitleController.Listener

 implements android.media.VolumeAutomation

 implements android.media.AudioRouting

@extends android.media.PlayerBase

 MediaPlayer class can be used to control playback
 of audio/video files and streams. An example on how to use the methods in
 this class can be found in {@link android.widget.VideoView}.

 &lt;p&gt;Topics covered here are:
 &lt;ol&gt;
 &lt;li&gt;&lt;a href=&quot;#StateDiagram&quot;&gt;State Diagram&lt;/a&gt;
 &lt;li&gt;&lt;a href=&quot;#Valid_and_Invalid_States&quot;&gt;Valid and Invalid States&lt;/a&gt;
 &lt;li&gt;&lt;a href=&quot;#Permissions&quot;&gt;Permissions&lt;/a&gt;
 &lt;li&gt;&lt;a href=&quot;#Callbacks&quot;&gt;Register informational and error callbacks&lt;/a&gt;
 &lt;/ol&gt;

 &lt;div class=&quot;special reference&quot;&gt;
 &lt;h3&gt;Developer Guides&lt;/h3&gt;
 &lt;p&gt;For more information about how to use MediaPlayer, read the
 &lt;a href=&quot;{@docRoot}guide/topics/media/mediaplayer.html&quot;&gt;Media Playback&lt;/a&gt; developer guide.&lt;/p&gt;
 &lt;/div&gt;

 &lt;a name=&quot;StateDiagram&quot;&gt;&lt;/a&gt;
 &lt;h3&gt;State Diagram&lt;/h3&gt;

 &lt;p&gt;Playback control of audio/video files and streams is managed as a state
 machine. The following diagram shows the life cycle and the states of a
 MediaPlayer object driven by the supported playback control operations.
 The ovals represent the states a MediaPlayer object may reside
 in. The arcs represent the playback control operations that drive the object
 state transition. There are two types of arcs. The arcs with a single arrow
 head represent synchronous method calls, while those with
 a double arrow head represent asynchronous method calls.&lt;/p&gt;

 &lt;p&gt;&lt;img src=&quot;../../../images/mediaplayer_state_diagram.gif&quot;
         alt=&quot;MediaPlayer State diagram&quot;
         border=&quot;0&quot; /&gt;&lt;/p&gt;

 &lt;p&gt;From this state diagram, one can see that a MediaPlayer object has the
    following states:&lt;/p&gt;
 &lt;ul&gt;
     &lt;li&gt;When a MediaPlayer object is just created using &lt;code&gt;new&lt;/code&gt; or
         after {@link #reset}() is called, it is in the &lt;em&gt;Idle&lt;/em&gt; state; and after
         {@link #release}() is called, it is in the &lt;em&gt;End&lt;/em&gt; state. Between these
         two states is the life cycle of the MediaPlayer object.
         &lt;ul&gt;
         &lt;li&gt;There is a subtle but important difference between a newly constructed
         MediaPlayer object and the MediaPlayer object after {@link #reset}()
         is called. It is a programming error to invoke methods such
         as {@link #getCurrentPosition}(),
         {@link #getDuration}(), {@link #getVideoHeight}(),
         {@link #getVideoWidth}(), {@link #setAudioAttributes}(AudioAttributes),
         {@link #setLooping}(boolean),
         {@link #setVolume(float, float)}, {@link #pause}(), {@link #start}(),
         {@link #stop}(), {@link #seekTo(long, int)}, {@link #prepare}() or
         {@link #prepareAsync}() in the &lt;em&gt;Idle&lt;/em&gt; state for both cases. If any of these
         methods is called right after a MediaPlayer object is constructed,
         the user supplied callback method OnErrorListener.onError() won't be
         called by the internal player engine and the object state remains
         unchanged; but if these methods are called right after {@link #reset}(),
         the user supplied callback method OnErrorListener.onError() will be
         invoked by the internal player engine and the object will be
         transfered to the &lt;em&gt;Error&lt;/em&gt; state. &lt;/li&gt;
         &lt;li&gt;It is also recommended that once
         a MediaPlayer object is no longer being used, call {@link #release}() immediately
         so that resources used by the internal player engine associated with the
         MediaPlayer object can be released immediately. Resource may include
         singleton resources such as hardware acceleration components and
         failure to call {@link #release}() may cause subsequent instances of
         MediaPlayer objects to fallback to software implementations or fail
         altogether. Once the MediaPlayer
         object is in the &lt;em&gt;End&lt;/em&gt; state, it can no longer be used and
         there is no way to bring it back to any other state. &lt;/li&gt;
         &lt;li&gt;Furthermore,
         the MediaPlayer objects created using &lt;code&gt;new&lt;/code&gt; is in the
         &lt;em&gt;Idle&lt;/em&gt; state, while those created with one
         of the overloaded convenient &lt;code&gt;create&lt;/code&gt; methods are &lt;em&gt;NOT&lt;/em&gt;
         in the &lt;em&gt;Idle&lt;/em&gt; state. In fact, the objects are in the &lt;em&gt;Prepared&lt;/em&gt;
         state if the creation using &lt;code&gt;create&lt;/code&gt; method is successful.
         &lt;/li&gt;
         &lt;/ul&gt;
         &lt;/li&gt;
     &lt;li&gt;In general, some playback control operation may fail due to various
         reasons, such as unsupported audio/video format, poorly interleaved
         audio/video, resolution too high, streaming timeout, and the like.
         Thus, error reporting and recovery is an important concern under
         these circumstances. Sometimes, due to programming errors, invoking a playback
         control operation in an invalid state may also occur. Under all these
         error conditions, the internal player engine invokes a user supplied
         OnErrorListener.onError() method if an OnErrorListener has been
         registered beforehand via
         {@link #setOnErrorListener(android.media.MediaPlayer.OnErrorListener)}.
         &lt;ul&gt;
         &lt;li&gt;It is important to note that once an error occurs, the
         MediaPlayer object enters the &lt;em&gt;Error&lt;/em&gt; state (except as noted
         above), even if an error listener has not been registered by the application.&lt;/li&gt;
         &lt;li&gt;In order to reuse a MediaPlayer object that is in the &lt;em&gt;
         Error&lt;/em&gt; state and recover from the error,
         {@link #reset}() can be called to restore the object to its &lt;em&gt;Idle&lt;/em&gt;
         state.&lt;/li&gt;
         &lt;li&gt;It is good programming practice to have your application
         register a OnErrorListener to look out for error notifications from
         the internal player engine.&lt;/li&gt;
         &lt;li&gt;IllegalStateException is
         thrown to prevent programming errors such as calling {@link #prepare}(),
         {@link #prepareAsync}(), or one of the overloaded &lt;code&gt;setDataSource
         &lt;/code&gt; methods in an invalid state. &lt;/li&gt;
         &lt;/ul&gt;
         &lt;/li&gt;
     &lt;li&gt;Calling
         {@link #setDataSource}(FileDescriptor), or
         {@link #setDataSource}(String), or
         {@link #setDataSource(Context, Uri)}, or
         {@link #setDataSource(FileDescriptor, long, long)}, or
         {@link #setDataSource}(MediaDataSource) transfers a
         MediaPlayer object in the &lt;em&gt;Idle&lt;/em&gt; state to the
         &lt;em&gt;Initialized&lt;/em&gt; state.
         &lt;ul&gt;
         &lt;li&gt;An IllegalStateException is thrown if
         setDataSource() is called in any other state.&lt;/li&gt;
         &lt;li&gt;It is good programming
         practice to always look out for &lt;code&gt;IllegalArgumentException&lt;/code&gt;
         and &lt;code&gt;IOException&lt;/code&gt; that may be thrown from the overloaded
         &lt;code&gt;setDataSource&lt;/code&gt; methods.&lt;/li&gt;
         &lt;/ul&gt;
         &lt;/li&gt;
     &lt;li&gt;A MediaPlayer object must first enter the &lt;em&gt;Prepared&lt;/em&gt; state
         before playback can be started.
         &lt;ul&gt;
         &lt;li&gt;There are two ways (synchronous vs.
         asynchronous) that the &lt;em&gt;Prepared&lt;/em&gt; state can be reached:
         either a call to {@link #prepare}() (synchronous) which
         transfers the object to the &lt;em&gt;Prepared&lt;/em&gt; state once the method call
         returns, or a call to {@link #prepareAsync}() (asynchronous) which
         first transfers the object to the &lt;em&gt;Preparing&lt;/em&gt; state after the
         call returns (which occurs almost right away) while the internal
         player engine continues working on the rest of preparation work
         until the preparation work completes. When the preparation completes or when {@link #prepare}() call returns,
         the internal player engine then calls a user supplied callback method,
         onPrepared() of the OnPreparedListener interface, if an
         OnPreparedListener is registered beforehand via {@link #setOnPreparedListener(android.media.MediaPlayer.OnPreparedListener)}.&lt;/li&gt;
         &lt;li&gt;It is important to note that
         the &lt;em&gt;Preparing&lt;/em&gt; state is a transient state, and the behavior
         of calling any method with side effect while a MediaPlayer object is
         in the &lt;em&gt;Preparing&lt;/em&gt; state is undefined.&lt;/li&gt;
         &lt;li&gt;An IllegalStateException is
         thrown if {@link #prepare}() or {@link #prepareAsync}() is called in
         any other state.&lt;/li&gt;
         &lt;li&gt;While in the &lt;em&gt;Prepared&lt;/em&gt; state, properties
         such as audio/sound volume, screenOnWhilePlaying, looping can be
         adjusted by invoking the corresponding set methods.&lt;/li&gt;
         &lt;/ul&gt;
         &lt;/li&gt;
     &lt;li&gt;To start the playback, {@link #start}() must be called. After
         {@link #start}() returns successfully, the MediaPlayer object is in the
         &lt;em&gt;Started&lt;/em&gt; state. {@link #isPlaying}() can be called to test
         whether the MediaPlayer object is in the &lt;em&gt;Started&lt;/em&gt; state.
         &lt;ul&gt;
         &lt;li&gt;While in the &lt;em&gt;Started&lt;/em&gt; state, the internal player engine calls
         a user supplied OnBufferingUpdateListener.onBufferingUpdate() callback
         method if a OnBufferingUpdateListener has been registered beforehand
         via {@link #setOnBufferingUpdateListener}(OnBufferingUpdateListener).
         This callback allows applications to keep track of the buffering status
         while streaming audio/video.&lt;/li&gt;
         &lt;li&gt;Calling {@link #start}() has not effect
         on a MediaPlayer object that is already in the &lt;em&gt;Started&lt;/em&gt; state.&lt;/li&gt;
         &lt;/ul&gt;
         &lt;/li&gt;
     &lt;li&gt;Playback can be paused and stopped, and the current playback position
         can be adjusted. Playback can be paused via {@link #pause}(). When the call to
         {@link #pause}() returns, the MediaPlayer object enters the
         &lt;em&gt;Paused&lt;/em&gt; state. Note that the transition from the &lt;em&gt;Started&lt;/em&gt;
         state to the &lt;em&gt;Paused&lt;/em&gt; state and vice versa happens
         asynchronously in the player engine. It may take some time before
         the state is updated in calls to {@link #isPlaying}(), and it can be
         a number of seconds in the case of streamed content.
         &lt;ul&gt;
         &lt;li&gt;Calling {@link #start}() to resume playback for a paused
         MediaPlayer object, and the resumed playback
         position is the same as where it was paused. When the call to
         {@link #start}() returns, the paused MediaPlayer object goes back to
         the &lt;em&gt;Started&lt;/em&gt; state.&lt;/li&gt;
         &lt;li&gt;Calling {@link #pause}() has no effect on
         a MediaPlayer object that is already in the &lt;em&gt;Paused&lt;/em&gt; state.&lt;/li&gt;
         &lt;/ul&gt;
         &lt;/li&gt;
     &lt;li&gt;Calling  {@link #stop}() stops playback and causes a
         MediaPlayer in the &lt;em&gt;Started&lt;/em&gt;, &lt;em&gt;Paused&lt;/em&gt;, &lt;em&gt;Prepared
         &lt;/em&gt; or &lt;em&gt;PlaybackCompleted&lt;/em&gt; state to enter the
         &lt;em&gt;Stopped&lt;/em&gt; state.
         &lt;ul&gt;
         &lt;li&gt;Once in the &lt;em&gt;Stopped&lt;/em&gt; state, playback cannot be started
         until {@link #prepare}() or {@link #prepareAsync}() are called to set
         the MediaPlayer object to the &lt;em&gt;Prepared&lt;/em&gt; state again.&lt;/li&gt;
         &lt;li&gt;Calling {@link #stop}() has no effect on a MediaPlayer
         object that is already in the &lt;em&gt;Stopped&lt;/em&gt; state.&lt;/li&gt;
         &lt;/ul&gt;
         &lt;/li&gt;
     &lt;li&gt;The playback position can be adjusted with a call to
         {@link #seekTo(long, int)}.
         &lt;ul&gt;
         &lt;li&gt;Although the asynchronuous {@link #seekTo(long, int)}
         call returns right away, the actual seek operation may take a while to
         finish, especially for audio/video being streamed. When the actual
         seek operation completes, the internal player engine calls a user
         supplied OnSeekComplete.onSeekComplete() if an OnSeekCompleteListener
         has been registered beforehand via
         {@link #setOnSeekCompleteListener}(OnSeekCompleteListener).&lt;/li&gt;
         &lt;li&gt;Please
         note that {@link #seekTo(long, int)} can also be called in the other states,
         such as &lt;em&gt;Prepared&lt;/em&gt;, &lt;em&gt;Paused&lt;/em&gt; and &lt;em&gt;PlaybackCompleted
         &lt;/em&gt; state. When {@link #seekTo(long, int)} is called in those states,
         one video frame will be displayed if the stream has video and the requested
         position is valid.
         &lt;/li&gt;
         &lt;li&gt;Furthermore, the actual current playback position
         can be retrieved with a call to {@link #getCurrentPosition}(), which
         is helpful for applications such as a Music player that need to keep
         track of the playback progress.&lt;/li&gt;
         &lt;/ul&gt;
         &lt;/li&gt;
     &lt;li&gt;When the playback reaches the end of stream, the playback completes.
         &lt;ul&gt;
         &lt;li&gt;If the looping mode was being set to &lt;var&gt;true&lt;/var&gt;with
         {@link #setLooping}(boolean), the MediaPlayer object shall remain in
         the &lt;em&gt;Started&lt;/em&gt; state.&lt;/li&gt;
         &lt;li&gt;If the looping mode was set to &lt;var&gt;false
         &lt;/var&gt;, the player engine calls a user supplied callback method,
         OnCompletion.onCompletion(), if a OnCompletionListener is registered
         beforehand via {@link #setOnCompletionListener}(OnCompletionListener).
         The invoke of the callback signals that the object is now in the &lt;em&gt;
         PlaybackCompleted&lt;/em&gt; state.&lt;/li&gt;
         &lt;li&gt;While in the &lt;em&gt;PlaybackCompleted&lt;/em&gt;
         state, calling {@link #start}() can restart the playback from the
         beginning of the audio/video source.&lt;/li&gt;
 &lt;/ul&gt;


 &lt;a name=&quot;Valid_and_Invalid_States&quot;&gt;&lt;/a&gt;
 &lt;h3&gt;Valid and invalid states&lt;/h3&gt;

 &lt;table border=&quot;0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;
 &lt;tr&gt;&lt;td&gt;Method Name &lt;/p&gt;&lt;/td&gt;
     &lt;td&gt;Valid States &lt;/p&gt;&lt;/td&gt;
     &lt;td&gt;Invalid States &lt;/p&gt;&lt;/td&gt;
     &lt;td&gt;Comments &lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;attachAuxEffect &lt;/p&gt;&lt;/td&gt;
     &lt;td&gt;{Initialized, Prepared, Started, Paused, Stopped, PlaybackCompleted} &lt;/p&gt;&lt;/td&gt;
     &lt;td&gt;{Idle, Error} &lt;/p&gt;&lt;/td&gt;
     &lt;td&gt;This method must be called after setDataSource.
     Calling it does not change the object state. &lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;getAudioSessionId &lt;/p&gt;&lt;/td&gt;
     &lt;td&gt;any &lt;/p&gt;&lt;/td&gt;
     &lt;td&gt;{} &lt;/p&gt;&lt;/td&gt;
     &lt;td&gt;This method can be called in any state and calling it does not change
         the object state. &lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;getCurrentPosition &lt;/p&gt;&lt;/td&gt;
     &lt;td&gt;{Idle, Initialized, Prepared, Started, Paused, Stopped,
         PlaybackCompleted} &lt;/p&gt;&lt;/td&gt;
     &lt;td&gt;{Error}&lt;/p&gt;&lt;/td&gt;
     &lt;td&gt;Successful invoke of this method in a valid state does not change the
         state. Calling this method in an invalid state transfers the object
         to the &lt;em&gt;Error&lt;/em&gt; state. &lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;getDuration &lt;/p&gt;&lt;/td&gt;
     &lt;td&gt;{Prepared, Started, Paused, Stopped, PlaybackCompleted} &lt;/p&gt;&lt;/td&gt;
     &lt;td&gt;{Idle, Initialized, Error} &lt;/p&gt;&lt;/td&gt;
     &lt;td&gt;Successful invoke of this method in a valid state does not change the
         state. Calling this method in an invalid state transfers the object
         to the &lt;em&gt;Error&lt;/em&gt; state. &lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;getVideoHeight &lt;/p&gt;&lt;/td&gt;
     &lt;td&gt;{Idle, Initialized, Prepared, Started, Paused, Stopped,
         PlaybackCompleted}&lt;/p&gt;&lt;/td&gt;
     &lt;td&gt;{Error}&lt;/p&gt;&lt;/td&gt;
     &lt;td&gt;Successful invoke of this method in a valid state does not change the
         state. Calling this method in an invalid state transfers the object
         to the &lt;em&gt;Error&lt;/em&gt; state.  &lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;getVideoWidth &lt;/p&gt;&lt;/td&gt;
     &lt;td&gt;{Idle, Initialized, Prepared, Started, Paused, Stopped,
         PlaybackCompleted}&lt;/p&gt;&lt;/td&gt;
     &lt;td&gt;{Error}&lt;/p&gt;&lt;/td&gt;
     &lt;td&gt;Successful invoke of this method in a valid state does not change
         the state. Calling this method in an invalid state transfers the
         object to the &lt;em&gt;Error&lt;/em&gt; state. &lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;isPlaying &lt;/p&gt;&lt;/td&gt;
     &lt;td&gt;{Idle, Initialized, Prepared, Started, Paused, Stopped,
          PlaybackCompleted}&lt;/p&gt;&lt;/td&gt;
     &lt;td&gt;{Error}&lt;/p&gt;&lt;/td&gt;
     &lt;td&gt;Successful invoke of this method in a valid state does not change
         the state. Calling this method in an invalid state transfers the
         object to the &lt;em&gt;Error&lt;/em&gt; state. &lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;pause &lt;/p&gt;&lt;/td&gt;
     &lt;td&gt;{Started, Paused, PlaybackCompleted}&lt;/p&gt;&lt;/td&gt;
     &lt;td&gt;{Idle, Initialized, Prepared, Stopped, Error}&lt;/p&gt;&lt;/td&gt;
     &lt;td&gt;Successful invoke of this method in a valid state transfers the
         object to the &lt;em&gt;Paused&lt;/em&gt; state. Calling this method in an
         invalid state transfers the object to the &lt;em&gt;Error&lt;/em&gt; state.&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;prepare &lt;/p&gt;&lt;/td&gt;
     &lt;td&gt;{Initialized, Stopped} &lt;/p&gt;&lt;/td&gt;
     &lt;td&gt;{Idle, Prepared, Started, Paused, PlaybackCompleted, Error} &lt;/p&gt;&lt;/td&gt;
     &lt;td&gt;Successful invoke of this method in a valid state transfers the
         object to the &lt;em&gt;Prepared&lt;/em&gt; state. Calling this method in an
         invalid state throws an IllegalStateException.&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;prepareAsync &lt;/p&gt;&lt;/td&gt;
     &lt;td&gt;{Initialized, Stopped} &lt;/p&gt;&lt;/td&gt;
     &lt;td&gt;{Idle, Prepared, Started, Paused, PlaybackCompleted, Error} &lt;/p&gt;&lt;/td&gt;
     &lt;td&gt;Successful invoke of this method in a valid state transfers the
         object to the &lt;em&gt;Preparing&lt;/em&gt; state. Calling this method in an
         invalid state throws an IllegalStateException.&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;release &lt;/p&gt;&lt;/td&gt;
     &lt;td&gt;any &lt;/p&gt;&lt;/td&gt;
     &lt;td&gt;{} &lt;/p&gt;&lt;/td&gt;
     &lt;td&gt;After {@link #release}(), the object is no longer available. &lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;reset &lt;/p&gt;&lt;/td&gt;
     &lt;td&gt;{Idle, Initialized, Prepared, Started, Paused, Stopped,
         PlaybackCompleted, Error}&lt;/p&gt;&lt;/td&gt;
     &lt;td&gt;{}&lt;/p&gt;&lt;/td&gt;
     &lt;td&gt;After {@link #reset}(), the object is like being just created.&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;seekTo &lt;/p&gt;&lt;/td&gt;
     &lt;td&gt;{Prepared, Started, Paused, PlaybackCompleted} &lt;/p&gt;&lt;/td&gt;
     &lt;td&gt;{Idle, Initialized, Stopped, Error}&lt;/p&gt;&lt;/td&gt;
     &lt;td&gt;Successful invoke of this method in a valid state does not change
         the state. Calling this method in an invalid state transfers the
         object to the &lt;em&gt;Error&lt;/em&gt; state. &lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;setAudioAttributes &lt;/p&gt;&lt;/td&gt;
     &lt;td&gt;{Idle, Initialized, Stopped, Prepared, Started, Paused,
          PlaybackCompleted}&lt;/p&gt;&lt;/td&gt;
     &lt;td&gt;{Error}&lt;/p&gt;&lt;/td&gt;
     &lt;td&gt;Successful invoke of this method does not change the state. In order for the
         target audio attributes type to become effective, this method must be called before
         prepare() or prepareAsync().&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;setAudioSessionId &lt;/p&gt;&lt;/td&gt;
     &lt;td&gt;{Idle} &lt;/p&gt;&lt;/td&gt;
     &lt;td&gt;{Initialized, Prepared, Started, Paused, Stopped, PlaybackCompleted,
          Error} &lt;/p&gt;&lt;/td&gt;
     &lt;td&gt;This method must be called in idle state as the audio session ID must be known before
         calling setDataSource. Calling it does not change the object state. &lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;setAudioStreamType (deprecated)&lt;/p&gt;&lt;/td&gt;
     &lt;td&gt;{Idle, Initialized, Stopped, Prepared, Started, Paused,
          PlaybackCompleted}&lt;/p&gt;&lt;/td&gt;
     &lt;td&gt;{Error}&lt;/p&gt;&lt;/td&gt;
     &lt;td&gt;Successful invoke of this method does not change the state. In order for the
         target audio stream type to become effective, this method must be called before
         prepare() or prepareAsync().&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;setAuxEffectSendLevel &lt;/p&gt;&lt;/td&gt;
     &lt;td&gt;any&lt;/p&gt;&lt;/td&gt;
     &lt;td&gt;{} &lt;/p&gt;&lt;/td&gt;
     &lt;td&gt;Calling this method does not change the object state. &lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;setDataSource &lt;/p&gt;&lt;/td&gt;
     &lt;td&gt;{Idle} &lt;/p&gt;&lt;/td&gt;
     &lt;td&gt;{Initialized, Prepared, Started, Paused, Stopped, PlaybackCompleted,
          Error} &lt;/p&gt;&lt;/td&gt;
     &lt;td&gt;Successful invoke of this method in a valid state transfers the
         object to the &lt;em&gt;Initialized&lt;/em&gt; state. Calling this method in an
         invalid state throws an IllegalStateException.&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;setDisplay &lt;/p&gt;&lt;/td&gt;
     &lt;td&gt;any &lt;/p&gt;&lt;/td&gt;
     &lt;td&gt;{} &lt;/p&gt;&lt;/td&gt;
     &lt;td&gt;This method can be called in any state and calling it does not change
         the object state. &lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;setSurface &lt;/p&gt;&lt;/td&gt;
     &lt;td&gt;any &lt;/p&gt;&lt;/td&gt;
     &lt;td&gt;{} &lt;/p&gt;&lt;/td&gt;
     &lt;td&gt;This method can be called in any state and calling it does not change
         the object state. &lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;setVideoScalingMode &lt;/p&gt;&lt;/td&gt;
     &lt;td&gt;{Initialized, Prepared, Started, Paused, Stopped, PlaybackCompleted} &lt;/p&gt;&lt;/td&gt;
     &lt;td&gt;{Idle, Error}&lt;/p&gt;&lt;/td&gt;
     &lt;td&gt;Successful invoke of this method does not change the state.&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;setLooping &lt;/p&gt;&lt;/td&gt;
     &lt;td&gt;{Idle, Initialized, Stopped, Prepared, Started, Paused,
         PlaybackCompleted}&lt;/p&gt;&lt;/td&gt;
     &lt;td&gt;{Error}&lt;/p&gt;&lt;/td&gt;
     &lt;td&gt;Successful invoke of this method in a valid state does not change
         the state. Calling this method in an
         invalid state transfers the object to the &lt;em&gt;Error&lt;/em&gt; state.&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;isLooping &lt;/p&gt;&lt;/td&gt;
     &lt;td&gt;any &lt;/p&gt;&lt;/td&gt;
     &lt;td&gt;{} &lt;/p&gt;&lt;/td&gt;
     &lt;td&gt;This method can be called in any state and calling it does not change
         the object state. &lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;setOnBufferingUpdateListener &lt;/p&gt;&lt;/td&gt;
     &lt;td&gt;any &lt;/p&gt;&lt;/td&gt;
     &lt;td&gt;{} &lt;/p&gt;&lt;/td&gt;
     &lt;td&gt;This method can be called in any state and calling it does not change
         the object state. &lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;setOnCompletionListener &lt;/p&gt;&lt;/td&gt;
     &lt;td&gt;any &lt;/p&gt;&lt;/td&gt;
     &lt;td&gt;{} &lt;/p&gt;&lt;/td&gt;
     &lt;td&gt;This method can be called in any state and calling it does not change
         the object state. &lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;setOnErrorListener &lt;/p&gt;&lt;/td&gt;
     &lt;td&gt;any &lt;/p&gt;&lt;/td&gt;
     &lt;td&gt;{} &lt;/p&gt;&lt;/td&gt;
     &lt;td&gt;This method can be called in any state and calling it does not change
         the object state. &lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;setOnPreparedListener &lt;/p&gt;&lt;/td&gt;
     &lt;td&gt;any &lt;/p&gt;&lt;/td&gt;
     &lt;td&gt;{} &lt;/p&gt;&lt;/td&gt;
     &lt;td&gt;This method can be called in any state and calling it does not change
         the object state. &lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;setOnSeekCompleteListener &lt;/p&gt;&lt;/td&gt;
     &lt;td&gt;any &lt;/p&gt;&lt;/td&gt;
     &lt;td&gt;{} &lt;/p&gt;&lt;/td&gt;
     &lt;td&gt;This method can be called in any state and calling it does not change
         the object state. &lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;setPlaybackParams&lt;/p&gt;&lt;/td&gt;
     &lt;td&gt;{Initialized, Prepared, Started, Paused, PlaybackCompleted, Error}&lt;/p&gt;&lt;/td&gt;
     &lt;td&gt;{Idle, Stopped} &lt;/p&gt;&lt;/td&gt;
     &lt;td&gt;This method will change state in some cases, depending on when it's called.
         &lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;setScreenOnWhilePlaying&lt;/&gt;&lt;/td&gt;
     &lt;td&gt;any &lt;/p&gt;&lt;/td&gt;
     &lt;td&gt;{} &lt;/p&gt;&lt;/td&gt;
     &lt;td&gt;This method can be called in any state and calling it does not change
         the object state.  &lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;setVolume &lt;/p&gt;&lt;/td&gt;
     &lt;td&gt;{Idle, Initialized, Stopped, Prepared, Started, Paused,
          PlaybackCompleted}&lt;/p&gt;&lt;/td&gt;
     &lt;td&gt;{Error}&lt;/p&gt;&lt;/td&gt;
     &lt;td&gt;Successful invoke of this method does not change the state.
 &lt;tr&gt;&lt;td&gt;setWakeMode &lt;/p&gt;&lt;/td&gt;
     &lt;td&gt;any &lt;/p&gt;&lt;/td&gt;
     &lt;td&gt;{} &lt;/p&gt;&lt;/td&gt;
     &lt;td&gt;This method can be called in any state and calling it does not change
         the object state.&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;start &lt;/p&gt;&lt;/td&gt;
     &lt;td&gt;{Prepared, Started, Paused, PlaybackCompleted}&lt;/p&gt;&lt;/td&gt;
     &lt;td&gt;{Idle, Initialized, Stopped, Error}&lt;/p&gt;&lt;/td&gt;
     &lt;td&gt;Successful invoke of this method in a valid state transfers the
         object to the &lt;em&gt;Started&lt;/em&gt; state. Calling this method in an
         invalid state transfers the object to the &lt;em&gt;Error&lt;/em&gt; state.&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;stop &lt;/p&gt;&lt;/td&gt;
     &lt;td&gt;{Prepared, Started, Stopped, Paused, PlaybackCompleted}&lt;/p&gt;&lt;/td&gt;
     &lt;td&gt;{Idle, Initialized, Error}&lt;/p&gt;&lt;/td&gt;
     &lt;td&gt;Successful invoke of this method in a valid state transfers the
         object to the &lt;em&gt;Stopped&lt;/em&gt; state. Calling this method in an
         invalid state transfers the object to the &lt;em&gt;Error&lt;/em&gt; state.&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;getTrackInfo &lt;/p&gt;&lt;/td&gt;
     &lt;td&gt;{Prepared, Started, Stopped, Paused, PlaybackCompleted}&lt;/p&gt;&lt;/td&gt;
     &lt;td&gt;{Idle, Initialized, Error}&lt;/p&gt;&lt;/td&gt;
     &lt;td&gt;Successful invoke of this method does not change the state.&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;addTimedTextSource &lt;/p&gt;&lt;/td&gt;
     &lt;td&gt;{Prepared, Started, Stopped, Paused, PlaybackCompleted}&lt;/p&gt;&lt;/td&gt;
     &lt;td&gt;{Idle, Initialized, Error}&lt;/p&gt;&lt;/td&gt;
     &lt;td&gt;Successful invoke of this method does not change the state.&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;selectTrack &lt;/p&gt;&lt;/td&gt;
     &lt;td&gt;{Prepared, Started, Stopped, Paused, PlaybackCompleted}&lt;/p&gt;&lt;/td&gt;
     &lt;td&gt;{Idle, Initialized, Error}&lt;/p&gt;&lt;/td&gt;
     &lt;td&gt;Successful invoke of this method does not change the state.&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;deselectTrack &lt;/p&gt;&lt;/td&gt;
     &lt;td&gt;{Prepared, Started, Stopped, Paused, PlaybackCompleted}&lt;/p&gt;&lt;/td&gt;
     &lt;td&gt;{Idle, Initialized, Error}&lt;/p&gt;&lt;/td&gt;
     &lt;td&gt;Successful invoke of this method does not change the state.&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;

 &lt;/table&gt;

 &lt;a name=&quot;Permissions&quot;&gt;&lt;/a&gt;
 &lt;h3&gt;Permissions&lt;/h3&gt;
 &lt;p&gt;One may need to declare a corresponding WAKE_LOCK permission {@link android.R.styleable#AndroidManifestUsesPermission &amp;lt;uses-permission&amp;gt;}
 element.

 &lt;p&gt;This class requires the {@link android.Manifest.permission#INTERNET} permission
 when used with network-based content.

 &lt;a name=&quot;Callbacks&quot;&gt;&lt;/a&gt;
 &lt;h3&gt;Callbacks&lt;/h3&gt;
 &lt;p&gt;Applications may want to register for informational and error
 events in order to be informed of some internal state update and
 possible runtime errors during playback or streaming. Registration for
 these events is done by properly setting the appropriate listeners (via calls
 to
 {@link #setOnPreparedListener}(OnPreparedListener)setOnPreparedListener,
 {@link #setOnVideoSizeChangedListener}(OnVideoSizeChangedListener)setOnVideoSizeChangedListener,
 {@link #setOnSeekCompleteListener}(OnSeekCompleteListener)setOnSeekCompleteListener,
 {@link #setOnCompletionListener}(OnCompletionListener)setOnCompletionListener,
 {@link #setOnBufferingUpdateListener}(OnBufferingUpdateListener)setOnBufferingUpdateListener,
 {@link #setOnInfoListener}(OnInfoListener)setOnInfoListener,
 {@link #setOnErrorListener}(OnErrorListener)setOnErrorListener, etc).
 In order to receive the respective callback
 associated with these listeners, applications are required to create
 MediaPlayer objects on a thread with its own Looper running (main UI
 thread by default has a Looper running).

*/
var MediaPlayer = {

<span id='android-media-MediaPlayer-property-METADATA_UPDATE_ONLY'>/**       Constant to retrieve only the new metadata since the last
</span>       call.
       // FIXME: unhide.
       // FIXME: add link to getMetadata(boolean, boolean)
       {@hide}
*/
METADATA_UPDATE_ONLY : &quot;true&quot;,
<span id='android-media-MediaPlayer-property-METADATA_ALL'>/**       Constant to retrieve all the metadata.
</span>       // FIXME: unhide.
       // FIXME: add link to getMetadata(boolean, boolean)
       {@hide}
*/
METADATA_ALL : &quot;false&quot;,
<span id='android-media-MediaPlayer-property-APPLY_METADATA_FILTER'>/**       Constant to enable the metadata filter during retrieval.
</span>       // FIXME: unhide.
       // FIXME: add link to getMetadata(boolean, boolean)
       {@hide}
*/
APPLY_METADATA_FILTER : &quot;true&quot;,
<span id='android-media-MediaPlayer-property-BYPASS_METADATA_FILTER'>/**       Constant to disable the metadata filter during retrieval.
</span>       // FIXME: unhide.
       // FIXME: add link to getMetadata(boolean, boolean)
       {@hide}
*/
BYPASS_METADATA_FILTER : &quot;false&quot;,
<span id='android-media-MediaPlayer-property-VIDEO_SCALING_MODE_SCALE_TO_FIT'>/** Specifies a video scaling mode. The content is stretched to the
</span> surface rendering area. When the surface has the same aspect ratio
 as the content, the aspect ratio of the content is maintained;
 otherwise, the aspect ratio of the content is not maintained when video
 is being rendered. Unlike {@link #VIDEO_SCALING_MODE_SCALE_TO_FIT_WITH_CROPPING},
 there is no content cropping with this video scaling mode.
*/
VIDEO_SCALING_MODE_SCALE_TO_FIT : &quot;1&quot;,
<span id='android-media-MediaPlayer-property-VIDEO_SCALING_MODE_SCALE_TO_FIT_WITH_CROPPING'>/** Specifies a video scaling mode. The content is scaled, maintaining
</span> its aspect ratio. The whole surface area is always used. When the
 aspect ratio of the content is the same as the surface, no content
 is cropped; otherwise, content is cropped to fit the surface.
*/
VIDEO_SCALING_MODE_SCALE_TO_FIT_WITH_CROPPING : &quot;2&quot;,
<span id='android-media-MediaPlayer-property-PLAYBACK_RATE_AUDIO_MODE_RESAMPLE'>/** Change playback speed of audio by resampling the audio.
</span> &lt;p&gt;
 Specifies resampling as audio mode for variable rate playback, i.e.,
 resample the waveform based on the requested playback rate to get
 a new waveform, and play back the new waveform at the original sampling
 frequency.
 When rate is larger than 1.0, pitch becomes higher.
 When rate is smaller than 1.0, pitch becomes lower.

 @hide
*/
PLAYBACK_RATE_AUDIO_MODE_RESAMPLE : &quot;2&quot;,
<span id='android-media-MediaPlayer-property-PLAYBACK_RATE_AUDIO_MODE_STRETCH'>/** Change playback speed of audio without changing its pitch.
</span> &lt;p&gt;
 Specifies time stretching as audio mode for variable rate playback.
 Time stretching changes the duration of the audio samples without
 affecting its pitch.
 &lt;p&gt;
 This mode is only supported for a limited range of playback speed factors,
 e.g. between 1/2x and 2x.

 @hide
*/
PLAYBACK_RATE_AUDIO_MODE_STRETCH : &quot;1&quot;,
<span id='android-media-MediaPlayer-property-PLAYBACK_RATE_AUDIO_MODE_DEFAULT'>/** Change playback speed of audio without changing its pitch, and
</span> possibly mute audio if time stretching is not supported for the playback
 speed.
 &lt;p&gt;
 Try to keep audio pitch when changing the playback rate, but allow the
 system to determine how to change audio playback if the rate is out
 of range.

 @hide
*/
PLAYBACK_RATE_AUDIO_MODE_DEFAULT : &quot;0&quot;,
<span id='android-media-MediaPlayer-property-SEEK_PREVIOUS_SYNC'>/** This mode is used with {@link #seekTo(long, int)} to move media position to
</span> a sync (or key) frame associated with a data source that is located
 right before or at the given time.

 @see #seekTo(long, int)
*/
SEEK_PREVIOUS_SYNC : &quot;0&quot;,
<span id='android-media-MediaPlayer-property-SEEK_NEXT_SYNC'>/** This mode is used with {@link #seekTo(long, int)} to move media position to
</span> a sync (or key) frame associated with a data source that is located
 right after or at the given time.

 @see #seekTo(long, int)
*/
SEEK_NEXT_SYNC : &quot;1&quot;,
<span id='android-media-MediaPlayer-property-SEEK_CLOSEST_SYNC'>/** This mode is used with {@link #seekTo(long, int)} to move media position to
</span> a sync (or key) frame associated with a data source that is located
 closest to (in time) or at the given time.

 @see #seekTo(long, int)
*/
SEEK_CLOSEST_SYNC : &quot;2&quot;,
<span id='android-media-MediaPlayer-property-SEEK_CLOSEST'>/** This mode is used with {@link #seekTo(long, int)} to move media position to
</span> a frame (not necessarily a key frame) associated with a data source that
 is located closest to or at the given time.

 @see #seekTo(long, int)
*/
SEEK_CLOSEST : &quot;3&quot;,
<span id='android-media-MediaPlayer-property-MEDIA_MIMETYPE_TEXT_SUBRIP'>/** MIME type for SubRip (SRT) container. Used in addTimedTextSource APIs.
</span> @deprecated use {@link android.media.MediaFormat#MIMETYPE_TEXT_SUBRIP}
*/
MEDIA_MIMETYPE_TEXT_SUBRIP : &quot;application/x-subrip&quot;,
<span id='android-media-MediaPlayer-property-MEDIA_MIMETYPE_TEXT_VTT'>/** MIME type for WebVTT subtitle data.
</span> @hide
 @deprecated
*/
MEDIA_MIMETYPE_TEXT_VTT : &quot;text/vtt&quot;,
<span id='android-media-MediaPlayer-property-MEDIA_MIMETYPE_TEXT_CEA_608'>/** MIME type for CEA-608 closed caption data.
</span> @hide
 @deprecated
*/
MEDIA_MIMETYPE_TEXT_CEA_608 : &quot;text/cea-608&quot;,
<span id='android-media-MediaPlayer-property-MEDIA_MIMETYPE_TEXT_CEA_708'>/** MIME type for CEA-708 closed caption data.
</span> @hide
 @deprecated
*/
MEDIA_MIMETYPE_TEXT_CEA_708 : &quot;text/cea-708&quot;,
<span id='android-media-MediaPlayer-property-MEDIA_ERROR_UNKNOWN'>/**Unspecified media player error.
</span> @see android.media.MediaPlayer.OnErrorListener
*/
MEDIA_ERROR_UNKNOWN : &quot;1&quot;,
<span id='android-media-MediaPlayer-property-MEDIA_ERROR_SERVER_DIED'>/**Media server died. In this case, the application must release the
</span> MediaPlayer object and instantiate a new one.
 @see android.media.MediaPlayer.OnErrorListener
*/
MEDIA_ERROR_SERVER_DIED : &quot;100&quot;,
<span id='android-media-MediaPlayer-property-MEDIA_ERROR_NOT_VALID_FOR_PROGRESSIVE_PLAYBACK'>/**The video is streamed and its container is not valid for progressive
</span> playback i.e the video's index (e.g moov atom) is not at the start of the
 file.
 @see android.media.MediaPlayer.OnErrorListener
*/
MEDIA_ERROR_NOT_VALID_FOR_PROGRESSIVE_PLAYBACK : &quot;200&quot;,
<span id='android-media-MediaPlayer-property-MEDIA_ERROR_IO'>/**File or network related operation errors. */
</span>MEDIA_ERROR_IO : &quot;-1004&quot;,
<span id='android-media-MediaPlayer-property-MEDIA_ERROR_MALFORMED'>/**Bitstream is not conforming to the related coding standard or file spec. */
</span>MEDIA_ERROR_MALFORMED : &quot;-1007&quot;,
<span id='android-media-MediaPlayer-property-MEDIA_ERROR_UNSUPPORTED'>/**Bitstream is conforming to the related coding standard or file spec, but
</span> the media framework does not support the feature. */
MEDIA_ERROR_UNSUPPORTED : &quot;-1010&quot;,
<span id='android-media-MediaPlayer-property-MEDIA_ERROR_TIMED_OUT'>/**Some operation takes too long to complete, usually more than 3-5 seconds. */
</span>MEDIA_ERROR_TIMED_OUT : &quot;-110&quot;,
<span id='android-media-MediaPlayer-property-MEDIA_ERROR_SYSTEM'>/**Unspecified low-level system error. This value originated from UNKNOWN_ERROR in
</span> system/core/include/utils/Errors.h
 @see android.media.MediaPlayer.OnErrorListener
 @hide
*/
MEDIA_ERROR_SYSTEM : &quot;-2147483648&quot;,
<span id='android-media-MediaPlayer-property-MEDIA_INFO_UNKNOWN'>/**Unspecified media player info.
</span> @see android.media.MediaPlayer.OnInfoListener
*/
MEDIA_INFO_UNKNOWN : &quot;1&quot;,
<span id='android-media-MediaPlayer-property-MEDIA_INFO_STARTED_AS_NEXT'>/**The player was started because it was used as the next player for another
</span> player, which just completed playback.
 @see android.media.MediaPlayer#setNextMediaPlayer(MediaPlayer)
 @see android.media.MediaPlayer.OnInfoListener
*/
MEDIA_INFO_STARTED_AS_NEXT : &quot;2&quot;,
<span id='android-media-MediaPlayer-property-MEDIA_INFO_VIDEO_RENDERING_START'>/**The player just pushed the very first video frame for rendering.
</span> @see android.media.MediaPlayer.OnInfoListener
*/
MEDIA_INFO_VIDEO_RENDERING_START : &quot;3&quot;,
<span id='android-media-MediaPlayer-property-MEDIA_INFO_VIDEO_TRACK_LAGGING'>/**The video is too complex for the decoder: it can't decode frames fast
</span>  enough. Possibly only the audio plays fine at this stage.
 @see android.media.MediaPlayer.OnInfoListener
*/
MEDIA_INFO_VIDEO_TRACK_LAGGING : &quot;700&quot;,
<span id='android-media-MediaPlayer-property-MEDIA_INFO_BUFFERING_START'>/**MediaPlayer is temporarily pausing playback internally in order to
</span> buffer more data.
 @see android.media.MediaPlayer.OnInfoListener
*/
MEDIA_INFO_BUFFERING_START : &quot;701&quot;,
<span id='android-media-MediaPlayer-property-MEDIA_INFO_BUFFERING_END'>/**MediaPlayer is resuming playback after filling buffers.
</span> @see android.media.MediaPlayer.OnInfoListener
*/
MEDIA_INFO_BUFFERING_END : &quot;702&quot;,
<span id='android-media-MediaPlayer-property-MEDIA_INFO_NETWORK_BANDWIDTH'>/**Estimated network bandwidth information (kbps) is available; currently this event fires
</span> simultaneously as {@link #MEDIA_INFO_BUFFERING_START} and {@link #MEDIA_INFO_BUFFERING_END}
 when playing network files.
 @see android.media.MediaPlayer.OnInfoListener
 @hide
*/
MEDIA_INFO_NETWORK_BANDWIDTH : &quot;703&quot;,
<span id='android-media-MediaPlayer-property-MEDIA_INFO_BAD_INTERLEAVING'>/**Bad interleaving means that a media has been improperly interleaved or
</span> not interleaved at all, e.g has all the video samples first then all the
 audio ones. Video is playing but a lot of disk seeks may be happening.
 @see android.media.MediaPlayer.OnInfoListener
*/
MEDIA_INFO_BAD_INTERLEAVING : &quot;800&quot;,
<span id='android-media-MediaPlayer-property-MEDIA_INFO_NOT_SEEKABLE'>/**The media cannot be seeked (e.g live stream)
</span> @see android.media.MediaPlayer.OnInfoListener
*/
MEDIA_INFO_NOT_SEEKABLE : &quot;801&quot;,
<span id='android-media-MediaPlayer-property-MEDIA_INFO_METADATA_UPDATE'>/**A new set of metadata is available.
</span> @see android.media.MediaPlayer.OnInfoListener
*/
MEDIA_INFO_METADATA_UPDATE : &quot;802&quot;,
<span id='android-media-MediaPlayer-property-MEDIA_INFO_EXTERNAL_METADATA_UPDATE'>/**A new set of external-only metadata is available.  Used by
</span>  JAVA framework to avoid triggering track scanning.
 @hide
*/
MEDIA_INFO_EXTERNAL_METADATA_UPDATE : &quot;803&quot;,
<span id='android-media-MediaPlayer-property-MEDIA_INFO_AUDIO_NOT_PLAYING'>/**Informs that audio is not playing. Note that playback of the video
</span> is not interrupted.
 @see android.media.MediaPlayer.OnInfoListener
*/
MEDIA_INFO_AUDIO_NOT_PLAYING : &quot;804&quot;,
<span id='android-media-MediaPlayer-property-MEDIA_INFO_VIDEO_NOT_PLAYING'>/**Informs that video is not playing. Note that playback of the audio
</span> is not interrupted.
 @see android.media.MediaPlayer.OnInfoListener
*/
MEDIA_INFO_VIDEO_NOT_PLAYING : &quot;805&quot;,
<span id='android-media-MediaPlayer-property-MEDIA_INFO_TIMED_TEXT_ERROR'>/**Failed to handle timed text track properly.
</span> @see android.media.MediaPlayer.OnInfoListener

 {@hide}
*/
MEDIA_INFO_TIMED_TEXT_ERROR : &quot;900&quot;,
<span id='android-media-MediaPlayer-property-MEDIA_INFO_UNSUPPORTED_SUBTITLE'>/**Subtitle track was not supported by the media framework.
</span> @see android.media.MediaPlayer.OnInfoListener
*/
MEDIA_INFO_UNSUPPORTED_SUBTITLE : &quot;901&quot;,
<span id='android-media-MediaPlayer-property-MEDIA_INFO_SUBTITLE_TIMED_OUT'>/**Reading the subtitle track takes too long.
</span> @see android.media.MediaPlayer.OnInfoListener
*/
MEDIA_INFO_SUBTITLE_TIMED_OUT : &quot;902&quot;,
<span id='android-media-MediaPlayer-property-PREPARE_DRM_STATUS_SUCCESS'>/** The status codes for {@link android.media.MediaPlayer.OnDrmPreparedListener#onDrmPrepared} listener.
</span> &lt;p&gt;

 DRM preparation has succeeded.
*/
PREPARE_DRM_STATUS_SUCCESS : &quot;0&quot;,
<span id='android-media-MediaPlayer-property-PREPARE_DRM_STATUS_PROVISIONING_NETWORK_ERROR'>/** The device required DRM provisioning but couldn't reach the provisioning server.
</span>*/
PREPARE_DRM_STATUS_PROVISIONING_NETWORK_ERROR : &quot;1&quot;,
<span id='android-media-MediaPlayer-property-PREPARE_DRM_STATUS_PROVISIONING_SERVER_ERROR'>/** The device required DRM provisioning but the provisioning server denied the request.
</span>*/
PREPARE_DRM_STATUS_PROVISIONING_SERVER_ERROR : &quot;2&quot;,
<span id='android-media-MediaPlayer-property-PREPARE_DRM_STATUS_PREPARATION_ERROR'>/** The DRM preparation has failed .
</span>*/
PREPARE_DRM_STATUS_PREPARATION_ERROR : &quot;3&quot;,
<span id='android-media-MediaPlayer-method-newRequest'>/**Create a request parcel which can be routed to the native media
</span> player using {@link #invoke(Parcel, Parcel)}. The Parcel
 returned has the proper InterfaceToken set. The caller should
 not overwrite that token, i.e it can only append data to the
 Parcel.
@return {Object {android.os.Parcel}} A parcel suitable to hold a request for the native
 player.
 {@hide}
*/
newRequest : function(  ) {},

<span id='android-media-MediaPlayer-method-invoke'>/**Invoke a generic method on the native player using opaque
</span> parcels for the request and reply. Both payloads' format is a
 convention between the java caller and the native player.
 Must be called after setDataSource to make sure a native player
 exists. On failure, a RuntimeException is thrown.
@param {Object {Parcel}} request Parcel with the data for the extension. The
 caller must use {@link #newRequest()} to get one.
@param {Object {Parcel}} reply Output parcel with the data returned by the
 native player.
 {@hide}
*/
invoke : function(  ) {},

<span id='android-media-MediaPlayer-method-setDisplay'>/**Sets the {@link SurfaceHolder} to use for displaying the video
</span> portion of the media.

 Either a surface holder or surface must be set if a display or video sink
 is needed.  Not calling this method or {@link #setSurface}(Surface)
 when playing back a video will result in only the audio track being played.
 A null surface holder or surface will result in only the audio track being
 played.
@param {Object {SurfaceHolder}} sh the SurfaceHolder to use for video display
@throws IllegalStateException if the internal player engine has not been
 initialized or has been released.
*/
setDisplay : function(  ) {},

<span id='android-media-MediaPlayer-method-setSurface'>/**Sets the {@link Surface} to be used as the sink for the video portion of
</span> the media. This is similar to {@link #setDisplay}(SurfaceHolder), but
 does not support {@link #setScreenOnWhilePlaying}(boolean).  Setting a
 Surface will un-set any Surface or SurfaceHolder that was previously set.
 A null surface will result in only the audio track being played.

 If the Surface sends frames to a {@link SurfaceTexture}, the timestamps
 returned from {@link SurfaceTexture#getTimestamp()} will have an
 unspecified zero point.  These timestamps cannot be directly compared
 between different media sources, different instances of the same media
 source, or multiple runs of the same program.  The timestamp is normally
 monotonically increasing and is unaffected by time-of-day adjustments,
 but it is reset when the position is set.
@param {Object {Surface}} surface The {@link Surface} to be used for the video portion of
 the media.
@throws IllegalStateException if the internal player engine has not been
 initialized or has been released.
*/
setSurface : function(  ) {},

<span id='android-media-MediaPlayer-method-setVideoScalingMode'>/**Sets video scaling mode. To make the target video scaling mode
</span> effective during playback, this method must be called after
 data source is set. If not called, the default video
 scaling mode is {@link #VIDEO_SCALING_MODE_SCALE_TO_FIT}.

 &lt;p&gt; The supported video scaling modes are:
 &lt;ul&gt;
 &lt;li&gt; {@link #VIDEO_SCALING_MODE_SCALE_TO_FIT}
 &lt;li&gt; {@link #VIDEO_SCALING_MODE_SCALE_TO_FIT_WITH_CROPPING}
 &lt;/ul&gt;
@param {Number} mode target video scaling mode. Must be one of the supported
 video scaling modes; otherwise, IllegalArgumentException will be thrown.
@see MediaPlayer#VIDEO_SCALING_MODE_SCALE_TO_FIT
@see MediaPlayer#VIDEO_SCALING_MODE_SCALE_TO_FIT_WITH_CROPPING
*/
setVideoScalingMode : function(  ) {},

<span id='android-media-MediaPlayer-method-create'>/**Convenience method to create a MediaPlayer for a given Uri.
</span> On success, {@link #prepare}() will already have been called and must not be called again.
 &lt;p&gt;When done with the MediaPlayer, you should call  {@link #release}(),
 to free the resources. If not released, too many MediaPlayer instances will
 result in an exception.&lt;/p&gt;
 &lt;p&gt;Note that since {@link #prepare}() is called automatically in this method,
 you cannot change the audio
 session ID (see {@link #setAudioSessionId}(int)) or audio attributes
 (see {@link #setAudioAttributes}(AudioAttributes) of the new MediaPlayer.&lt;/p&gt;
@param {Object {Context}} context the Context to use
@param {Object {Uri}} uri the Uri from which to get the datasource
@return {Object {android.media.MediaPlayer}} a MediaPlayer object, or null if creation failed
*/
create : function(  ) {},

<span id='android-media-MediaPlayer-method-create'>/**Convenience method to create a MediaPlayer for a given Uri.
</span> On success, {@link #prepare}() will already have been called and must not be called again.
 &lt;p&gt;When done with the MediaPlayer, you should call  {@link #release}(),
 to free the resources. If not released, too many MediaPlayer instances will
 result in an exception.&lt;/p&gt;
 &lt;p&gt;Note that since {@link #prepare}() is called automatically in this method,
 you cannot change the audio
 session ID (see {@link #setAudioSessionId}(int)) or audio attributes
 (see {@link #setAudioAttributes}(AudioAttributes) of the new MediaPlayer.&lt;/p&gt;
@param {Object {Context}} context the Context to use
@param {Object {Uri}} uri the Uri from which to get the datasource
@param {Object {SurfaceHolder}} holder the SurfaceHolder to use for displaying the video
@return {Object {android.media.MediaPlayer}} a MediaPlayer object, or null if creation failed
*/
create : function(  ) {},

<span id='android-media-MediaPlayer-method-create'>/**Same factory method as {@link #create(Context, Uri, SurfaceHolder)} but that lets you specify
</span> the audio attributes and session ID to be used by the new MediaPlayer instance.
@param {Object {Context}} context the Context to use
@param {Object {Uri}} uri the Uri from which to get the datasource
@param {Object {SurfaceHolder}} holder the SurfaceHolder to use for displaying the video, may be null.
@param {Object {AudioAttributes}} audioAttributes the {@link AudioAttributes} to be used by the media player.
@param {Number} audioSessionId the audio session ID to be used by the media player,
     see {@link AudioManager#generateAudioSessionId()} to obtain a new session.
@return {Object {android.media.MediaPlayer}} a MediaPlayer object, or null if creation failed
*/
create : function(  ) {},

<span id='android-media-MediaPlayer-method-create'>/**Convenience method to create a MediaPlayer for a given resource id.
</span> On success, {@link #prepare}() will already have been called and must not be called again.
 &lt;p&gt;When done with the MediaPlayer, you should call  {@link #release}(),
 to free the resources. If not released, too many MediaPlayer instances will
 result in an exception.&lt;/p&gt;
 &lt;p&gt;Note that since {@link #prepare}() is called automatically in this method,
 you cannot change the audio
 session ID (see {@link #setAudioSessionId}(int)) or audio attributes
 (see {@link #setAudioAttributes}(AudioAttributes) of the new MediaPlayer.&lt;/p&gt;
@param {Object {Context}} context the Context to use
@param {Number} resid the raw resource id (&lt;var&gt;R.raw.&amp;lt;something&gt;&lt;/var&gt;) for
              the resource to use as the datasource
@return {Object {android.media.MediaPlayer}} a MediaPlayer object, or null if creation failed
*/
create : function(  ) {},

<span id='android-media-MediaPlayer-method-create'>/**Same factory method as {@link #create(Context, int)} but that lets you specify the audio
</span> attributes and session ID to be used by the new MediaPlayer instance.
@param {Object {Context}} context the Context to use
@param {Number} resid the raw resource id (&lt;var&gt;R.raw.&amp;lt;something&gt;&lt;/var&gt;) for
              the resource to use as the datasource
@param {Object {AudioAttributes}} audioAttributes the {@link AudioAttributes} to be used by the media player.
@param {Number} audioSessionId the audio session ID to be used by the media player,
     see {@link AudioManager#generateAudioSessionId()} to obtain a new session.
@return {Object {android.media.MediaPlayer}} a MediaPlayer object, or null if creation failed
*/
create : function(  ) {},

<span id='android-media-MediaPlayer-method-setDataSource'>/**Sets the data source as a content Uri.
</span>@param {Object {Context}} context the Context to use when resolving the Uri
@param {Object {Uri}} uri the Content URI of the data you want to play
@throws IllegalStateException if it is called in an invalid state
*/
setDataSource : function(  ) {},

<span id='android-media-MediaPlayer-method-setDataSource'>/**Sets the data source as a content Uri.
</span>
 To provide cookies for the subsequent HTTP requests, you can install your own default cookie
 handler and use other variants of setDataSource APIs instead. Alternatively, you can use
 this API to pass the cookies as a list of HttpCookie. If the app has not installed
 a CookieHandler already, this API creates a CookieManager and populates its CookieStore with
 the provided cookies. If the app has installed its own handler already, this API requires the
 handler to be of CookieManager type such that the API can update the managers CookieStore.

 &lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt; that the cross domain redirection is allowed by default,
 but that can be changed with key/value pairs through the headers parameter with
 &quot;android-allow-cross-domain-redirect&quot; as the key and &quot;0&quot; or &quot;1&quot; as the value to
 disallow or allow cross domain redirection.
@param {Object {Context}} context the Context to use when resolving the Uri
@param {Object {Uri}} uri the Content URI of the data you want to play
@param {Object {java.util.Map}} headers the headers to be sent together with the request for the data
                The headers must not include cookies. Instead, use the cookies param.
@param {Object {java.util.List}} cookies the cookies to be sent together with the request
@throws IllegalArgumentException if cookies are provided and the installed handler is not
                                  a CookieManager
@throws IllegalStateException    if it is called in an invalid state
@throws NullPointerException     if context or uri is null
@throws IOException              if uri has a file scheme and an I/O error occurs
*/
setDataSource : function(  ) {},

<span id='android-media-MediaPlayer-method-setDataSource'>/**Sets the data source as a content Uri.
</span>
 &lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt; that the cross domain redirection is allowed by default,
 but that can be changed with key/value pairs through the headers parameter with
 &quot;android-allow-cross-domain-redirect&quot; as the key and &quot;0&quot; or &quot;1&quot; as the value to
 disallow or allow cross domain redirection.
@param {Object {Context}} context the Context to use when resolving the Uri
@param {Object {Uri}} uri the Content URI of the data you want to play
@param {Object {java.util.Map}} headers the headers to be sent together with the request for the data
@throws IllegalStateException if it is called in an invalid state
*/
setDataSource : function(  ) {},

<span id='android-media-MediaPlayer-method-setDataSource'>/**Sets the data source (file-path or http/rtsp URL) to use.
</span>
 &lt;p&gt;When &lt;code&gt;path&lt;/code&gt; refers to a local file, the file may actually be opened by a
 process other than the calling application.  This implies that the pathname
 should be an absolute path (as any other process runs with unspecified current working
 directory), and that the pathname should reference a world-readable file.
 As an alternative, the application could first open the file for reading,
 and then use the file descriptor form {@link #setDataSource}(FileDescriptor).
@param {String} path the path of the file, or the http/rtsp URL of the stream you want to play
@throws IllegalStateException if it is called in an invalid state
*/
setDataSource : function(  ) {},

<span id='android-media-MediaPlayer-method-setDataSource'>/**Sets the data source (file-path or http/rtsp URL) to use.
</span>@param {String} path the path of the file, or the http/rtsp URL of the stream you want to play
@param {Object {java.util.Map}} headers the headers associated with the http request for the stream you want to play
@throws IllegalStateException if it is called in an invalid state
@hide pending API council
*/
setDataSource : function(  ) {},

<span id='android-media-MediaPlayer-method-setDataSource'>/**Sets the data source (AssetFileDescriptor) to use. It is the caller's
</span> responsibility to close the file descriptor. It is safe to do so as soon
 as this call returns.
@param {Object {AssetFileDescriptor}} afd the AssetFileDescriptor for the file you want to play
@throws IllegalStateException if it is called in an invalid state
@throws IllegalArgumentException if afd is not a valid AssetFileDescriptor
@throws IOException if afd can not be read
*/
setDataSource : function(  ) {},

<span id='android-media-MediaPlayer-method-setDataSource'>/**Sets the data source (FileDescriptor) to use. It is the caller's responsibility
</span> to close the file descriptor. It is safe to do so as soon as this call returns.
@param {Object {FileDescriptor}} fd the FileDescriptor for the file you want to play
@throws IllegalStateException if it is called in an invalid state
@throws IllegalArgumentException if fd is not a valid FileDescriptor
@throws IOException if fd can not be read
*/
setDataSource : function(  ) {},

<span id='android-media-MediaPlayer-method-setDataSource'>/**Sets the data source (FileDescriptor) to use.  The FileDescriptor must be
</span> seekable (N.B. a LocalSocket is not seekable). It is the caller's responsibility
 to close the file descriptor. It is safe to do so as soon as this call returns.
@param {Object {FileDescriptor}} fd the FileDescriptor for the file you want to play
@param {Number} offset the offset into the file where the data to be played starts, in bytes
@param {Number} length the length in bytes of the data to be played
@throws IllegalStateException if it is called in an invalid state
@throws IllegalArgumentException if fd is not a valid FileDescriptor
@throws IOException if fd can not be read
*/
setDataSource : function(  ) {},

<span id='android-media-MediaPlayer-method-setDataSource'>/**Sets the data source (MediaDataSource) to use.
</span>@param {Object {MediaDataSource}} dataSource the MediaDataSource for the media you want to play
@throws IllegalStateException if it is called in an invalid state
@throws IllegalArgumentException if dataSource is not a valid MediaDataSource
*/
setDataSource : function(  ) {},

<span id='android-media-MediaPlayer-method-prepare'>/**Prepares the player for playback, synchronously.
</span>
 After setting the datasource and the display surface, you need to either
 call prepare() or prepareAsync(). For files, it is OK to call prepare(),
 which blocks until MediaPlayer is ready for playback.
@throws IllegalStateException if it is called in an invalid state
*/
prepare : function(  ) {},

<span id='android-media-MediaPlayer-method-prepareAsync'>/**Prepares the player for playback, asynchronously.
</span>
 After setting the datasource and the display surface, you need to either
 call prepare() or prepareAsync(). For streams, you should call prepareAsync(),
 which returns immediately, rather than blocking until enough data has been
 buffered.
@throws IllegalStateException if it is called in an invalid state
*/
prepareAsync : function(  ) {},

<span id='android-media-MediaPlayer-method-start'>/**Starts or resumes playback. If playback had previously been paused,
</span> playback will continue from where it was paused. If playback had
 been stopped, or never started before, playback will start at the
 beginning.
@throws IllegalStateException if it is called in an invalid state
*/
start : function(  ) {},

<span id='android-media-MediaPlayer-method-stop'>/**Stops playback after playback has been started or paused.
</span>@throws IllegalStateException if the internal player engine has not been
 initialized.
*/
stop : function(  ) {},

<span id='android-media-MediaPlayer-method-pause'>/**Pauses playback. Call start() to resume.
</span>@throws IllegalStateException if the internal player engine has not been
 initialized.
*/
pause : function(  ) {},

<span id='android-media-MediaPlayer-method-createVolumeShaper'>/**
</span>*/
createVolumeShaper : function(  ) {},

<span id='android-media-MediaPlayer-method-setPreferredDevice'>/**Specifies an audio device (via an {@link android.media.AudioDeviceInfo} object) to route
</span> the output from this MediaPlayer.
@param {Object {AudioDeviceInfo}} deviceInfo The {@link AudioDeviceInfo} specifying the audio sink or source.
  If deviceInfo is null, default routing is restored.
@return {Boolean} true if succesful, false if the specified {@link AudioDeviceInfo} is non-null and
 does not correspond to a valid audio device.
*/
setPreferredDevice : function(  ) {},

<span id='android-media-MediaPlayer-method-getPreferredDevice'>/**Returns the selected output specified by {@link #setPreferredDevice}. Note that this
</span> is not guaranteed to correspond to the actual device being used for playback.
*/
getPreferredDevice : function(  ) {},

<span id='android-media-MediaPlayer-method-getRoutedDevice'>/**Returns an {@link android.media.AudioDeviceInfo} identifying the current routing of this MediaPlayer
</span> Note: The query is only valid if the MediaPlayer is currently playing.
 If the player is not playing, the returned device can be null or correspond to previously
 selected device when the player was last active.
*/
getRoutedDevice : function(  ) {},

<span id='android-media-MediaPlayer-method-addOnRoutingChangedListener'>/**Adds an {@link android.media.AudioRouting.OnRoutingChangedListener} to receive notifications of routing
</span> changes on this MediaPlayer.
@param {Object {AudioRouting.OnRoutingChangedListener}} listener The {@link AudioRouting.OnRoutingChangedListener} interface to receive
 notifications of rerouting events.
@param {Object {Handler}} handler  Specifies the {@link Handler} object for the thread on which to execute
 the callback. If &lt;code&gt;null&lt;/code&gt;, the handler on the main looper will be used.
*/
addOnRoutingChangedListener : function(  ) {},

<span id='android-media-MediaPlayer-method-removeOnRoutingChangedListener'>/**Removes an {@link android.media.AudioRouting.OnRoutingChangedListener} which has been previously added
</span> to receive rerouting notifications.
@param {Object {AudioRouting.OnRoutingChangedListener}} listener The previously added {@link AudioRouting.OnRoutingChangedListener} interface
 to remove.
*/
removeOnRoutingChangedListener : function(  ) {},

<span id='android-media-MediaPlayer-method-setWakeMode'>/**Set the low-level power management behavior for this MediaPlayer.  This
</span> can be used when the MediaPlayer is not playing through a SurfaceHolder
 set with {@link #setDisplay}(SurfaceHolder) and thus can use the
 high-level {@link #setScreenOnWhilePlaying}(boolean) feature.

 &lt;p&gt;This function has the MediaPlayer access the low-level power manager
 service to control the device's power usage while playing is occurring.
 The parameter is a combination of {@link android.os.PowerManager} wake flags.
 Use of this method requires {@link android.Manifest.permission#WAKE_LOCK}
 permission.
 By default, no attempt is made to keep the device awake during playback.
@param {Object {Context}} context the Context to use
@param {Number} mode    the power/wake mode to set
@see android.os.PowerManager
*/
setWakeMode : function(  ) {},

<span id='android-media-MediaPlayer-method-setScreenOnWhilePlaying'>/**Control whether we should use the attached SurfaceHolder to keep the
</span> screen on while video playback is occurring.  This is the preferred
 method over {@link #setWakeMode} where possible, since it doesn't
 require that the application have permission for low-level wake lock
 access.
@param {Boolean} screenOn Supply true to keep the screen on, false to allow it
 to turn off.
*/
setScreenOnWhilePlaying : function(  ) {},

<span id='android-media-MediaPlayer-method-getVideoWidth'>/**Returns the width of the video.
</span>@return {Number} the width of the video, or 0 if there is no video,
 no display surface was set, or the width has not been determined
 yet. The OnVideoSizeChangedListener can be registered via
 {@link #setOnVideoSizeChangedListener(OnVideoSizeChangedListener)}
 to provide a notification when the width is available.
*/
getVideoWidth : function(  ) {},

<span id='android-media-MediaPlayer-method-getVideoHeight'>/**Returns the height of the video.
</span>@return {Number} the height of the video, or 0 if there is no video,
 no display surface was set, or the height has not been determined
 yet. The OnVideoSizeChangedListener can be registered via
 {@link #setOnVideoSizeChangedListener(OnVideoSizeChangedListener)}
 to provide a notification when the height is available.
*/
getVideoHeight : function(  ) {},

<span id='android-media-MediaPlayer-method-getMetrics'>/**Return Metrics data about the current player.
</span>@return {Object {android.os.PersistableBundle}} a {@link PersistableBundle} containing the set of attributes and values
 available for the media being handled by this instance of MediaPlayer
 The attributes are descibed in {@link MetricsConstants}.

  Additional vendor-specific fields may also be present in
  the return value.
*/
getMetrics : function(  ) {},

<span id='android-media-MediaPlayer-method-isPlaying'>/**Checks whether the MediaPlayer is playing.
</span>@return {Boolean} true if currently playing, false otherwise
@throws IllegalStateException if the internal player engine has not been
 initialized or has been released.
*/
isPlaying : function(  ) {},

<span id='android-media-MediaPlayer-method-easyPlaybackParams'>/**Sets playback rate and audio mode.
</span>@param {Number} rate the ratio between desired playback rate and normal one.
@param {Number} audioMode audio playback mode. Must be one of the supported
 audio modes.
@throws IllegalStateException if the internal player engine has not been
 initialized.
@throws IllegalArgumentException if audioMode is not supported.
@hide 
*/
easyPlaybackParams : function(  ) {},

<span id='android-media-MediaPlayer-method-setPlaybackParams'>/**Sets playback rate using {@link android.media.PlaybackParams}. The object sets its internal
</span> PlaybackParams to the input, except that the object remembers previous speed
 when input speed is zero. This allows the object to resume at previous speed
 when start() is called. Calling it before the object is prepared does not change
 the object state. After the object is prepared, calling it with zero speed is
 equivalent to calling pause(). After the object is prepared, calling it with
 non-zero speed is equivalent to calling start().
@param {Object {PlaybackParams}} params the playback params.
@throws IllegalStateException if the internal player engine has not been
 initialized or has been released.
@throws IllegalArgumentException if params is not supported.
*/
setPlaybackParams : function(  ) {},

<span id='android-media-MediaPlayer-method-getPlaybackParams'>/**Gets the playback params, containing the current playback rate.
</span>@return {Object {android.media.PlaybackParams}} the playback params.
@throws IllegalStateException if the internal player engine has not been
 initialized.
*/
getPlaybackParams : function(  ) {},

<span id='android-media-MediaPlayer-method-setSyncParams'>/**Sets A/V sync mode.
</span>@param {Object {SyncParams}} params the A/V sync params to apply
@throws IllegalStateException if the internal player engine has not been
 initialized.
@throws IllegalArgumentException if params are not supported.
*/
setSyncParams : function(  ) {},

<span id='android-media-MediaPlayer-method-getSyncParams'>/**Gets the A/V sync mode.
</span>@return {Object {android.media.SyncParams}} the A/V sync params
@throws IllegalStateException if the internal player engine has not been
 initialized.
*/
getSyncParams : function(  ) {},

<span id='android-media-MediaPlayer-method-seekTo'>/**Moves the media to specified time position by considering the given mode.
</span> &lt;p&gt;
 When seekTo is finished, the user will be notified via OnSeekComplete supplied by the user.
 There is at most one active seekTo processed at any time. If there is a to-be-completed
 seekTo, new seekTo requests will be queued in such a way that only the last request
 is kept. When current seekTo is completed, the queued request will be processed if
 that request is different from just-finished seekTo operation, i.e., the requested
 position or mode is different.
@param {Number} msec the offset in milliseconds from the start to seek to.
 When seeking to the given time position, there is no guarantee that the data source
 has a frame located at the position. When this happens, a frame nearby will be rendered.
 If msec is negative, time position zero will be used.
 If msec is larger than duration, duration will be used.
@param {Number} mode the mode indicating where exactly to seek to.
 Use {@link #SEEK_PREVIOUS_SYNC} if one wants to seek to a sync frame
 that has a timestamp earlier than or the same as msec. Use
 {@link #SEEK_NEXT_SYNC} if one wants to seek to a sync frame
 that has a timestamp later than or the same as msec. Use
 {@link #SEEK_CLOSEST_SYNC} if one wants to seek to a sync frame
 that has a timestamp closest to or the same as msec. Use
 {@link #SEEK_CLOSEST} if one wants to seek to a frame that may
 or may not be a sync frame but is closest to or the same as msec.
 {@link #SEEK_CLOSEST} often has larger performance overhead compared
 to the other options if there is no sync frame located at msec.
@throws IllegalStateException if the internal player engine has not been
 initialized
@throws IllegalArgumentException if the mode is invalid.
*/
seekTo : function(  ) {},

<span id='android-media-MediaPlayer-method-seekTo'>/**Seeks to specified time position.
</span> Same as {@link #seekTo(long, int)} with {@code mode = SEEK_PREVIOUS_SYNC}.
@param {Number} msec the offset in milliseconds from the start to seek to
@throws IllegalStateException if the internal player engine has not been
 initialized
*/
seekTo : function(  ) {},

<span id='android-media-MediaPlayer-method-getTimestamp'>/**Get current playback position as a {@link android.media.MediaTimestamp}.
</span> &lt;p&gt;
 The MediaTimestamp represents how the media time correlates to the system time in
 a linear fashion using an anchor and a clock rate. During regular playback, the media
 time moves fairly constantly (though the anchor frame may be rebased to a current
 system time, the linear correlation stays steady). Therefore, this method does not
 need to be called often.
 &lt;p&gt;
 To help users get current playback position, this method always anchors the timestamp
 to the current {@link System#nanoTime system time}, so
 {@link android.media.MediaTimestamp#getAnchorMediaTimeUs} can be used as current playback position.
@return {Object {android.media.MediaTimestamp}} a MediaTimestamp object if a timestamp is available, or {@code null} if no timestamp
         is available, e.g. because the media player has not been initialized.
@see MediaTimestamp
*/
getTimestamp : function(  ) {},

<span id='android-media-MediaPlayer-method-getCurrentPosition'>/**Gets the current playback position.
</span>@return {Number} the current position in milliseconds
*/
getCurrentPosition : function(  ) {},

<span id='android-media-MediaPlayer-method-getDuration'>/**Gets the duration of the file.
</span>@return {Number} the duration in milliseconds, if no duration is available
         (for example, if streaming live content), -1 is returned.
*/
getDuration : function(  ) {},

<span id='android-media-MediaPlayer-method-getMetadata'>/**Gets the media metadata.
</span>@param {Boolean} update_only controls whether the full set of available
 metadata is returned or just the set that changed since the
 last call. See {@see #METADATA_UPDATE_ONLY} and {@see
 #METADATA_ALL}.
@param {Boolean} apply_filter if true only metadata that matches the
 filter is returned. See {@see #APPLY_METADATA_FILTER} and {@see
 #BYPASS_METADATA_FILTER}.
@return {Object {android.media.Metadata}} The metadata, possibly empty. null if an error occured.
     // FIXME: unhide.
 {@hide}
*/
getMetadata : function(  ) {},

<span id='android-media-MediaPlayer-method-setMetadataFilter'>/**Set a filter for the metadata update notification and update
</span> retrieval. The caller provides 2 set of metadata keys, allowed
 and blocked. The blocked set always takes precedence over the
 allowed one.
 Metadata.MATCH_ALL and Metadata.MATCH_NONE are 2 sets available as
 shorthands to allow/block all or no metadata.

 By default, there is no filter set.
@param {Object {java.util.Set}} allow Is the set of metadata the client is interested
              in receiving new notifications for.
@param {Object {java.util.Set}} block Is the set of metadata the client is not interested
              in receiving new notifications for.
@return {Number} The call status code.

     // FIXME: unhide.
 {@hide}
*/
setMetadataFilter : function(  ) {},

<span id='android-media-MediaPlayer-method-setNextMediaPlayer'>/**Set the MediaPlayer to start when this MediaPlayer finishes playback
</span> (i.e. reaches the end of the stream).
 The media framework will attempt to transition from this player to
 the next as seamlessly as possible. The next player can be set at
 any time before completion, but shall be after setDataSource has been
 called successfully. The next player must be prepared by the
 app, and the application should not call start() on it.
 The next MediaPlayer must be different from 'this'. An exception
 will be thrown if next == this.
 The application may call setNextMediaPlayer(null) to indicate no
 next player should be started at the end of playback.
 If the current player is looping, it will keep looping and the next
 player will not be started.
@param {Object {MediaPlayer}} next the player to start after this one completes playback.
*/
setNextMediaPlayer : function(  ) {},

<span id='android-media-MediaPlayer-method-release'>/**Releases resources associated with this MediaPlayer object.
</span> It is considered good practice to call this method when you're
 done using the MediaPlayer. In particular, whenever an Activity
 of an application is paused (its onPause() method is called),
 or stopped (its onStop() method is called), this method should be
 invoked to release the MediaPlayer object, unless the application
 has a special need to keep the object around. In addition to
 unnecessary resources (such as memory and instances of codecs)
 being held, failure to call this method immediately if a
 MediaPlayer object is no longer needed may also lead to
 continuous battery consumption for mobile devices, and playback
 failure for other applications if no multiple instances of the
 same codec are supported on a device. Even if multiple instances
 of the same codec are supported, some performance degradation
 may be expected when unnecessary multiple instances are used
 at the same time.
*/
release : function(  ) {},

<span id='android-media-MediaPlayer-method-reset'>/**Resets the MediaPlayer to its uninitialized state. After calling
</span> this method, you will have to initialize it again by setting the
 data source and calling prepare().
*/
reset : function(  ) {},

<span id='android-media-MediaPlayer-method-notifyAt'>/**Set up a timer for {@link #TimeProvider}. {@link #TimeProvider} will be
</span> notified when the presentation time reaches (becomes greater than or equal to)
 the value specified.
@param {Number} mediaTimeUs presentation time to get timed event callback at
@hide 
*/
notifyAt : function(  ) {},

<span id='android-media-MediaPlayer-method-setAudioStreamType'>/**Sets the audio stream type for this MediaPlayer. See {@link android.media.AudioManager}
</span> for a list of stream types. Must call this method before prepare() or
 prepareAsync() in order for the target stream type to become effective
 thereafter.
@param {Number} streamtype the audio stream type
@deprecated use {@link #setAudioAttributes(AudioAttributes)}
@see android.media.AudioManager
*/
setAudioStreamType : function(  ) {},

<span id='android-media-MediaPlayer-method-setAudioAttributes'>/**Sets the audio attributes for this MediaPlayer.
</span> See {@link android.media.AudioAttributes} for how to build and configure an instance of this class.
 You must call this method before {@link #prepare}() or {@link #prepareAsync}() in order
 for the audio attributes to become effective thereafter.
@param {Object {AudioAttributes}} attributes a non-null set of audio attributes
*/
setAudioAttributes : function(  ) {},

<span id='android-media-MediaPlayer-method-setLooping'>/**Sets the player to be looping or non-looping.
</span>@param {Boolean} looping whether to loop or not
*/
setLooping : function(  ) {},

<span id='android-media-MediaPlayer-method-isLooping'>/**Checks whether the MediaPlayer is looping or non-looping.
</span>@return {Boolean} true if the MediaPlayer is currently looping, false otherwise
*/
isLooping : function(  ) {},

<span id='android-media-MediaPlayer-method-setVolume'>/**Sets the volume on this player.
</span> This API is recommended for balancing the output of audio streams
 within an application. Unless you are writing an application to
 control user settings, this API should be used in preference to
 {@link android.media.AudioManager#setStreamVolume(int, int, int)} which sets the volume of ALL streams of
 a particular type. Note that the passed volume values are raw scalars in range 0.0 to 1.0.
 UI controls should be scaled logarithmically.
@param {Number} leftVolume left volume scalar
@param {Number} rightVolume right volume scalar
*/
setVolume : function(  ) {},

<span id='android-media-MediaPlayer-method-setVolume'>/**Similar, excepts sets volume of all channels to same value.
</span>@hide 
*/
setVolume : function(  ) {},

<span id='android-media-MediaPlayer-method-setAudioSessionId'>/**Sets the audio session ID.
</span>@param {Number} sessionId the audio session ID.
 The audio session ID is a system wide unique identifier for the audio stream played by
 this MediaPlayer instance.
 The primary use of the audio session ID  is to associate audio effects to a particular
 instance of MediaPlayer: if an audio session ID is provided when creating an audio effect,
 this effect will be applied only to the audio content of media players within the same
 audio session and not to the output mix.
 When created, a MediaPlayer instance automatically generates its own audio session ID.
 However, it is possible to force this player to be part of an already existing audio session
 by calling this method.
 This method must be called before one of the overloaded &lt;code&gt; setDataSource &lt;/code&gt; methods.
@throws IllegalStateException if it is called in an invalid state
*/
setAudioSessionId : function(  ) {},

<span id='android-media-MediaPlayer-method-getAudioSessionId'>/**Returns the audio session ID.
</span>@return {Number} the audio session ID. {@see #setAudioSessionId(int)}
 Note that the audio session ID is 0 only if a problem occured when the MediaPlayer was contructed.
*/
getAudioSessionId : function(  ) {},

<span id='android-media-MediaPlayer-method-attachAuxEffect'>/**Attaches an auxiliary effect to the player. A typical auxiliary effect is a reverberation
</span> effect which can be applied on any sound source that directs a certain amount of its
 energy to this effect. This amount is defined by setAuxEffectSendLevel().
 See {@link #setAuxEffectSendLevel}(float).
 &lt;p&gt;After creating an auxiliary effect (e.g.
 {@link android.media.audiofx.EnvironmentalReverb}), retrieve its ID with
 {@link android.media.audiofx.AudioEffect#getId()} and use it when calling this method
 to attach the player to the effect.
 &lt;p&gt;To detach the effect from the player, call this method with a null effect id.
 &lt;p&gt;This method must be called after one of the overloaded &lt;code&gt; setDataSource &lt;/code&gt;
 methods.
@param {Number} effectId system wide unique id of the effect to attach
*/
attachAuxEffect : function(  ) {},

<span id='android-media-MediaPlayer-method-setAuxEffectSendLevel'>/**Sets the send level of the player to the attached auxiliary effect.
</span> See {@link #attachAuxEffect}(int). The level value range is 0 to 1.0.
 &lt;p&gt;By default the send level is 0, so even if an effect is attached to the player
 this method must be called for the effect to be applied.
 &lt;p&gt;Note that the passed level value is a raw scalar. UI controls should be scaled
 logarithmically: the gain applied by audio framework ranges from -72dB to 0dB,
 so an appropriate conversion from linear UI input x to level is:
 x == 0 -&gt; level = 0
 0 &lt; x &lt;= R -&gt; level = 10^(72*(x-R)/20/R)
@param {Number} level send level scalar
*/
setAuxEffectSendLevel : function(  ) {},

<span id='android-media-MediaPlayer-method-getTrackInfo'>/**Returns an array of track information.
</span>@return {Object {android.media.MediaPlayer.TrackInfo}} Array of track info. The total number of tracks is the array length.
 Must be called again if an external timed text source has been added after any of the
 addTimedTextSource methods are called.
@throws IllegalStateException if it is called in an invalid state.
*/
getTrackInfo : function(  ) {},

<span id='android-media-MediaPlayer-method-setSubtitleAnchor'>/**
</span>@hide 
*/
setSubtitleAnchor : function(  ) {},

<span id='android-media-MediaPlayer-method-onSubtitleTrackSelected'>/**
</span>@hide 
*/
onSubtitleTrackSelected : function(  ) {},

<span id='android-media-MediaPlayer-method-addSubtitleSource'>/**
</span>@hide 
*/
addSubtitleSource : function(  ) {},

<span id='android-media-MediaPlayer-method-addTimedTextSource'>/**Adds an external timed text source file.
</span>
 Currently supported format is SubRip with the file extension .srt, case insensitive.
 Note that a single external timed text source may contain multiple tracks in it.
 One can find the total number of available tracks using {@link #getTrackInfo}() to see what
 additional tracks become available after this method call.
@param {String} path The file path of external timed text source file.
@param {String} mimeType The mime type of the file. Must be one of the mime types listed above.
@throws IOException if the file cannot be accessed or is corrupted.
@throws IllegalArgumentException if the mimeType is not supported.
@throws IllegalStateException if called in an invalid state.
*/
addTimedTextSource : function(  ) {},

<span id='android-media-MediaPlayer-method-addTimedTextSource'>/**Adds an external timed text source file (Uri).
</span>
 Currently supported format is SubRip with the file extension .srt, case insensitive.
 Note that a single external timed text source may contain multiple tracks in it.
 One can find the total number of available tracks using {@link #getTrackInfo}() to see what
 additional tracks become available after this method call.
@param {Object {Context}} context the Context to use when resolving the Uri
@param {Object {Uri}} uri the Content URI of the data you want to play
@param {String} mimeType The mime type of the file. Must be one of the mime types listed above.
@throws IOException if the file cannot be accessed or is corrupted.
@throws IllegalArgumentException if the mimeType is not supported.
@throws IllegalStateException if called in an invalid state.
*/
addTimedTextSource : function(  ) {},

<span id='android-media-MediaPlayer-method-addTimedTextSource'>/**Adds an external timed text source file (FileDescriptor).
</span>
 It is the caller's responsibility to close the file descriptor.
 It is safe to do so as soon as this call returns.

 Currently supported format is SubRip. Note that a single external timed text source may
 contain multiple tracks in it. One can find the total number of available tracks
 using {@link #getTrackInfo}() to see what additional tracks become available
 after this method call.
@param {Object {FileDescriptor}} fd the FileDescriptor for the file you want to play
@param {String} mimeType The mime type of the file. Must be one of the mime types listed above.
@throws IllegalArgumentException if the mimeType is not supported.
@throws IllegalStateException if called in an invalid state.
*/
addTimedTextSource : function(  ) {},

<span id='android-media-MediaPlayer-method-addTimedTextSource'>/**Adds an external timed text file (FileDescriptor).
</span>
 It is the caller's responsibility to close the file descriptor.
 It is safe to do so as soon as this call returns.

 Currently supported format is SubRip. Note that a single external timed text source may
 contain multiple tracks in it. One can find the total number of available tracks
 using {@link #getTrackInfo}() to see what additional tracks become available
 after this method call.
@param {Object {FileDescriptor}} fd the FileDescriptor for the file you want to play
@param {Number} offset the offset into the file where the data to be played starts, in bytes
@param {Number} length the length in bytes of the data to be played
@param {String} mime The mime type of the file. Must be one of the mime types listed above.
@throws IllegalArgumentException if the mimeType is not supported.
@throws IllegalStateException if called in an invalid state.
*/
addTimedTextSource : function(  ) {},

<span id='android-media-MediaPlayer-method-getSelectedTrack'>/**Returns the index of the audio, video, or subtitle track currently selected for playback,
</span> The return value is an index into the array returned by {@link #getTrackInfo}(), and can
 be used in calls to {@link #selectTrack}(int) or {@link #deselectTrack}(int).
@param {Number} trackType should be one of {@link TrackInfo#MEDIA_TRACK_TYPE_VIDEO},
 {@link TrackInfo#MEDIA_TRACK_TYPE_AUDIO}, or
 {@link TrackInfo#MEDIA_TRACK_TYPE_SUBTITLE}
@return {Number} index of the audio, video, or subtitle track currently selected for playback;
 a negative integer is returned when there is no selected track for {@code trackType} or
 when {@code trackType} is not one of audio, video, or subtitle.
@throws IllegalStateException if called after {@link #release()}
@see #getTrackInfo()
@see #selectTrack(int)
@see #deselectTrack(int)
*/
getSelectedTrack : function(  ) {},

<span id='android-media-MediaPlayer-method-selectTrack'>/**Selects a track.
</span> &lt;p&gt;
 If a MediaPlayer is in invalid state, it throws an IllegalStateException exception.
 If a MediaPlayer is in &lt;em&gt;Started&lt;/em&gt; state, the selected track is presented immediately.
 If a MediaPlayer is not in Started state, it just marks the track to be played.
 &lt;/p&gt;
 &lt;p&gt;
 In any valid state, if it is called multiple times on the same type of track (ie. Video,
 Audio, Timed Text), the most recent one will be chosen.
 &lt;/p&gt;
 &lt;p&gt;
 The first audio and video tracks are selected by default if available, even though
 this method is not called. However, no timed text track will be selected until
 this function is called.
 &lt;/p&gt;
 &lt;p&gt;
 Currently, only timed text, subtitle or audio tracks can be selected via this method.
 In addition, the support for selecting an audio track at runtime is pretty limited
 in that an audio track can only be selected in the &lt;em&gt;Prepared&lt;/em&gt; state.
 &lt;/p&gt;
@param {Number} index the index of the track to be selected. The valid range of the index
 is 0..total number of track - 1. The total number of tracks as well as the type of
 each individual track can be found by calling {@link #getTrackInfo()} method.
@throws IllegalStateException if called in an invalid state.
@see android.media.MediaPlayer#getTrackInfo
*/
selectTrack : function(  ) {},

<span id='android-media-MediaPlayer-method-deselectTrack'>/**Deselect a track.
</span> &lt;p&gt;
 Currently, the track must be a timed text track and no audio or video tracks can be
 deselected. If the timed text track identified by index has not been
 selected before, it throws an exception.
 &lt;/p&gt;
@param {Number} index the index of the track to be deselected. The valid range of the index
 is 0..total number of tracks - 1. The total number of tracks as well as the type of
 each individual track can be found by calling {@link #getTrackInfo()} method.
@throws IllegalStateException if called in an invalid state.
@see android.media.MediaPlayer#getTrackInfo
*/
deselectTrack : function(  ) {},

<span id='android-media-MediaPlayer-method-native_pullBatteryData'>/**
</span>@param {Object {Parcel}} reply Parcel with audio/video duration info for battery
                    tracking usage
@return {Number} The status code.
 {@hide}
*/
native_pullBatteryData : function(  ) {},

<span id='android-media-MediaPlayer-method-setRetransmitEndpoint'>/**Sets the target UDP re-transmit endpoint for the low level player.
</span> Generally, the address portion of the endpoint is an IP multicast
 address, although a unicast address would be equally valid.  When a valid
 retransmit endpoint has been set, the media player will not decode and
 render the media presentation locally.  Instead, the player will attempt
 to re-multiplex its media data using the Android@Home RTP profile and
 re-transmit to the target endpoint.  Receiver devices (which may be
 either the same as the transmitting device or different devices) may
 instantiate, prepare, and start a receiver player using a setDataSource
 URL of the form...

 aahRX://&amp;lt;multicastIP&amp;gt;:&amp;lt;port&amp;gt;

 to receive, decode and render the re-transmitted content.

 setRetransmitEndpoint may only be called before setDataSource has been
 called; while the player is in the Idle state.
@param {Object {InetSocketAddress}} endpoint the address and UDP port of the re-transmission target or
 null if no re-transmission is to be performed.
@throws IllegalStateException if it is called in an invalid state
@throws IllegalArgumentException if the retransmit endpoint is supplied,
 but invalid.

 {@hide} pending API council
*/
setRetransmitEndpoint : function(  ) {},

<span id='android-media-MediaPlayer-method-getMediaTimeProvider'>/**
</span>@hide 
*/
getMediaTimeProvider : function(  ) {},

<span id='android-media-MediaPlayer-method-setOnPreparedListener'>/**Register a callback to be invoked when the media source is ready
</span> for playback.
@param {Object {MediaPlayer.OnPreparedListener}} listener the callback that will be run
*/
setOnPreparedListener : function(  ) {},

<span id='android-media-MediaPlayer-method-setOnCompletionListener'>/**Register a callback to be invoked when the end of a media source
</span> has been reached during playback.
@param {Object {MediaPlayer.OnCompletionListener}} listener the callback that will be run
*/
setOnCompletionListener : function(  ) {},

<span id='android-media-MediaPlayer-method-setOnBufferingUpdateListener'>/**Register a callback to be invoked when the status of a network
</span> stream's buffer has changed.
@param {Object {MediaPlayer.OnBufferingUpdateListener}} listener the callback that will be run.
*/
setOnBufferingUpdateListener : function(  ) {},

<span id='android-media-MediaPlayer-method-setOnSeekCompleteListener'>/**Register a callback to be invoked when a seek operation has been
</span> completed.
@param {Object {MediaPlayer.OnSeekCompleteListener}} listener the callback that will be run
*/
setOnSeekCompleteListener : function(  ) {},

<span id='android-media-MediaPlayer-method-setOnVideoSizeChangedListener'>/**Register a callback to be invoked when the video size is
</span> known or updated.
@param {Object {MediaPlayer.OnVideoSizeChangedListener}} listener the callback that will be run
*/
setOnVideoSizeChangedListener : function(  ) {},

<span id='android-media-MediaPlayer-method-setOnTimedTextListener'>/**Register a callback to be invoked when a timed text is available
</span> for display.
@param {Object {MediaPlayer.OnTimedTextListener}} listener the callback that will be run
*/
setOnTimedTextListener : function(  ) {},

<span id='android-media-MediaPlayer-method-setOnSubtitleDataListener'>/**Sets the listener to be invoked when a subtitle track has new data available.
</span> The subtitle data comes from a subtitle track previously selected with
 {@link #selectTrack}(int). Use {@link #getTrackInfo}() to determine which tracks are
 subtitles (of type {@link android.media.MediaPlayer.TrackInfo#MEDIA_TRACK_TYPE_SUBTITLE}), Subtitle track encodings
 can be determined by {@link android.media.MediaPlayer.TrackInfo#getFormat()}).&lt;br&gt;
 See {@link android.media.MediaPlayer2.SubtitleData} for an example of querying subtitle encoding.
@param {Object {MediaPlayer.OnSubtitleDataListener}} listener the listener called when new data is available
@param {Object {Handler}} handler the {@link Handler} that receives the listener events
*/
setOnSubtitleDataListener : function(  ) {},

<span id='android-media-MediaPlayer-method-setOnSubtitleDataListener'>/**Sets the listener to be invoked when a subtitle track has new data available.
</span> The subtitle data comes from a subtitle track previously selected with
 {@link #selectTrack}(int). Use {@link #getTrackInfo}() to determine which tracks are
 subtitles (of type {@link android.media.MediaPlayer.TrackInfo#MEDIA_TRACK_TYPE_SUBTITLE}), Subtitle track encodings
 can be determined by {@link android.media.MediaPlayer.TrackInfo#getFormat()}).&lt;br&gt;
 See {@link android.media.MediaPlayer2.SubtitleData} for an example of querying subtitle encoding.&lt;br&gt;
 The listener will be called on the same thread as the one in which the MediaPlayer was
 created.
@param {Object {MediaPlayer.OnSubtitleDataListener}} listener the listener called when new data is available
*/
setOnSubtitleDataListener : function(  ) {},

<span id='android-media-MediaPlayer-method-clearOnSubtitleDataListener'>/**Clears the listener previously set with
</span> {@link #setOnSubtitleDataListener}(OnSubtitleDataListener) or
 {@link #setOnSubtitleDataListener(OnSubtitleDataListener, Handler)}.
*/
clearOnSubtitleDataListener : function(  ) {},

<span id='android-media-MediaPlayer-method-setOnMediaTimeDiscontinuityListener'>/**Sets the listener to be invoked when a media time discontinuity is encountered.
</span>@param {Object {MediaPlayer.OnMediaTimeDiscontinuityListener}} listener the listener called after a discontinuity
@param {Object {Handler}} handler the {@link Handler} that receives the listener events
*/
setOnMediaTimeDiscontinuityListener : function(  ) {},

<span id='android-media-MediaPlayer-method-setOnMediaTimeDiscontinuityListener'>/**Sets the listener to be invoked when a media time discontinuity is encountered.
</span> The listener will be called on the same thread as the one in which the MediaPlayer was
 created.
@param {Object {MediaPlayer.OnMediaTimeDiscontinuityListener}} listener the listener called after a discontinuity
*/
setOnMediaTimeDiscontinuityListener : function(  ) {},

<span id='android-media-MediaPlayer-method-clearOnMediaTimeDiscontinuityListener'>/**Clears the listener previously set with
</span> {@link #setOnMediaTimeDiscontinuityListener}(OnMediaTimeDiscontinuityListener)
 or {@link #setOnMediaTimeDiscontinuityListener(OnMediaTimeDiscontinuityListener, Handler)}
*/
clearOnMediaTimeDiscontinuityListener : function(  ) {},

<span id='android-media-MediaPlayer-method-setOnTimedMetaDataAvailableListener'>/**Register a callback to be invoked when a selected track has timed metadata available.
</span> &lt;p&gt;
 Currently only HTTP live streaming data URI's embedded with timed ID3 tags generates
 {@link android.media.TimedMetaData}.
@param {Object {MediaPlayer.OnTimedMetaDataAvailableListener}} listener the callback that will be run
@see MediaPlayer.OnTimedMetaDataAvailableListener
@see TimedMetaData
@param listener the callback that will be run
*/
setOnTimedMetaDataAvailableListener : function(  ) {},

<span id='android-media-MediaPlayer-method-setOnErrorListener'>/**Register a callback to be invoked when an error has happened
</span> during an asynchronous operation.
@param {Object {MediaPlayer.OnErrorListener}} listener the callback that will be run
*/
setOnErrorListener : function(  ) {},

<span id='android-media-MediaPlayer-method-setOnInfoListener'>/**Register a callback to be invoked when an info/warning is available.
</span>@param {Object {MediaPlayer.OnInfoListener}} listener the callback that will be run
*/
setOnInfoListener : function(  ) {},

<span id='android-media-MediaPlayer-method-setOnDrmConfigHelper'>/**Register a callback to be invoked for configuration of the DRM object before
</span> the session is created.
 The callback will be invoked synchronously during the execution
 of {@link #prepareDrm}(UUID uuid).
@param {Object {MediaPlayer.OnDrmConfigHelper}} listener the callback that will be run
*/
setOnDrmConfigHelper : function(  ) {},

<span id='android-media-MediaPlayer-method-setOnDrmInfoListener'>/**Register a callback to be invoked when the DRM info is
</span> known.
@param {Object {MediaPlayer.OnDrmInfoListener}} listener the callback that will be run
*/
setOnDrmInfoListener : function(  ) {},

<span id='android-media-MediaPlayer-method-setOnDrmInfoListener'>/**Register a callback to be invoked when the DRM info is
</span> known.
@param {Object {MediaPlayer.OnDrmInfoListener}} listener the callback that will be run
*/
setOnDrmInfoListener : function(  ) {},

<span id='android-media-MediaPlayer-method-setOnDrmPreparedListener'>/**Register a callback to be invoked when the DRM object is prepared.
</span>@param {Object {MediaPlayer.OnDrmPreparedListener}} listener the callback that will be run
*/
setOnDrmPreparedListener : function(  ) {},

<span id='android-media-MediaPlayer-method-setOnDrmPreparedListener'>/**Register a callback to be invoked when the DRM object is prepared.
</span>@param {Object {MediaPlayer.OnDrmPreparedListener}} listener the callback that will be run
@param {Object {Handler}} handler the Handler that will receive the callback
*/
setOnDrmPreparedListener : function(  ) {},

<span id='android-media-MediaPlayer-method-getDrmInfo'>/**Retrieves the DRM Info associated with the current source
</span>@throws IllegalStateException if called before prepare()
*/
getDrmInfo : function(  ) {},

<span id='android-media-MediaPlayer-method-prepareDrm'>/**Prepares the DRM for the current source
</span> &lt;p&gt;
 If {@code OnDrmConfigHelper} is registered, it will be called during
 preparation to allow configuration of the DRM properties before opening the
 DRM session. Note that the callback is called synchronously in the thread that called
 {@code prepareDrm}. It should be used only for a series of {@code getDrmPropertyString}
 and {@code setDrmPropertyString} calls and refrain from any lengthy operation.
 &lt;p&gt;
 If the device has not been provisioned before, this call also provisions the device
 which involves accessing the provisioning server and can take a variable time to
 complete depending on the network connectivity.
 If {@code OnDrmPreparedListener} is registered, prepareDrm() runs in non-blocking
 mode by launching the provisioning in the background and returning. The listener
 will be called when provisioning and preparation has finished. If a
 {@code OnDrmPreparedListener} is not registered, prepareDrm() waits till provisioning
 and preparation has finished, i.e., runs in blocking mode.
 &lt;p&gt;
 If {@code OnDrmPreparedListener} is registered, it is called to indicate the DRM
 session being ready. The application should not make any assumption about its call
 sequence (e.g., before or after prepareDrm returns), or the thread context that will
 execute the listener (unless the listener is registered with a handler thread).
 &lt;p&gt;
@param {Object {UUID}} uuid The UUID of the crypto scheme. If not known beforehand, it can be retrieved
 from the source through {@code getDrmInfo} or registering a {@code onDrmInfoListener}.
@throws IllegalStateException              if called before prepare(), or the DRM was
                                            prepared already
@throws UnsupportedSchemeException         if the crypto scheme is not supported
@throws ResourceBusyException              if required DRM resources are in use
@throws ProvisioningNetworkErrorException  if provisioning is required but failed due to a
                                            network error
@throws ProvisioningServerErrorException   if provisioning is required but failed due to
                                            the request denied by the provisioning server
*/
prepareDrm : function(  ) {},

<span id='android-media-MediaPlayer-method-releaseDrm'>/**Releases the DRM session
</span> &lt;p&gt;
 The player has to have an active DRM session and be in stopped, or prepared
 state before this call is made.
 A {@code reset()} call will release the DRM session implicitly.
@throws NoDrmSchemeException if there is no active DRM session to release
*/
releaseDrm : function(  ) {},

<span id='android-media-MediaPlayer-method-getKeyRequest'>/**A key request/response exchange occurs between the app and a license server
</span> to obtain or release keys used to decrypt encrypted content.
 &lt;p&gt;
 getKeyRequest() is used to obtain an opaque key request byte array that is
 delivered to the license server.  The opaque key request byte array is returned
 in KeyRequest.data.  The recommended URL to deliver the key request to is
 returned in KeyRequest.defaultUrl.
 &lt;p&gt;
 After the app has received the key request response from the server,
 it should deliver to the response to the DRM engine plugin using the method
 {@link #provideKeyResponse}.
@param {Object {byte[]}} keySetId is the key-set identifier of the offline keys being released when keyType is
 {@link MediaDrm#KEY_TYPE_RELEASE}. It should be set to null for other key requests, when
 keyType is {@link MediaDrm#KEY_TYPE_STREAMING} or {@link MediaDrm#KEY_TYPE_OFFLINE}.
@param {Object {byte[]}} initData is the container-specific initialization data when the keyType is
 {@link MediaDrm#KEY_TYPE_STREAMING} or {@link MediaDrm#KEY_TYPE_OFFLINE}. Its meaning is
 interpreted based on the mime type provided in the mimeType parameter.  It could
 contain, for example, the content ID, key ID or other data obtained from the content
 metadata that is required in generating the key request.
 When the keyType is {@link MediaDrm#KEY_TYPE_RELEASE}, it should be set to null.
@param {String} mimeType identifies the mime type of the content
@param {Number} keyType specifies the type of the request. The request may be to acquire
 keys for streaming, {@link MediaDrm#KEY_TYPE_STREAMING}, or for offline content
 {@link MediaDrm#KEY_TYPE_OFFLINE}, or to release previously acquired
 keys ({@link MediaDrm#KEY_TYPE_RELEASE}), which are identified by a keySetId.
@param {Object {java.util.Map}} optionalParameters are included in the key request message to
 allow a client application to provide additional message parameters to the server.
 This may be {@code null} if no additional parameters are to be sent.
@throws NoDrmSchemeException if there is no active DRM session
*/
getKeyRequest : function(  ) {},

<span id='android-media-MediaPlayer-method-provideKeyResponse'>/**A key response is received from the license server by the app, then it is
</span> provided to the DRM engine plugin using provideKeyResponse. When the
 response is for an offline key request, a key-set identifier is returned that
 can be used to later restore the keys to a new session with the method
 {@ link # restoreKeys}.
 When the response is for a streaming or release request, null is returned.
@param {Object {byte[]}} keySetId When the response is for a release request, keySetId identifies
 the saved key associated with the release request (i.e., the same keySetId
 passed to the earlier {@ link # getKeyRequest} call. It MUST be null when the
 response is for either streaming or offline key requests.
@param {Object {byte[]}} response the byte array response from the server
@throws NoDrmSchemeException if there is no active DRM session
@throws DeniedByServerException if the response indicates that the
 server rejected the request
*/
provideKeyResponse : function(  ) {},

<span id='android-media-MediaPlayer-method-restoreKeys'>/**Restore persisted offline keys into a new session.  keySetId identifies the
</span> keys to load, obtained from a prior call to {@link #provideKeyResponse}.
@param {Object {byte[]}} keySetId identifies the saved key set to restore
*/
restoreKeys : function(  ) {},

<span id='android-media-MediaPlayer-method-getDrmPropertyString'>/**Read a DRM engine plugin String property value, given the property name string.
</span> &lt;p&gt;
@param {String} propertyName the property name

 Standard fields names are:
 {@link MediaDrm#PROPERTY_VENDOR}, {@link MediaDrm#PROPERTY_VERSION},
 {@link MediaDrm#PROPERTY_DESCRIPTION}, {@link MediaDrm#PROPERTY_ALGORITHMS}
*/
getDrmPropertyString : function(  ) {},

<span id='android-media-MediaPlayer-method-setDrmPropertyString'>/**Set a DRM engine plugin String property value.
</span> &lt;p&gt;
@param {String} propertyName the property name
@param {String} value the property value

 Standard fields names are:
 {@link MediaDrm#PROPERTY_VENDOR}, {@link MediaDrm#PROPERTY_VERSION},
 {@link MediaDrm#PROPERTY_DESCRIPTION}, {@link MediaDrm#PROPERTY_ALGORITHMS}
*/
setDrmPropertyString : function(  ) {},


};</pre>
</body>
</html>
