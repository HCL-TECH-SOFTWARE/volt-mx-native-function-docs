<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='javax-security-auth-x500-X500Principal'>/**@class javax.security.auth.x500.X500Principal
</span> implements java.security.Principal

 implements java.io.Serializable

@extends java.lang.Object

 &lt;p&gt; This class represents an X.500 {@code Principal}.
 {@code X500Principal}s are represented by distinguished names such as
 &quot;CN=Duke, OU=JavaSoft, O=Sun Microsystems, C=US&quot;.

 &lt;p&gt; This class can be instantiated by using a string representation
 of the distinguished name, or by using the ASN.1 DER encoded byte
 representation of the distinguished name.  The current specification
 for the string representation of a distinguished name is defined in
 &lt;a href=&quot;http://www.ietf.org/rfc/rfc2253.txt&quot;&gt;RFC 2253: Lightweight
 Directory Access Protocol (v3): UTF-8 String Representation of
 Distinguished Names&lt;/a&gt;. This class, however, accepts string formats from
 both RFC 2253 and &lt;a href=&quot;http://www.ietf.org/rfc/rfc1779.txt&quot;&gt;RFC 1779:
 A String Representation of Distinguished Names&lt;/a&gt;, and also recognizes
 attribute type keywords whose OIDs (Object Identifiers) are defined in
 &lt;a href=&quot;http://www.ietf.org/rfc/rfc3280.txt&quot;&gt;RFC 3280: Internet X.509
 Public Key Infrastructure Certificate and CRL Profile&lt;/a&gt;.

 &lt;p&gt; The string representation for this {@code X500Principal}
 can be obtained by calling the {@code getName} methods.

 &lt;p&gt; Note that the {@code getSubjectX500Principal} and
 {@code getIssuerX500Principal} methods of
 {@code X509Certificate} return X500Principals representing the
 issuer and subject fields of the certificate.

 @see java.security.cert.X509Certificate
 @since 1.4
*/
var X500Principal = {

<span id='javax-security-auth-x500-X500Principal-property-RFC1779'>/** RFC 1779 String format of Distinguished Names.
</span>*/
RFC1779 : &quot;RFC1779&quot;,
<span id='javax-security-auth-x500-X500Principal-property-RFC2253'>/** RFC 2253 String format of Distinguished Names.
</span>*/
RFC2253 : &quot;RFC2253&quot;,
<span id='javax-security-auth-x500-X500Principal-property-CANONICAL'>/** Canonical String format of Distinguished Names.
</span>*/
CANONICAL : &quot;CANONICAL&quot;,
<span id='javax-security-auth-x500-X500Principal-method-getName'>/**Returns a string representation of the X.500 distinguished name using
</span> the format defined in RFC 2253.

 &lt;p&gt;This method is equivalent to calling
 {@code getName(X500Principal.RFC2253)}.
@return {String} the distinguished name of this {@code X500Principal}
*/
getName : function(  ) {},

<span id='javax-security-auth-x500-X500Principal-method-getName'>/**Returns a string representation of the X.500 distinguished name
</span> using the specified format. Valid values for the format are
 &quot;RFC1779&quot;, &quot;RFC2253&quot;, and &quot;CANONICAL&quot; (case insensitive).

 &lt;p&gt; If &quot;RFC1779&quot; is specified as the format,
 this method emits the attribute type keywords defined in
 RFC 1779 (CN, L, ST, O, OU, C, STREET).
 Any other attribute type is emitted as an OID.

 &lt;p&gt; If &quot;RFC2253&quot; is specified as the format,
 this method emits the attribute type keywords defined in
 RFC 2253 (CN, L, ST, O, OU, C, STREET, DC, UID).
 Any other attribute type is emitted as an OID.
 Under a strict reading, RFC 2253 only specifies a UTF-8 string
 representation. The String returned by this method is the
 Unicode string achieved by decoding this UTF-8 representation.

 &lt;p&gt; If &quot;CANONICAL&quot; is specified as the format,
 this method returns an RFC 2253 conformant string representation
 with the following additional canonicalizations:

 &lt;ol&gt;
 &lt;li&gt; Leading zeros are removed from attribute types
          that are encoded as dotted decimal OIDs
 &lt;li&gt; DirectoryString attribute values of type
          PrintableString and UTF8String are not
          output in hexadecimal format
 &lt;li&gt; DirectoryString attribute values of types
          other than PrintableString and UTF8String
          are output in hexadecimal format
 &lt;li&gt; Leading and trailing white space characters
          are removed from non-hexadecimal attribute values
          (unless the value consists entirely of white space characters)
 &lt;li&gt; Internal substrings of one or more white space characters are
          converted to a single space in non-hexadecimal
          attribute values
 &lt;li&gt; Relative Distinguished Names containing more than one
          Attribute Value Assertion (AVA) are output in the
          following order: an alphabetical ordering of AVAs
          containing standard keywords, followed by a numeric
          ordering of AVAs containing OID keywords.
 &lt;li&gt; The only characters in attribute values that are escaped are
          those which section 2.4 of RFC 2253 states must be escaped
          (they are escaped using a preceding backslash character)
 &lt;li&gt; The entire name is converted to upper case
          using {@code String.toUpperCase(Locale.US)}
 &lt;li&gt; The entire name is converted to lower case
          using {@code String.toLowerCase(Locale.US)}
 &lt;li&gt; The name is finally normalized using normalization form KD,
          as described in the Unicode Standard and UAX #15
 &lt;/ol&gt;

 &lt;p&gt; Additional standard formats may be introduced in the future.
@param {String} format the format to use
@return {String} a string representation of this {@code X500Principal}
          using the specified format
@throws IllegalArgumentException if the specified format is invalid
          or null
*/
getName : function(  ) {},

<span id='javax-security-auth-x500-X500Principal-method-getName'>/**Returns a string representation of the X.500 distinguished name
</span> using the specified format. Valid values for the format are
 &quot;RFC1779&quot; and &quot;RFC2253&quot; (case insensitive). &quot;CANONICAL&quot; is not
 permitted and an {@code IllegalArgumentException} will be thrown.

 &lt;p&gt;This method returns Strings in the format as specified in
 {@link #getName}(String) and also emits additional attribute type
 keywords for OIDs that have entries in the {@code oidMap}
 parameter. OID entries in the oidMap take precedence over the default
 OIDs recognized by {@code getName(String)}.
 Improperly specified OIDs are ignored; however if an OID
 in the name maps to an improperly specified keyword, an
 {@code IllegalArgumentException} is thrown.

 &lt;p&gt; Additional standard formats may be introduced in the future.

 &lt;p&gt; Warning: additional attribute type keywords may not be recognized
 by other implementations; therefore do not use this method if
 you are unsure if these keywords will be recognized by other
 implementations.
@param {String} format the format to use
@param {Object {java.util.Map}} oidMap an OID map, where each key is an object identifier in
  String form (a sequence of nonnegative integers separated by periods)
  that maps to a corresponding attribute type keyword String.
  The map may be empty but never {@code null}.
@return {String} a string representation of this {@code X500Principal}
          using the specified format
@throws IllegalArgumentException if the specified format is invalid,
  null, or an OID in the name maps to an improperly specified keyword
@throws NullPointerException if {@code oidMap} is {@code null}
@since 1.6
*/
getName : function(  ) {},

<span id='javax-security-auth-x500-X500Principal-method-getEncoded'>/**Returns the distinguished name in ASN.1 DER encoded form. The ASN.1
</span> notation for this structure is supplied in the documentation for
 {@link #javax.security.auth.x500.X500Principal(byte[] name) javax.security.auth.x500.X500Principal(byte[] name)}.

 &lt;p&gt;Note that the byte array returned is cloned to protect against
 subsequent modifications.
@return {Number} a byte array containing the distinguished name in ASN.1 DER
 encoded form
*/
getEncoded : function(  ) {},

<span id='javax-security-auth-x500-X500Principal-method-toString'>/**Return a user-friendly string representation of this
</span> {@code X500Principal}.
@return {String} a string representation of this {@code X500Principal}
*/
toString : function(  ) {},

<span id='javax-security-auth-x500-X500Principal-method-equals'>/**Compares the specified {@code Object} with this
</span> {@code X500Principal} for equality.

 &lt;p&gt; Specifically, this method returns {@code true} if
 the {@code Object} &lt;i&gt;o&lt;/i&gt; is an {@code X500Principal}
 and if the respective canonical string representations
 (obtained via the {@code getName(X500Principal.CANONICAL)} method)
 of this object and &lt;i&gt;o&lt;/i&gt; are equal.

 &lt;p&gt; This implementation is compliant with the requirements of RFC 3280.
@param {Object {Object}} o Object to be compared for equality with this
          {@code X500Principal}
@return {Boolean} {@code true} if the specified {@code Object} is equal
          to this {@code X500Principal}, {@code false} otherwise
*/
equals : function(  ) {},

<span id='javax-security-auth-x500-X500Principal-method-hashCode'>/**Return a hash code for this {@code X500Principal}.
</span>
 &lt;p&gt; The hash code is calculated via:
 {@code getName(X500Principal.CANONICAL).hashCode()}
@return {Number} a hash code for this {@code X500Principal}
*/
hashCode : function(  ) {},


};</pre>
</body>
</html>
