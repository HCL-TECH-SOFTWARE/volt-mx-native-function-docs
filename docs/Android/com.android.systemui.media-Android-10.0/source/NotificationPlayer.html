<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='com-android-systemui-media-NotificationPlayer'>/**@class com.android.systemui.media.NotificationPlayer
</span> implements android.media.MediaPlayer.OnCompletionListener

 implements android.media.MediaPlayer.OnErrorListener

@extends java.lang.Object

 @hide
 This class is provides the same interface and functionality as android.media.AsyncPlayer
 with the following differences:
 - whenever audio is played, audio focus is requested,
 - whenever audio playback is stopped or the playback completed, audio focus is abandoned.
*/
var NotificationPlayer = {

<span id='com-android-systemui-media-NotificationPlayer-method-onCompletion'>/**
</span>*/
onCompletion : function(  ) {},

<span id='com-android-systemui-media-NotificationPlayer-method-onError'>/**
</span>*/
onError : function(  ) {},

<span id='com-android-systemui-media-NotificationPlayer-method-play'>/**Start playing the sound.  It will actually start playing at some
</span> point in the future.  There are no guarantees about latency here.
 Calling this before another audio file is done playing will stop
 that one and start the new one.
@param {Object {Context}} context Your application's context.
@param {Object {Uri}} uri The URI to play.  (see {@link MediaPlayer#setDataSource(Context, Uri)})
@param {Boolean} looping Whether the audio should loop forever.
          (see {@link MediaPlayer#setLooping(boolean)})
@param {Number} stream the AudioStream to use.
          (see {@link MediaPlayer#setAudioStreamType(int)})
@deprecated use {@link #play(Context, Uri, boolean, AudioAttributes)} instead.
*/
play : function(  ) {},

<span id='com-android-systemui-media-NotificationPlayer-method-play'>/**Start playing the sound.  It will actually start playing at some
</span> point in the future.  There are no guarantees about latency here.
 Calling this before another audio file is done playing will stop
 that one and start the new one.
@param {Object {Context}} context Your application's context.
@param {Object {Uri}} uri The URI to play.  (see {@link MediaPlayer#setDataSource(Context, Uri)})
@param {Boolean} looping Whether the audio should loop forever.
          (see {@link MediaPlayer#setLooping(boolean)})
@param {Object {AudioAttributes}} attributes the AudioAttributes to use.
          (see {@link MediaPlayer#setAudioAttributes(AudioAttributes)})
*/
play : function(  ) {},

<span id='com-android-systemui-media-NotificationPlayer-method-stop'>/**Stop a previously played sound.  It can't be played again or unpaused
</span> at this point.  Calling this multiple times has no ill effects.
*/
stop : function(  ) {},

<span id='com-android-systemui-media-NotificationPlayer-method-setUsesWakeLock'>/**We want to hold a wake lock while we do the prepare and play.  The stop probably is
</span> optional, but it won't hurt to have it too.  The problem is that if you start a sound
 while you're holding a wake lock (e.g. an alarm starting a notification), you want the
 sound to play, but if the CPU turns off before mThread gets to work, it won't.  The
 simplest way to deal with this is to make it so there is a wake lock held while the
 thread is starting or running.  You're going to need the WAKE_LOCK permission if you're
 going to call this.

 This must be called before the first time play is called.
@hide 
*/
setUsesWakeLock : function(  ) {},


};</pre>
</body>
</html>
