<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='java-time-temporal-TemporalAmount'>/**@class java.time.temporal.TemporalAmount
</span> Framework-level interface defining an amount of time, such as
 &quot;6 hours&quot;, &quot;8 days&quot; or &quot;2 years and 3 months&quot;.
 &lt;p&gt;
 This is the base interface type for amounts of time.
 An amount is distinct from a date or time-of-day in that it is not tied
 to any specific point on the time-line.
 &lt;p&gt;
 The amount can be thought of as a {@code Map} of {@link java.time.temporal.TemporalUnit} to
 {@code long}, exposed via {@link #getUnits}() and {@link #get}(TemporalUnit).
 A simple case might have a single unit-value pair, such as &quot;6 hours&quot;.
 A more complex case may have multiple unit-value pairs, such as
 &quot;7 years, 3 months and 5 days&quot;.
 &lt;p&gt;
 There are two common implementations.
 {@link Period} is a date-based implementation, storing years, months and days.
 {@link Duration} is a time-based implementation, storing seconds and nanoseconds,
 but providing some access using other duration based units such as minutes,
 hours and fixed 24-hour days.
 &lt;p&gt;
 This interface is a framework-level interface that should not be widely
 used in application code. Instead, applications should create and pass
 around instances of concrete types, such as {@code Period} and {@code Duration}.

 @implSpec
 This interface places no restrictions on the mutability of implementations,
 however immutability is strongly recommended.

 @since 1.8
*/
var TemporalAmount = {

<span id='java-time-temporal-TemporalAmount-method-get'>/**Returns the value of the requested unit.
</span> The units returned from {@link #getUnits}() uniquely define the
 value of the {@code TemporalAmount}.  A value must be returned
 for each unit listed in {@code getUnits}.
@param {Object {TemporalUnit}} unit the {@code TemporalUnit} for which to return the value
@param unit the {@code TemporalUnit} for which to return the value
@return {Number} the long value of the unit
@throws DateTimeException if a value for the unit cannot be obtained
@throws UnsupportedTemporalTypeException if the {@code unit} is not supported
*/
get : function(  ) {},

<span id='java-time-temporal-TemporalAmount-method-getUnits'>/**Returns the list of units uniquely defining the value of this TemporalAmount.
</span> The list of {@code TemporalUnits} is defined by the implementation class.
 The list is a snapshot of the units at the time {@code getUnits}
 is called and is not mutable.
 The units are ordered from longest duration to the shortest duration
 of the unit.
@implSpec The list of units completely and uniquely represents the
 state of the object without omissions, overlaps or duplication.
 The units are in order from longest duration to shortest.
@return {Object {java.util.List}} the List of {@code TemporalUnits}; not null
*/
getUnits : function(  ) {},

<span id='java-time-temporal-TemporalAmount-method-addTo'>/**Adds to the specified temporal object.
</span> &lt;p&gt;
 Adds the amount to the specified temporal object using the logic
 encapsulated in the implementing class.
 &lt;p&gt;
 There are two equivalent ways of using this method.
 The first is to invoke this method directly.
 The second is to use {@link java.time.temporal.Temporal#plus(java.time.temporal.TemporalAmount)}:
 &lt;pre&gt;
   // These two lines are equivalent, but the second approach is recommended
   dateTime = amount.addTo(dateTime);
   dateTime = dateTime.plus(adder);
 &lt;/pre&gt;
 It is recommended to use the second approach, {@code plus(TemporalAmount)},
 as it is a lot clearer to read in code.
@param {Object {Temporal}} temporal  the temporal object to add the amount to, not null
@param temporal  the temporal object to add the amount to, not null
@return {Object {java.time.temporal.Temporal}} an object of the same observable type with the addition made, not null
@throws DateTimeException if unable to add
@throws ArithmeticException if numeric overflow occurs
*/
addTo : function(  ) {},

<span id='java-time-temporal-TemporalAmount-method-subtractFrom'>/**Subtracts this object from the specified temporal object.
</span> &lt;p&gt;
 Subtracts the amount from the specified temporal object using the logic
 encapsulated in the implementing class.
 &lt;p&gt;
 There are two equivalent ways of using this method.
 The first is to invoke this method directly.
 The second is to use {@link java.time.temporal.Temporal#minus(java.time.temporal.TemporalAmount)}:
 &lt;pre&gt;
   // these two lines are equivalent, but the second approach is recommended
   dateTime = amount.subtractFrom(dateTime);
   dateTime = dateTime.minus(amount);
 &lt;/pre&gt;
 It is recommended to use the second approach, {@code minus(TemporalAmount)},
 as it is a lot clearer to read in code.
@param {Object {Temporal}} temporal  the temporal object to subtract the amount from, not null
@param temporal  the temporal object to subtract the amount from, not null
@return {Object {java.time.temporal.Temporal}} an object of the same observable type with the subtraction made, not null
@throws DateTimeException if unable to subtract
@throws ArithmeticException if numeric overflow occurs
*/
subtractFrom : function(  ) {},


};</pre>
</body>
</html>
